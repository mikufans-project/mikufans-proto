// This file is @generated by prost-build.
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AiAudio {
    ///
    #[prost(bool, tag = "1")]
    pub support_ai_audio: bool,
    ///
    #[prost(message, repeated, tag = "2")]
    pub ai_audio_items: ::prost::alloc::vec::Vec<AiAudioItem>,
    ///
    #[prost(string, tag = "3")]
    pub ai_open_toast: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub ai_close_toast: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub badge: ::core::option::Option<Badge>,
    ///
    #[prost(string, tag = "6")]
    pub default_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub list_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub list_desc: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AiAudioItem {
    ///
    #[prost(message, repeated, tag = "1")]
    pub audio_info: ::prost::alloc::vec::Vec<DashItem>,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub button_title: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArcConf {
    ///
    #[prost(bool, tag = "1")]
    pub is_support: bool,
    ///
    #[prost(bool, tag = "2")]
    pub disabled: bool,
    ///
    #[prost(message, optional, tag = "3")]
    pub extra_content: ::core::option::Option<ExtraContent>,
    ///
    #[prost(int32, repeated, tag = "4")]
    pub unsupport_scene: ::prost::alloc::vec::Vec<i32>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoQnCtl {
    ///
    #[prost(int64, tag = "1")]
    pub login_half: i64,
    ///
    #[prost(int64, tag = "2")]
    pub nologin_half: i64,
    ///
    #[prost(int64, tag = "3")]
    pub login_full: i64,
    ///
    #[prost(int64, tag = "4")]
    pub nologin_full: i64,
    ///
    #[prost(int64, tag = "5")]
    pub mobile_login_full: i64,
    ///
    #[prost(int64, tag = "6")]
    pub mobile_nologin_full: i64,
    ///
    #[prost(map = "string, message", tag = "7")]
    pub scene_qn_range: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AutoQnRange,
    >,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AutoQnRange {
    ///
    #[prost(int64, tag = "1")]
    pub max: i64,
    ///
    #[prost(int64, tag = "2")]
    pub min: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackgroundInfo {
    ///
    #[prost(string, tag = "1")]
    pub drawable_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub drawable_bitmap_url: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "Effects", tag = "3")]
    pub effects: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Badge {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub bg_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub bg_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub border_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub border_color_night: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "8")]
    pub bg_style: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BadgeInfo {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub bg_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub bg_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub text_color: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub bg_gradient_color: ::core::option::Option<GradientColor>,
    ///
    #[prost(string, tag = "6")]
    pub img: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Banner {
    ///
    #[prost(string, tag = "1")]
    pub jump_link: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub image_link: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub half_image_link: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub report: ::core::option::Option<Report>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BenefitInfo {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub icon: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BottomDisplay {
    ///
    #[prost(message, optional, tag = "1")]
    pub title: ::core::option::Option<TextInfo>,
    ///
    #[prost(string, tag = "2")]
    pub icon: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Button {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub link: ::prost::alloc::string::String,
    ///
    #[prost(map = "string, string", tag = "3")]
    pub report_params: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ButtonInfo {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub bg_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub bg_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub link: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "ButtonAction", tag = "7")]
    pub action_type: i32,
    ///
    #[prost(message, optional, tag = "8")]
    pub badge_info: ::core::option::Option<BadgeInfo>,
    ///
    #[prost(message, optional, tag = "9")]
    pub report: ::core::option::Option<Report>,
    ///
    #[prost(string, tag = "10")]
    pub left_strikethrough_text: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "11")]
    pub simple_text_info: ::core::option::Option<TextInfo>,
    ///
    #[prost(string, tag = "12")]
    pub simple_bg_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "13")]
    pub simple_bg_color_night: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "14")]
    pub bg_gradient_color: ::core::option::Option<GradientColor>,
    ///
    #[prost(map = "string, string", tag = "15")]
    pub order_report_params: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    ///
    #[prost(message, optional, tag = "16")]
    pub task_param: ::core::option::Option<TaskParam>,
    ///
    #[prost(string, tag = "17")]
    pub frame_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "18")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "19")]
    pub font_size: i32,
    ///
    #[prost(string, tag = "20")]
    pub tips_link: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "21")]
    pub deliver_code: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChargingExt {
    ///
    #[prost(bool, tag = "1")]
    pub hide_bg_img: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComprehensiveToast {
    ///
    #[prost(enumeration = "ToastType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub button: ::core::option::Option<ButtonInfo>,
    ///
    #[prost(enumeration = "ShowStyleType", tag = "3")]
    pub show_style_type: i32,
    ///
    #[prost(string, tag = "4")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub toast_text: ::core::option::Option<TextInfo>,
    ///
    #[prost(message, optional, tag = "6")]
    pub report: ::core::option::Option<Report>,
    ///
    #[prost(map = "string, string", tag = "7")]
    pub order_report_params: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConfValue {
    ///
    #[prost(oneof = "conf_value::Value", tags = "1, 2")]
    pub value: ::core::option::Option<conf_value::Value>,
}
/// Nested message and enum types in `ConfValue`.
pub mod conf_value {
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Value {
        ///
        #[prost(bool, tag = "1")]
        SwitchVal(bool),
        ///
        #[prost(int64, tag = "2")]
        SelectedVal(i64),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CountDownItem {
    ///
    #[prost(int64, tag = "1")]
    pub fold_countdown: i64,
    ///
    #[prost(message, optional, tag = "2")]
    pub title: ::core::option::Option<TextInfo>,
    ///
    #[prost(message, optional, tag = "3")]
    pub subtitle: ::core::option::Option<TextInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DashItem {
    ///
    #[prost(int32, tag = "1")]
    pub id: i32,
    ///
    #[prost(string, tag = "2")]
    pub base_url: ::prost::alloc::string::String,
    ///
    #[prost(string, repeated, tag = "3")]
    pub backup_url: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(int32, tag = "4")]
    pub bandwidth: i32,
    ///
    #[prost(int32, tag = "5")]
    pub codecid: i32,
    ///
    #[prost(string, tag = "6")]
    pub md5: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "7")]
    pub size: i64,
    ///
    #[prost(string, tag = "8")]
    pub frame_rate: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub widevine_pssh: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub bilidrm_uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DashVideo {
    ///
    #[prost(string, tag = "1")]
    pub base_url: ::prost::alloc::string::String,
    ///
    #[prost(string, repeated, tag = "2")]
    pub backup_url: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(int32, tag = "3")]
    pub bandwidth: i32,
    ///
    #[prost(int32, tag = "4")]
    pub codecid: i32,
    ///
    #[prost(string, tag = "5")]
    pub md5: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "6")]
    pub size: i64,
    ///
    #[prost(int32, tag = "7")]
    pub audio_id: i32,
    ///
    #[prost(bool, tag = "8")]
    pub no_rexcode: bool,
    ///
    #[prost(string, tag = "9")]
    pub frame_rate: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "10")]
    pub width: i32,
    ///
    #[prost(int32, tag = "11")]
    pub height: i32,
    ///
    #[prost(string, tag = "12")]
    pub widevine_pssh: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "13")]
    pub bilidrm_uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeviceConf {
    ///
    #[prost(message, optional, tag = "1")]
    pub conf_value: ::core::option::Option<ConfValue>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dialog {
    ///
    #[prost(enumeration = "GuideStyle", tag = "1")]
    pub style_type: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub background_info: ::core::option::Option<BackgroundInfo>,
    ///
    #[prost(message, optional, tag = "3")]
    pub title: ::core::option::Option<TextInfo>,
    ///
    #[prost(message, optional, tag = "4")]
    pub subtitle: ::core::option::Option<TextInfo>,
    ///
    #[prost(message, optional, tag = "5")]
    pub image: ::core::option::Option<ImageInfo>,
    ///
    #[prost(message, repeated, tag = "6")]
    pub button: ::prost::alloc::vec::Vec<ButtonInfo>,
    ///
    #[prost(message, optional, tag = "7")]
    pub bottom_desc: ::core::option::Option<ButtonInfo>,
    ///
    #[prost(message, optional, tag = "8")]
    pub report: ::core::option::Option<Report>,
    ///
    #[prost(int32, tag = "9")]
    pub count_down_sec: i32,
    ///
    #[prost(message, optional, tag = "10")]
    pub right_bottom_desc: ::core::option::Option<TextInfo>,
    ///
    #[prost(message, repeated, tag = "11")]
    pub bottom_display: ::prost::alloc::vec::Vec<BottomDisplay>,
    ///
    #[prost(message, optional, tag = "12")]
    pub ext_data: ::core::option::Option<ExtData>,
    ///
    #[prost(enumeration = "LimitActionType", tag = "13")]
    pub limit_action_type: i32,
    ///
    #[prost(int32, tag = "14")]
    pub is_hide_more_btn: i32,
    ///
    #[prost(int32, tag = "15")]
    pub hide_button_on_half: i32,
    ///
    #[prost(string, tag = "16")]
    pub deliver_win_id: ::prost::alloc::string::String,
    ///
    #[prost(map = "string, string", tag = "17")]
    pub conditions: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Dimension {
    ///
    #[prost(int64, tag = "1")]
    pub width: i64,
    ///
    #[prost(int64, tag = "2")]
    pub height: i64,
    ///
    #[prost(int64, tag = "3")]
    pub rotate: i64,
    ///
    #[prost(int64, tag = "4")]
    pub variable: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DolbyItem {
    ///
    #[prost(enumeration = "dolby_item::Type", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(message, repeated, tag = "2")]
    pub audio: ::prost::alloc::vec::Vec<DashItem>,
}
/// Nested message and enum types in `DolbyItem`.
pub mod dolby_item {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        ///
        None = 0,
        ///
        Common = 1,
        ///
        Atmos = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::Common => "COMMON",
                Self::Atmos => "ATMOS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "COMMON" => Some(Self::Common),
                "ATMOS" => Some(Self::Atmos),
                _ => None,
            }
        }
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EpInlineVideo {
    ///
    #[prost(int64, tag = "1")]
    pub material_no: i64,
    ///
    #[prost(int64, tag = "2")]
    pub aid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub cid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EpInlineVideoInfo {
    ///
    #[prost(message, repeated, tag = "1")]
    pub ep_inline_video: ::prost::alloc::vec::Vec<EpInlineVideo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    ///
    #[prost(message, optional, tag = "1")]
    pub shake: ::core::option::Option<Shake>,
    ///
    #[prost(message, optional, tag = "2")]
    pub qn_tip: ::core::option::Option<QnTip>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpSwitch {
    ///
    #[prost(int32, tag = "2")]
    pub hit_opti_try_watch: i32,
    ///
    #[prost(map = "string, string", tag = "3")]
    pub exp_ab: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtData {
    ///
    #[prost(enumeration = "ExtDataType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(oneof = "ext_data::Data", tags = "2, 3, 4, 5, 6")]
    pub data: ::core::option::Option<ext_data::Data>,
}
/// Nested message and enum types in `ExtData`.
pub mod ext_data {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        ///
        #[prost(message, tag = "2")]
        PlayListInfo(super::PlayListInfo),
        ///
        #[prost(message, tag = "3")]
        Banner(super::Banner),
        ///
        #[prost(message, tag = "4")]
        EpInlineVideoInfo(super::EpInlineVideoInfo),
        ///
        #[prost(message, tag = "5")]
        ChargingExt(super::ChargingExt),
        ///
        #[prost(message, tag = "6")]
        QrCode(super::QrCode),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtraContent {
    ///
    #[prost(string, tag = "1")]
    pub disabled_reason: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub disabled_code: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FoldData {
    ///
    #[prost(enumeration = "FoldStyle", tag = "1")]
    pub fold_style: i32,
    ///
    #[prost(oneof = "fold_data::Data", tags = "2")]
    pub data: ::core::option::Option<fold_data::Data>,
}
/// Nested message and enum types in `FoldData`.
pub mod fold_data {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        ///
        #[prost(message, tag = "2")]
        CountDown(super::CountDownItem),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fragment {
    ///
    #[prost(message, repeated, tag = "1")]
    pub infos: ::prost::alloc::vec::Vec<FragmentInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FragmentInfo {
    ///
    #[prost(int32, tag = "1")]
    pub index: i32,
    ///
    #[prost(enumeration = "FragmentPosition", tag = "2")]
    pub fragment_position: i32,
    ///
    #[prost(enumeration = "FragmentType", tag = "3")]
    pub fragment_type: i32,
    ///
    #[prost(int64, tag = "4")]
    pub aid: i64,
    ///
    #[prost(int64, tag = "5")]
    pub cid: i64,
    ///
    #[prost(int64, tag = "6")]
    pub start_time: i64,
    ///
    #[prost(message, optional, tag = "7")]
    pub report: ::core::option::Option<::prost_types::Any>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FragmentVideo {
    ///
    #[prost(message, repeated, tag = "1")]
    pub videos: ::prost::alloc::vec::Vec<FragmentVideoInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FragmentVideoInfo {
    ///
    #[prost(message, optional, tag = "1")]
    pub fragment_info: ::core::option::Option<FragmentInfo>,
    ///
    #[prost(message, optional, tag = "2")]
    pub vod_info: ::core::option::Option<VodInfo>,
    ///
    #[prost(message, optional, tag = "3")]
    pub play_arc_conf: ::core::option::Option<PlayArcConf>,
    ///
    #[prost(message, optional, tag = "4")]
    pub dimension: ::core::option::Option<Dimension>,
    ///
    #[prost(int64, tag = "5")]
    pub timelength: i64,
    ///
    #[prost(enumeration = "BizType", tag = "6")]
    pub video_type: i32,
    ///
    #[prost(bool, tag = "7")]
    pub playable_status: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FullPromptBar {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub title: ::core::option::Option<TextInfo>,
    ///
    #[prost(int64, tag = "3")]
    pub timer_countdown: i64,
    ///
    #[prost(bool, tag = "4")]
    pub countdown_enable: bool,
    ///
    #[prost(message, optional, tag = "5")]
    pub subtitle: ::core::option::Option<TextInfo>,
    ///
    #[prost(message, repeated, tag = "6")]
    pub button: ::prost::alloc::vec::Vec<ButtonInfo>,
    ///
    #[prost(message, optional, tag = "7")]
    pub fold_data: ::core::option::Option<FoldData>,
    ///
    #[prost(message, optional, tag = "8")]
    pub report: ::core::option::Option<Report>,
    ///
    #[prost(string, tag = "9")]
    pub bg_image: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "10")]
    pub bar_height: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GradientColor {
    ///
    #[prost(string, tag = "1")]
    pub start_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub end_color: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct History {
    ///
    #[prost(message, optional, tag = "1")]
    pub current_video: ::core::option::Option<HistoryInfo>,
    ///
    #[prost(message, optional, tag = "2")]
    pub related_video: ::core::option::Option<HistoryInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistoryInfo {
    ///
    #[prost(int64, tag = "1")]
    pub progress: i64,
    ///
    #[prost(int64, tag = "2")]
    pub last_play_cid: i64,
    ///
    #[prost(message, optional, tag = "3")]
    pub toast: ::core::option::Option<Toast>,
    ///
    #[prost(message, optional, tag = "4")]
    pub toast_without_time: ::core::option::Option<Toast>,
    ///
    #[prost(int64, tag = "5")]
    pub last_play_aid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageInfo {
    ///
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Interaction {
    ///
    #[prost(message, optional, tag = "1")]
    pub history_node: ::core::option::Option<Node>,
    ///
    #[prost(int64, tag = "2")]
    pub graph_version: i64,
    ///
    #[prost(string, tag = "3")]
    pub msg: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub mark: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LossLessItem {
    ///
    #[prost(bool, tag = "1")]
    pub is_lossless_audio: bool,
    ///
    #[prost(message, optional, tag = "2")]
    pub audio: ::core::option::Option<DashItem>,
    ///
    #[prost(bool, tag = "3")]
    pub need_vip: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Node {
    ///
    #[prost(int64, tag = "1")]
    pub node_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub cid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PayWallOnshowAction {
    ///
    #[prost(string, tag = "1")]
    pub link: ::prost::alloc::string::String,
    ///
    #[prost(map = "string, string", tag = "2")]
    pub order_report_params: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    ///
    #[prost(enumeration = "ButtonAction", tag = "3")]
    pub action_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayArc {
    ///
    #[prost(enumeration = "BizType", tag = "1")]
    pub video_type: i32,
    ///
    #[prost(int64, tag = "2")]
    pub aid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub cid: i64,
    ///
    #[prost(enumeration = "DrmTechType", tag = "4")]
    pub drm_tech_type: i32,
    ///
    #[prost(enumeration = "ArcType", tag = "5")]
    pub arc_type: i32,
    ///
    #[prost(message, optional, tag = "6")]
    pub interaction: ::core::option::Option<Interaction>,
    ///
    #[prost(message, optional, tag = "7")]
    pub dimension: ::core::option::Option<Dimension>,
    ///
    #[prost(int64, tag = "8")]
    pub duration: i64,
    ///
    #[prost(bool, tag = "9")]
    pub is_preview: bool,
    ///
    #[prost(int64, tag = "10")]
    pub watch_time_length: i64,
    ///
    #[prost(int64, tag = "11")]
    pub duration_ms: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayArcConf {
    ///
    #[prost(map = "int32, message", tag = "1")]
    pub arc_confs: ::std::collections::HashMap<i32, ArcConf>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayDeviceConf {
    ///
    #[prost(map = "int32, message", tag = "1")]
    pub device_confs: ::std::collections::HashMap<i32, DeviceConf>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayList {
    ///
    #[prost(int64, tag = "1")]
    pub season_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub link: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub badge_info: ::core::option::Option<BadgeInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayListInfo {
    ///
    #[prost(message, repeated, tag = "2")]
    pub play_list: ::prost::alloc::vec::Vec<PlayList>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromptBar {
    ///
    #[prost(message, optional, tag = "1")]
    pub title: ::core::option::Option<TextInfo>,
    ///
    #[prost(message, optional, tag = "2")]
    pub sub_title: ::core::option::Option<TextInfo>,
    ///
    #[prost(string, tag = "3")]
    pub sub_title_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub bg_image: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub bg_gradient_color: ::core::option::Option<GradientColor>,
    ///
    #[prost(message, repeated, tag = "6")]
    pub button: ::prost::alloc::vec::Vec<ButtonInfo>,
    ///
    #[prost(message, optional, tag = "7")]
    pub report: ::core::option::Option<Report>,
    ///
    #[prost(string, tag = "8")]
    pub full_screen_ip_icon: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "9")]
    pub full_screen_bg_gradient_color: ::core::option::Option<GradientColor>,
    ///
    #[prost(enumeration = "PromptBarType", tag = "10")]
    pub prompt_bar_type: i32,
    ///
    #[prost(enumeration = "PromptBarStyle", tag = "11")]
    pub prompt_bar_style: i32,
    ///
    #[prost(message, repeated, tag = "12")]
    pub benefit_infos: ::prost::alloc::vec::Vec<BenefitInfo>,
    ///
    #[prost(int64, tag = "13")]
    pub end_time: i64,
    ///
    #[prost(int32, tag = "14")]
    pub show_on_paywall: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QnExp {
    ///
    #[prost(bool, tag = "1")]
    pub qn_exp1: bool,
    ///
    #[prost(bool, tag = "2")]
    pub qn_exp2: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QnTip {
    ///
    #[prost(string, tag = "1")]
    pub msg: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QnTrialInfo {
    ///
    #[prost(bool, tag = "1")]
    pub trial_able: bool,
    ///
    #[prost(int32, tag = "2")]
    pub remaining_times: i32,
    ///
    #[prost(int32, tag = "3")]
    pub start: i32,
    ///
    #[prost(int32, tag = "4")]
    pub time_length: i32,
    ///
    #[prost(message, optional, tag = "5")]
    pub start_toast: ::core::option::Option<Toast>,
    ///
    #[prost(message, optional, tag = "6")]
    pub end_toast: ::core::option::Option<Toast>,
    ///
    #[prost(message, optional, tag = "8")]
    pub quality_open_tip_btn: ::core::option::Option<Button>,
    ///
    #[prost(int32, tag = "9")]
    pub trial_quality_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QrCode {
    ///
    #[prost(string, tag = "1")]
    pub link: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub link_desc: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Report {
    ///
    #[prost(string, tag = "1")]
    pub show_event_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub click_event_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub extends: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResidentBar {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub question_text: ::core::option::Option<TextInfo>,
    ///
    #[prost(message, optional, tag = "3")]
    pub button: ::core::option::Option<ButtonInfo>,
    ///
    #[prost(string, tag = "4")]
    pub link: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub report: ::core::option::Option<Report>,
    ///
    #[prost(string, tag = "6")]
    pub bg_image: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseDash {
    ///
    #[prost(message, repeated, tag = "1")]
    pub video: ::prost::alloc::vec::Vec<DashItem>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub audio: ::prost::alloc::vec::Vec<DashItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseUrl {
    ///
    #[prost(int32, tag = "1")]
    pub order: i32,
    ///
    #[prost(int64, tag = "2")]
    pub length: i64,
    ///
    #[prost(int64, tag = "3")]
    pub size: i64,
    ///
    #[prost(string, tag = "4")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, repeated, tag = "5")]
    pub backup_url: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(string, tag = "6")]
    pub md5: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Scheme {
    ///
    #[prost(enumeration = "scheme::ActionType", tag = "1")]
    pub action_type: i32,
    ///
    #[prost(string, tag = "2")]
    pub toast: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Scheme`.
pub mod scheme {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ActionType {
        ///
        UnknownActionType = 0,
        ///
        ShowToast = 1,
    }
    impl ActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownActionType => "UNKNOWN_ActionType",
                Self::ShowToast => "SHOW_TOAST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_ActionType" => Some(Self::UnknownActionType),
                "SHOW_TOAST" => Some(Self::ShowToast),
                _ => None,
            }
        }
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SegmentVideo {
    ///
    #[prost(message, repeated, tag = "1")]
    pub segment: ::prost::alloc::vec::Vec<ResponseUrl>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettingBase {
    ///
    #[prost(string, tag = "1")]
    pub left_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub left_title: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "SettingItemType", tag = "3")]
    pub r#type: i32,
    ///
    #[prost(message, optional, tag = "4")]
    pub control: ::core::option::Option<SettingControl>,
    ///
    #[prost(map = "string, string", tag = "5")]
    pub report: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettingControl {
    ///
    #[prost(bool, tag = "1")]
    pub disabled: bool,
    ///
    #[prost(string, tag = "2")]
    pub disabled_reason: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "3")]
    pub disable_gray: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettingGroup {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<SettingItem>,
    ///
    #[prost(enumeration = "GroupStyle", tag = "3")]
    pub group_style: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettingItem {
    ///
    #[prost(message, optional, tag = "1")]
    pub base: ::core::option::Option<SettingBase>,
    ///
    #[prost(enumeration = "SettingItemStyle", tag = "2")]
    pub style: i32,
    ///
    #[prost(oneof = "setting_item::Value", tags = "3, 4, 5")]
    pub value: ::core::option::Option<setting_item::Value>,
}
/// Nested message and enum types in `SettingItem`.
pub mod setting_item {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        ///
        #[prost(message, tag = "3")]
        More(super::SettingMore),
        ///
        #[prost(message, tag = "4")]
        Vertical(super::SettingVertical),
        ///
        #[prost(message, tag = "5")]
        Switch(super::SettingSwitch),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettingMore {
    ///
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub right_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub right_icon: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "SettingJumpType", tag = "4")]
    pub jump_type: i32,
    ///
    #[prost(bool, tag = "5")]
    pub need_login: bool,
    ///
    #[prost(message, optional, tag = "6")]
    pub badge: ::core::option::Option<Badge>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettingSwitch {
    ///
    #[prost(message, optional, tag = "1")]
    pub badge: ::core::option::Option<Badge>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettingVertical {
    ///
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "SettingJumpType", tag = "2")]
    pub jump_type: i32,
    ///
    #[prost(bool, tag = "3")]
    pub need_login: bool,
    ///
    #[prost(message, optional, tag = "4")]
    pub badge: ::core::option::Option<Badge>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Shake {
    ///
    #[prost(string, tag = "1")]
    pub file: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stream {
    ///
    #[prost(message, optional, tag = "1")]
    pub stream_info: ::core::option::Option<StreamInfo>,
    ///
    #[prost(oneof = "stream::Content", tags = "2, 3")]
    pub content: ::core::option::Option<stream::Content>,
}
/// Nested message and enum types in `Stream`.
pub mod stream {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        ///
        #[prost(message, tag = "2")]
        DashVideo(super::DashVideo),
        ///
        #[prost(message, tag = "3")]
        SegmentVideo(super::SegmentVideo),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamInfo {
    ///
    #[prost(int32, tag = "1")]
    pub quality: i32,
    ///
    #[prost(string, tag = "2")]
    pub format: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "PlayErr", tag = "4")]
    pub err_code: i32,
    ///
    #[prost(message, optional, tag = "5")]
    pub limit: ::core::option::Option<StreamLimit>,
    ///
    #[prost(bool, tag = "6")]
    pub need_vip: bool,
    ///
    #[prost(bool, tag = "7")]
    pub need_login: bool,
    ///
    #[prost(bool, tag = "8")]
    pub intact: bool,
    ///
    #[prost(bool, tag = "9")]
    pub no_rexcode: bool,
    ///
    #[prost(int64, tag = "10")]
    pub attribute: i64,
    ///
    #[prost(string, tag = "11")]
    pub new_description: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "12")]
    pub display_desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "13")]
    pub superscript: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "14")]
    pub vip_free: bool,
    ///
    #[prost(string, tag = "15")]
    pub subtitle: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "16")]
    pub scheme: ::core::option::Option<Scheme>,
    ///
    #[prost(bool, tag = "17")]
    pub support_drm: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamLimit {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub msg: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskParam {
    ///
    #[prost(string, tag = "1")]
    pub task_type: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub activity_id: i64,
    ///
    #[prost(int64, tag = "3")]
    pub tips_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextInfo {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text_color_night: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "4")]
    pub font_size: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Toast {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub button: ::core::option::Option<Button>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoCtrl {
    ///
    #[prost(message, optional, tag = "1")]
    pub auto_qn_ctl: ::core::option::Option<AutoQnCtl>,
    ///
    #[prost(message, optional, tag = "2")]
    pub qn_exp: ::core::option::Option<QnExp>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VideoVod {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub cid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub qn: i64,
    ///
    #[prost(int32, tag = "4")]
    pub fnver: i32,
    ///
    #[prost(int32, tag = "5")]
    pub fnval: i32,
    ///
    #[prost(int32, tag = "6")]
    pub download: i32,
    ///
    #[prost(int32, tag = "7")]
    pub force_host: i32,
    ///
    #[prost(bool, tag = "8")]
    pub fourk: bool,
    ///
    #[prost(enumeration = "CodeType", tag = "9")]
    pub prefer_codec_type: i32,
    ///
    #[prost(int64, tag = "10")]
    pub voice_balance: i64,
    ///
    #[prost(bool, tag = "11")]
    pub is_need_trial: bool,
    ///
    #[prost(enumeration = "QnPolicy", tag = "12")]
    pub qn_policy: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewInfo {
    ///
    #[prost(map = "string, message", tag = "1")]
    pub dialog_map: ::std::collections::HashMap<::prost::alloc::string::String, Dialog>,
    ///
    #[prost(message, optional, tag = "2")]
    pub prompt_bar: ::core::option::Option<PromptBar>,
    ///
    #[prost(message, repeated, tag = "3")]
    pub toasts: ::prost::alloc::vec::Vec<ComprehensiveToast>,
    ///
    #[prost(message, optional, tag = "4")]
    pub pay_wall_onshow_action: ::core::option::Option<PayWallOnshowAction>,
    ///
    #[prost(message, optional, tag = "5")]
    pub exp_switch: ::core::option::Option<ExpSwitch>,
    ///
    #[prost(message, optional, tag = "6")]
    pub full_prompt_bar: ::core::option::Option<FullPromptBar>,
    ///
    #[prost(message, optional, tag = "7")]
    pub resident_bar: ::core::option::Option<ResidentBar>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VodInfo {
    ///
    #[prost(int32, tag = "1")]
    pub quality: i32,
    ///
    #[prost(string, tag = "2")]
    pub format: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub timelength: i64,
    ///
    #[prost(int32, tag = "4")]
    pub video_codecid: i32,
    ///
    #[prost(message, repeated, tag = "5")]
    pub stream_list: ::prost::alloc::vec::Vec<Stream>,
    ///
    #[prost(message, repeated, tag = "6")]
    pub dash_audio: ::prost::alloc::vec::Vec<DashItem>,
    ///
    #[prost(message, optional, tag = "7")]
    pub dolby: ::core::option::Option<DolbyItem>,
    ///
    #[prost(message, optional, tag = "8")]
    pub volume: ::core::option::Option<VolumeInfo>,
    ///
    #[prost(message, optional, tag = "9")]
    pub loss_less_item: ::core::option::Option<LossLessItem>,
    ///
    #[prost(bool, tag = "10")]
    pub support_project: bool,
    ///
    #[prost(message, optional, tag = "11")]
    pub ai_audio: ::core::option::Option<AiAudio>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VolumeInfo {
    ///
    #[prost(double, tag = "1")]
    pub measured_i: f64,
    ///
    #[prost(double, tag = "2")]
    pub measured_lra: f64,
    ///
    #[prost(double, tag = "3")]
    pub measured_tp: f64,
    ///
    #[prost(double, tag = "4")]
    pub measured_threshold: f64,
    ///
    #[prost(double, tag = "5")]
    pub target_offset: f64,
    ///
    #[prost(double, tag = "6")]
    pub target_i: f64,
    ///
    #[prost(double, tag = "7")]
    pub target_tp: f64,
    ///
    #[prost(map = "string, string", tag = "8")]
    pub multi_scene_args: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ArcType {
    ///
    Normal = 0,
    ///
    Interact = 1,
}
impl ArcType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Normal => "ARC_TYPE_NORMAL",
            Self::Interact => "ARC_TYPE_INTERACT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ARC_TYPE_NORMAL" => Some(Self::Normal),
            "ARC_TYPE_INTERACT" => Some(Self::Interact),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BizType {
    ///
    Unknown = 0,
    ///
    Ugc = 1,
    ///
    Pgc = 2,
    ///
    Pugv = 3,
}
impl BizType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "BIZ_TYPE_UNKNOWN",
            Self::Ugc => "BIZ_TYPE_UGC",
            Self::Pgc => "BIZ_TYPE_PGC",
            Self::Pugv => "BIZ_TYPE_PUGV",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BIZ_TYPE_UNKNOWN" => Some(Self::Unknown),
            "BIZ_TYPE_UGC" => Some(Self::Ugc),
            "BIZ_TYPE_PGC" => Some(Self::Pgc),
            "BIZ_TYPE_PUGV" => Some(Self::Pugv),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ButtonAction {
    ///
    ButtonUnknown = 0,
    ///
    Pay = 1,
    ///
    Vip = 2,
    ///
    Pack = 3,
    ///
    Link = 4,
    ///
    Coupon = 5,
    ///
    Demand = 6,
    ///
    DemandPack = 7,
    ///
    Follow = 8,
    ///
    Appointment = 9,
    ///
    VipFree = 10,
    ///
    Task = 11,
    ///
    Chargingplus = 12,
    ///
    Bp = 13,
    ///
    PreSell = 14,
    ///
    Login = 15,
    ///
    CheesePay = 16,
    ///
    DeliverReport = 17,
    ///
    DeviceManage = 18,
    ///
    Reload = 19,
}
impl ButtonAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ButtonUnknown => "BUTTON_UNKNOWN",
            Self::Pay => "PAY",
            Self::Vip => "VIP",
            Self::Pack => "PACK",
            Self::Link => "LINK",
            Self::Coupon => "COUPON",
            Self::Demand => "DEMAND",
            Self::DemandPack => "DEMAND_PACK",
            Self::Follow => "FOLLOW",
            Self::Appointment => "APPOINTMENT",
            Self::VipFree => "VIP_FREE",
            Self::Task => "TASK",
            Self::Chargingplus => "CHARGINGPLUS",
            Self::Bp => "BP",
            Self::PreSell => "PRE_SELL",
            Self::Login => "LOGIN",
            Self::CheesePay => "BUTTON_ACTION_CHEESE_PAY",
            Self::DeliverReport => "DELIVER_REPORT",
            Self::DeviceManage => "DEVICE_MANAGE",
            Self::Reload => "RELOAD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BUTTON_UNKNOWN" => Some(Self::ButtonUnknown),
            "PAY" => Some(Self::Pay),
            "VIP" => Some(Self::Vip),
            "PACK" => Some(Self::Pack),
            "LINK" => Some(Self::Link),
            "COUPON" => Some(Self::Coupon),
            "DEMAND" => Some(Self::Demand),
            "DEMAND_PACK" => Some(Self::DemandPack),
            "FOLLOW" => Some(Self::Follow),
            "APPOINTMENT" => Some(Self::Appointment),
            "VIP_FREE" => Some(Self::VipFree),
            "TASK" => Some(Self::Task),
            "CHARGINGPLUS" => Some(Self::Chargingplus),
            "BP" => Some(Self::Bp),
            "PRE_SELL" => Some(Self::PreSell),
            "LOGIN" => Some(Self::Login),
            "BUTTON_ACTION_CHEESE_PAY" => Some(Self::CheesePay),
            "DELIVER_REPORT" => Some(Self::DeliverReport),
            "DEVICE_MANAGE" => Some(Self::DeviceManage),
            "RELOAD" => Some(Self::Reload),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CodeType {
    ///
    Nocode = 0,
    ///
    Code264 = 1,
    ///
    Code265 = 2,
    ///
    Codeav1 = 3,
}
impl CodeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Nocode => "NOCODE",
            Self::Code264 => "CODE264",
            Self::Code265 => "CODE265",
            Self::Codeav1 => "CODEAV1",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NOCODE" => Some(Self::Nocode),
            "CODE264" => Some(Self::Code264),
            "CODE265" => Some(Self::Code265),
            "CODEAV1" => Some(Self::Codeav1),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConfType {
    ///
    NoType = 0,
    ///
    Flipconf = 1,
    ///
    Castconf = 2,
    ///
    Feedback = 3,
    ///
    Subtitle = 4,
    ///
    Playbackrate = 5,
    ///
    Timeup = 6,
    ///
    Playbackmode = 7,
    ///
    Scalemode = 8,
    ///
    Backgroundplay = 9,
    ///
    Like = 10,
    ///
    Dislike = 11,
    ///
    Coin = 12,
    ///
    Elec = 13,
    ///
    Share = 14,
    ///
    Screenshot = 15,
    ///
    Lockscreen = 16,
    ///
    Recommend = 17,
    ///
    Playbackspeed = 18,
    ///
    Definition = 19,
    ///
    Selections = 20,
    ///
    Next = 21,
    ///
    Editdm = 22,
    ///
    Smallwindow = 23,
    ///
    Shake = 24,
    ///
    Outerdm = 25,
    ///
    Innerdm = 26,
    ///
    Panorama = 27,
    ///
    Dolby = 28,
    ///
    Colorfilter = 29,
    ///
    Lossless = 30,
    ///
    Freyaenter = 31,
    ///
    Freyafullenter = 32,
    ///
    Skipoped = 33,
    ///
    Recordscreen = 34,
    ///
    Dubbing = 35,
    ///
    Listen = 36,
    ///
    WatchLater = 37,
}
impl ConfType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoType => "NoType",
            Self::Flipconf => "FLIPCONF",
            Self::Castconf => "CASTCONF",
            Self::Feedback => "FEEDBACK",
            Self::Subtitle => "SUBTITLE",
            Self::Playbackrate => "PLAYBACKRATE",
            Self::Timeup => "TIMEUP",
            Self::Playbackmode => "PLAYBACKMODE",
            Self::Scalemode => "SCALEMODE",
            Self::Backgroundplay => "BACKGROUNDPLAY",
            Self::Like => "LIKE",
            Self::Dislike => "DISLIKE",
            Self::Coin => "COIN",
            Self::Elec => "ELEC",
            Self::Share => "SHARE",
            Self::Screenshot => "SCREENSHOT",
            Self::Lockscreen => "LOCKSCREEN",
            Self::Recommend => "RECOMMEND",
            Self::Playbackspeed => "PLAYBACKSPEED",
            Self::Definition => "DEFINITION",
            Self::Selections => "SELECTIONS",
            Self::Next => "NEXT",
            Self::Editdm => "EDITDM",
            Self::Smallwindow => "SMALLWINDOW",
            Self::Shake => "SHAKE",
            Self::Outerdm => "OUTERDM",
            Self::Innerdm => "INNERDM",
            Self::Panorama => "PANORAMA",
            Self::Dolby => "DOLBY",
            Self::Colorfilter => "COLORFILTER",
            Self::Lossless => "LOSSLESS",
            Self::Freyaenter => "FREYAENTER",
            Self::Freyafullenter => "FREYAFULLENTER",
            Self::Skipoped => "SKIPOPED",
            Self::Recordscreen => "RECORDSCREEN",
            Self::Dubbing => "DUBBING",
            Self::Listen => "LISTEN",
            Self::WatchLater => "WATCH_LATER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NoType" => Some(Self::NoType),
            "FLIPCONF" => Some(Self::Flipconf),
            "CASTCONF" => Some(Self::Castconf),
            "FEEDBACK" => Some(Self::Feedback),
            "SUBTITLE" => Some(Self::Subtitle),
            "PLAYBACKRATE" => Some(Self::Playbackrate),
            "TIMEUP" => Some(Self::Timeup),
            "PLAYBACKMODE" => Some(Self::Playbackmode),
            "SCALEMODE" => Some(Self::Scalemode),
            "BACKGROUNDPLAY" => Some(Self::Backgroundplay),
            "LIKE" => Some(Self::Like),
            "DISLIKE" => Some(Self::Dislike),
            "COIN" => Some(Self::Coin),
            "ELEC" => Some(Self::Elec),
            "SHARE" => Some(Self::Share),
            "SCREENSHOT" => Some(Self::Screenshot),
            "LOCKSCREEN" => Some(Self::Lockscreen),
            "RECOMMEND" => Some(Self::Recommend),
            "PLAYBACKSPEED" => Some(Self::Playbackspeed),
            "DEFINITION" => Some(Self::Definition),
            "SELECTIONS" => Some(Self::Selections),
            "NEXT" => Some(Self::Next),
            "EDITDM" => Some(Self::Editdm),
            "SMALLWINDOW" => Some(Self::Smallwindow),
            "SHAKE" => Some(Self::Shake),
            "OUTERDM" => Some(Self::Outerdm),
            "INNERDM" => Some(Self::Innerdm),
            "PANORAMA" => Some(Self::Panorama),
            "DOLBY" => Some(Self::Dolby),
            "COLORFILTER" => Some(Self::Colorfilter),
            "LOSSLESS" => Some(Self::Lossless),
            "FREYAENTER" => Some(Self::Freyaenter),
            "FREYAFULLENTER" => Some(Self::Freyafullenter),
            "SKIPOPED" => Some(Self::Skipoped),
            "RECORDSCREEN" => Some(Self::Recordscreen),
            "DUBBING" => Some(Self::Dubbing),
            "LISTEN" => Some(Self::Listen),
            "WATCH_LATER" => Some(Self::WatchLater),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DrmTechType {
    ///
    UnknownDrm = 0,
    ///
    FairPlay = 1,
    ///
    WideVine = 2,
    ///
    BiliDrm = 3,
}
impl DrmTechType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownDrm => "UNKNOWN_DRM",
            Self::FairPlay => "FAIR_PLAY",
            Self::WideVine => "WIDE_VINE",
            Self::BiliDrm => "BILI_DRM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_DRM" => Some(Self::UnknownDrm),
            "FAIR_PLAY" => Some(Self::FairPlay),
            "WIDE_VINE" => Some(Self::WideVine),
            "BILI_DRM" => Some(Self::BiliDrm),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Effects {
    ///
    Unknown = 0,
    ///
    GaussianBlur = 1,
    ///
    HalfAlpha = 2,
}
impl Effects {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "EFFECTS_UNKNOWN",
            Self::GaussianBlur => "GAUSSIAN_BLUR",
            Self::HalfAlpha => "HALF_ALPHA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EFFECTS_UNKNOWN" => Some(Self::Unknown),
            "GAUSSIAN_BLUR" => Some(Self::GaussianBlur),
            "HALF_ALPHA" => Some(Self::HalfAlpha),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExtDataType {
    ///
    Unknown = 0,
    ///
    PlayList = 1,
    ///
    Banner = 2,
    ///
    HeInline = 3,
    ///
    Charging = 4,
    ///
    QrCode = 5,
}
impl ExtDataType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "EXT_DATA_TYPE_UNKNOWN",
            Self::PlayList => "PLAY_LIST",
            Self::Banner => "BANNER",
            Self::HeInline => "HE_INLINE",
            Self::Charging => "EXT_DATA_TYPE_CHARGING",
            Self::QrCode => "QR_CODE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EXT_DATA_TYPE_UNKNOWN" => Some(Self::Unknown),
            "PLAY_LIST" => Some(Self::PlayList),
            "BANNER" => Some(Self::Banner),
            "HE_INLINE" => Some(Self::HeInline),
            "EXT_DATA_TYPE_CHARGING" => Some(Self::Charging),
            "QR_CODE" => Some(Self::QrCode),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FoldStyle {
    ///
    Unspecified = 0,
    ///
    CountDown = 1,
    ///
    OnlyButton = 2,
}
impl FoldStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FOLD_STYLE_UNSPECIFIED",
            Self::CountDown => "FOLD_STYLE_COUNT_DOWN",
            Self::OnlyButton => "FOLD_STYLE_ONLY_BUTTON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FOLD_STYLE_UNSPECIFIED" => Some(Self::Unspecified),
            "FOLD_STYLE_COUNT_DOWN" => Some(Self::CountDown),
            "FOLD_STYLE_ONLY_BUTTON" => Some(Self::OnlyButton),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FragmentPosition {
    ///
    Invalid = 0,
    ///
    Pre = 1,
    ///
    Middle = 2,
    ///
    Post = 3,
}
impl FragmentPosition {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "INVALID",
            Self::Pre => "PRE",
            Self::Middle => "MIDDLE",
            Self::Post => "POST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INVALID" => Some(Self::Invalid),
            "PRE" => Some(Self::Pre),
            "MIDDLE" => Some(Self::Middle),
            "POST" => Some(Self::Post),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FragmentType {
    ///
    Unknown = 0,
    ///
    AdFragment = 1,
    ///
    OgvFragment = 2,
    ///
    PugvFragment = 3,
}
impl FragmentType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "UNKNOWN",
            Self::AdFragment => "AD_FRAGMENT",
            Self::OgvFragment => "OGV_FRAGMENT",
            Self::PugvFragment => "PUGV_FRAGMENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN" => Some(Self::Unknown),
            "AD_FRAGMENT" => Some(Self::AdFragment),
            "OGV_FRAGMENT" => Some(Self::OgvFragment),
            "PUGV_FRAGMENT" => Some(Self::PugvFragment),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GroupStyle {
    ///
    Default = 0,
    ///
    Horizon = 1,
}
impl GroupStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "GROUP_STYLE_DEFAULT",
            Self::Horizon => "GROUP_STYLE_HORIZON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GROUP_STYLE_DEFAULT" => Some(Self::Default),
            "GROUP_STYLE_HORIZON" => Some(Self::Horizon),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GuideStyle {
    ///
    StyleUnknown = 0,
    ///
    HorizontalImage = 1,
    ///
    VerticalText = 2,
    ///
    SimpleText = 3,
    ///
    ChargingText = 4,
    ///
    UniversalIntercept = 5,
    ///
    MsgAttachQrCode = 6,
}
impl GuideStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::StyleUnknown => "STYLE_UNKNOWN",
            Self::HorizontalImage => "HORIZONTAL_IMAGE",
            Self::VerticalText => "VERTICAL_TEXT",
            Self::SimpleText => "SIMPLE_TEXT",
            Self::ChargingText => "CHARGING_TEXT",
            Self::UniversalIntercept => "UNIVERSAL_INTERCEPT",
            Self::MsgAttachQrCode => "MSG_ATTACH_QR_CODE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STYLE_UNKNOWN" => Some(Self::StyleUnknown),
            "HORIZONTAL_IMAGE" => Some(Self::HorizontalImage),
            "VERTICAL_TEXT" => Some(Self::VerticalText),
            "SIMPLE_TEXT" => Some(Self::SimpleText),
            "CHARGING_TEXT" => Some(Self::ChargingText),
            "UNIVERSAL_INTERCEPT" => Some(Self::UniversalIntercept),
            "MSG_ATTACH_QR_CODE" => Some(Self::MsgAttachQrCode),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LimitActionType {
    ///
    LatUnknown = 0,
    ///
    ShowLimitDialog = 1,
    ///
    SkipCurrentEp = 2,
}
impl LimitActionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::LatUnknown => "LAT_UNKNOWN",
            Self::ShowLimitDialog => "SHOW_LIMIT_DIALOG",
            Self::SkipCurrentEp => "SKIP_CURRENT_EP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LAT_UNKNOWN" => Some(Self::LatUnknown),
            "SHOW_LIMIT_DIALOG" => Some(Self::ShowLimitDialog),
            "SKIP_CURRENT_EP" => Some(Self::SkipCurrentEp),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlayCtrl {
    ///
    Default = 0,
    ///
    Simple = 1,
}
impl PlayCtrl {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "PLAY_CTRL_DEFAULT",
            Self::Simple => "PLAY_CTRL_SIMPLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PLAY_CTRL_DEFAULT" => Some(Self::Default),
            "PLAY_CTRL_SIMPLE" => Some(Self::Simple),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlayErr {
    ///
    NoErr = 0,
    ///
    WithMultiDeviceLoginErr = 1,
}
impl PlayErr {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoErr => "NoErr",
            Self::WithMultiDeviceLoginErr => "WithMultiDeviceLoginErr",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NoErr" => Some(Self::NoErr),
            "WithMultiDeviceLoginErr" => Some(Self::WithMultiDeviceLoginErr),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PromptBarStyle {
    ///
    Unknown = 0,
    ///
    Text = 1,
    ///
    CuringBenefits = 2,
    ///
    CardOpeningGift = 3,
    ///
    Countdown = 4,
}
impl PromptBarStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "PROMPT_BAR_STYLE_UNKNOWN",
            Self::Text => "TEXT",
            Self::CuringBenefits => "CURING_BENEFITS",
            Self::CardOpeningGift => "CARD_OPENING_GIFT",
            Self::Countdown => "COUNTDOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROMPT_BAR_STYLE_UNKNOWN" => Some(Self::Unknown),
            "TEXT" => Some(Self::Text),
            "CURING_BENEFITS" => Some(Self::CuringBenefits),
            "CARD_OPENING_GIFT" => Some(Self::CardOpeningGift),
            "COUNTDOWN" => Some(Self::Countdown),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PromptBarType {
    ///
    Unknown = 0,
    ///
    OpenPromptBar = 1,
    ///
    TryPromptBar = 2,
}
impl PromptBarType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "PROMPT_BAR_TYPE_UNKNOWN",
            Self::OpenPromptBar => "OPEN_PROMPT_BAR",
            Self::TryPromptBar => "TRY_PROMPT_BAR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROMPT_BAR_TYPE_UNKNOWN" => Some(Self::Unknown),
            "OPEN_PROMPT_BAR" => Some(Self::OpenPromptBar),
            "TRY_PROMPT_BAR" => Some(Self::TryPromptBar),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QnPolicy {
    ///
    Default = 0,
    ///
    AutoQnEnable = 1,
}
impl QnPolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "QN_POLICY_DEFAULT",
            Self::AutoQnEnable => "QN_POLICY_AUTO_QN_ENABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QN_POLICY_DEFAULT" => Some(Self::Default),
            "QN_POLICY_AUTO_QN_ENABLE" => Some(Self::AutoQnEnable),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SettingItemStyle {
    ///
    SettingStyleNone = 0,
    ///
    SettingStyleSwitch = 1,
    ///
    SettingStyleMore = 2,
    ///
    SettingStyleSelect = 3,
    ///
    SettingStyleVertical = 4,
}
impl SettingItemStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SettingStyleNone => "SETTING_STYLE_NONE",
            Self::SettingStyleSwitch => "SETTING_STYLE_SWITCH",
            Self::SettingStyleMore => "SETTING_STYLE_MORE",
            Self::SettingStyleSelect => "SETTING_STYLE_SELECT",
            Self::SettingStyleVertical => "SETTING_STYLE_VERTICAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SETTING_STYLE_NONE" => Some(Self::SettingStyleNone),
            "SETTING_STYLE_SWITCH" => Some(Self::SettingStyleSwitch),
            "SETTING_STYLE_MORE" => Some(Self::SettingStyleMore),
            "SETTING_STYLE_SELECT" => Some(Self::SettingStyleSelect),
            "SETTING_STYLE_VERTICAL" => Some(Self::SettingStyleVertical),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SettingItemType {
    ///
    SettingNone = 0,
    ///
    SettingPlaybackRate = 1,
    ///
    SettingWatchLater = 2,
    ///
    SettingDowNlOad = 3,
    ///
    SettingSmallWindow = 4,
    ///
    SettingFreyaenter = 5,
    ///
    SettingPlaybackMode = 6,
    ///
    SettingLoopPlayback = 7,
    ///
    SettingTimingSwitch = 8,
    ///
    SettingBackgroundPlay = 9,
    ///
    SettingSubtitle = 10,
    ///
    SettingSubtitleExchange = 11,
    ///
    SettingFlipConf = 12,
    ///
    SettingMorePlay = 13,
    ///
    SettingShake = 14,
    ///
    SettingSkipOped = 15,
    ///
    SettingNote = 16,
    ///
    SettingReport = 17,
    ///
    SettingFeedback = 18,
    ///
    SettingFreeGift = 19,
    ///
    SettingDub = 20,
    ///
    SettingListen = 21,
    ///
    SettingProject = 22,
    ///
    SettingPicSize = 23,
    ///
    SettingPanorama = 24,
    ///
    SettingVisionAssist = 25,
    ///
    SettingEdit = 26,
    ///
    SettingDislike = 27,
    ///
    SettingBihuo = 28,
    ///
    SettingGesture = 29,
    ///
    SettingDm = 30,
    ///
    SettingDefinition = 31,
    ///
    SettingSuggest = 32,
    ///
    SettingAutomaticScroll = 33,
    ///
    SettingBacktracking = 34,
    ///
    SettingAiAudio = 35,
    ///
    SettingAiAudioExchange = 36,
}
impl SettingItemType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SettingNone => "SETTING_NONE",
            Self::SettingPlaybackRate => "SETTING_PLAYBACK_RATE",
            Self::SettingWatchLater => "SETTING_WATCH_LATER",
            Self::SettingDowNlOad => "SETTING_DOWNlOAD",
            Self::SettingSmallWindow => "SETTING_SMALL_WINDOW",
            Self::SettingFreyaenter => "SETTING_FREYAENTER",
            Self::SettingPlaybackMode => "SETTING_PLAYBACK_MODE",
            Self::SettingLoopPlayback => "SETTING_LOOP_PLAYBACK",
            Self::SettingTimingSwitch => "SETTING_TIMING_SWITCH",
            Self::SettingBackgroundPlay => "SETTING_BACKGROUND_PLAY",
            Self::SettingSubtitle => "SETTING_SUBTITLE",
            Self::SettingSubtitleExchange => "SETTING_SUBTITLE_EXCHANGE",
            Self::SettingFlipConf => "SETTING_FLIP_CONF",
            Self::SettingMorePlay => "SETTING_MORE_PLAY",
            Self::SettingShake => "SETTING_SHAKE",
            Self::SettingSkipOped => "SETTING_SKIP_OPED",
            Self::SettingNote => "SETTING_NOTE",
            Self::SettingReport => "SETTING_REPORT",
            Self::SettingFeedback => "SETTING_FEEDBACK",
            Self::SettingFreeGift => "SETTING_FREE_GIFT",
            Self::SettingDub => "SETTING_DUB",
            Self::SettingListen => "SETTING_LISTEN",
            Self::SettingProject => "SETTING_PROJECT",
            Self::SettingPicSize => "SETTING_PIC_SIZE",
            Self::SettingPanorama => "SETTING_PANORAMA",
            Self::SettingVisionAssist => "SETTING_VISION_ASSIST",
            Self::SettingEdit => "SETTING_EDIT",
            Self::SettingDislike => "SETTING_DISLIKE",
            Self::SettingBihuo => "SETTING_BIHUO",
            Self::SettingGesture => "SETTING_GESTURE",
            Self::SettingDm => "SETTING_DM",
            Self::SettingDefinition => "SETTING_DEFINITION",
            Self::SettingSuggest => "SETTING_SUGGEST",
            Self::SettingAutomaticScroll => "SETTING_AUTOMATIC_SCROLL",
            Self::SettingBacktracking => "SETTING_BACKTRACKING",
            Self::SettingAiAudio => "SETTING_AI_AUDIO",
            Self::SettingAiAudioExchange => "SETTING_AI_AUDIO_EXCHANGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SETTING_NONE" => Some(Self::SettingNone),
            "SETTING_PLAYBACK_RATE" => Some(Self::SettingPlaybackRate),
            "SETTING_WATCH_LATER" => Some(Self::SettingWatchLater),
            "SETTING_DOWNlOAD" => Some(Self::SettingDowNlOad),
            "SETTING_SMALL_WINDOW" => Some(Self::SettingSmallWindow),
            "SETTING_FREYAENTER" => Some(Self::SettingFreyaenter),
            "SETTING_PLAYBACK_MODE" => Some(Self::SettingPlaybackMode),
            "SETTING_LOOP_PLAYBACK" => Some(Self::SettingLoopPlayback),
            "SETTING_TIMING_SWITCH" => Some(Self::SettingTimingSwitch),
            "SETTING_BACKGROUND_PLAY" => Some(Self::SettingBackgroundPlay),
            "SETTING_SUBTITLE" => Some(Self::SettingSubtitle),
            "SETTING_SUBTITLE_EXCHANGE" => Some(Self::SettingSubtitleExchange),
            "SETTING_FLIP_CONF" => Some(Self::SettingFlipConf),
            "SETTING_MORE_PLAY" => Some(Self::SettingMorePlay),
            "SETTING_SHAKE" => Some(Self::SettingShake),
            "SETTING_SKIP_OPED" => Some(Self::SettingSkipOped),
            "SETTING_NOTE" => Some(Self::SettingNote),
            "SETTING_REPORT" => Some(Self::SettingReport),
            "SETTING_FEEDBACK" => Some(Self::SettingFeedback),
            "SETTING_FREE_GIFT" => Some(Self::SettingFreeGift),
            "SETTING_DUB" => Some(Self::SettingDub),
            "SETTING_LISTEN" => Some(Self::SettingListen),
            "SETTING_PROJECT" => Some(Self::SettingProject),
            "SETTING_PIC_SIZE" => Some(Self::SettingPicSize),
            "SETTING_PANORAMA" => Some(Self::SettingPanorama),
            "SETTING_VISION_ASSIST" => Some(Self::SettingVisionAssist),
            "SETTING_EDIT" => Some(Self::SettingEdit),
            "SETTING_DISLIKE" => Some(Self::SettingDislike),
            "SETTING_BIHUO" => Some(Self::SettingBihuo),
            "SETTING_GESTURE" => Some(Self::SettingGesture),
            "SETTING_DM" => Some(Self::SettingDm),
            "SETTING_DEFINITION" => Some(Self::SettingDefinition),
            "SETTING_SUGGEST" => Some(Self::SettingSuggest),
            "SETTING_AUTOMATIC_SCROLL" => Some(Self::SettingAutomaticScroll),
            "SETTING_BACKTRACKING" => Some(Self::SettingBacktracking),
            "SETTING_AI_AUDIO" => Some(Self::SettingAiAudio),
            "SETTING_AI_AUDIO_EXCHANGE" => Some(Self::SettingAiAudioExchange),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SettingJumpType {
    ///
    None = 0,
    ///
    OpenUrl = 1,
    ///
    HalfScreen = 2,
    ///
    OpenUrlByOuterBrowser = 3,
}
impl SettingJumpType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "SETTING_JUMP_TYPE_NONE",
            Self::OpenUrl => "SETTING_JUMP_TYPE_OPEN_URL",
            Self::HalfScreen => "SETTING_JUMP_TYPE_HALF_SCREEN",
            Self::OpenUrlByOuterBrowser => "SETTING_JUMP_TYPE_OPEN_URL_BY_OUTER_BROWSER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SETTING_JUMP_TYPE_NONE" => Some(Self::None),
            "SETTING_JUMP_TYPE_OPEN_URL" => Some(Self::OpenUrl),
            "SETTING_JUMP_TYPE_HALF_SCREEN" => Some(Self::HalfScreen),
            "SETTING_JUMP_TYPE_OPEN_URL_BY_OUTER_BROWSER" => {
                Some(Self::OpenUrlByOuterBrowser)
            }
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ShowStyleType {
    ///
    Unknown = 0,
    ///
    Ordinary = 1,
    ///
    Resident = 2,
}
impl ShowStyleType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "SHOW_STYLE_TYPE_UNKNOWN",
            Self::Ordinary => "SHOW_STYLE_TYPE_ORDINARY",
            Self::Resident => "SHOW_STYLE_TYPE_RESIDENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SHOW_STYLE_TYPE_UNKNOWN" => Some(Self::Unknown),
            "SHOW_STYLE_TYPE_ORDINARY" => Some(Self::Ordinary),
            "SHOW_STYLE_TYPE_RESIDENT" => Some(Self::Resident),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ToastType {
    ///
    Unknown = 0,
    ///
    VipContentRemind = 1,
    ///
    VipDefinitionRemind = 2,
    ///
    VipDefinitionGuide = 3,
    ///
    OgvVideoStartToast = 4,
    ///
    ChargingToast = 5,
    ///
    VipSkipFragmentToast = 6,
    ///
    VipAiFixDefinitionRemind = 7,
    ///
    NewUserDefinitionRemind = 8,
    ///
    VipRiskToast = 9,
}
impl ToastType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "TOAST_TYPE_UNKNOWN",
            Self::VipContentRemind => "VIP_CONTENT_REMIND",
            Self::VipDefinitionRemind => "VIP_DEFINITION_REMIND",
            Self::VipDefinitionGuide => "VIP_DEFINITION_GUIDE",
            Self::OgvVideoStartToast => "OGV_VIDEO_START_TOAST",
            Self::ChargingToast => "CHARGING_TOAST",
            Self::VipSkipFragmentToast => "VIP_SKIP_FRAGMENT_TOAST",
            Self::VipAiFixDefinitionRemind => "VIP_AI_FIX_DEFINITION_REMIND",
            Self::NewUserDefinitionRemind => "NEW_USER_DEFINITION_REMIND",
            Self::VipRiskToast => "VIP_RISK_TOAST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TOAST_TYPE_UNKNOWN" => Some(Self::Unknown),
            "VIP_CONTENT_REMIND" => Some(Self::VipContentRemind),
            "VIP_DEFINITION_REMIND" => Some(Self::VipDefinitionRemind),
            "VIP_DEFINITION_GUIDE" => Some(Self::VipDefinitionGuide),
            "OGV_VIDEO_START_TOAST" => Some(Self::OgvVideoStartToast),
            "CHARGING_TOAST" => Some(Self::ChargingToast),
            "VIP_SKIP_FRAGMENT_TOAST" => Some(Self::VipSkipFragmentToast),
            "VIP_AI_FIX_DEFINITION_REMIND" => Some(Self::VipAiFixDefinitionRemind),
            "NEW_USER_DEFINITION_REMIND" => Some(Self::NewUserDefinitionRemind),
            "VIP_RISK_TOAST" => Some(Self::VipRiskToast),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UnsupportScene {
    ///
    UnknownScene = 0,
    ///
    Premiere = 1,
}
impl UnsupportScene {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownScene => "UNKNOWN_SCENE",
            Self::Premiere => "PREMIERE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_SCENE" => Some(Self::UnknownScene),
            "PREMIERE" => Some(Self::Premiere),
            _ => None,
        }
    }
}
