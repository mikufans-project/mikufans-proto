// This file is @generated by prost-build.
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InteractLayoutData {
    ///
    #[prost(int32, tag = "1")]
    pub width: i32,
    ///
    #[prost(int32, tag = "2")]
    pub height: i32,
    ///
    #[prost(message, optional, tag = "3")]
    pub default_cell: ::core::option::Option<LayoutCell>,
    ///
    #[prost(message, repeated, tag = "4")]
    pub cells: ::prost::alloc::vec::Vec<LayoutCell>,
    ///
    #[prost(message, optional, tag = "5")]
    pub rtc_resolution: ::core::option::Option<RtcResolution>,
    ///
    #[prost(int32, tag = "6")]
    pub best_area_show_pos: i32,
    ///
    #[prost(message, optional, tag = "7")]
    pub rtc_resolution_simulcast: ::core::option::Option<RtcResolution>,
}
impl ::prost::Name for InteractLayoutData {
    const NAME: &'static str = "InteractLayoutData";
    const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.live.universal_interact.InteractLayoutData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.live.universal_interact.InteractLayoutData".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InteractSceneConfiguration {
    ///
    #[prost(enumeration = "interact_scene_configuration::InteractMode", tag = "1")]
    pub interact_mode: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub interact_template: ::core::option::Option<
        interact_scene_configuration::InteractTemplate,
    >,
    ///
    #[prost(int64, tag = "3")]
    pub interact_max_users: i64,
}
/// Nested message and enum types in `InteractSceneConfiguration`.
pub mod interact_scene_configuration {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InteractTemplate {
        ///
        #[prost(string, tag = "1")]
        pub layout: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "2")]
        pub template_id: ::prost::alloc::string::String,
        ///
        #[prost(bool, tag = "3")]
        pub is_variable_layout: bool,
        ///
        #[prost(message, repeated, tag = "4")]
        pub layout_list: ::prost::alloc::vec::Vec<interact_template::Layout>,
        ///
        #[prost(bool, tag = "5")]
        pub show_interact_ui: bool,
        ///
        #[prost(string, tag = "6")]
        pub layout_id: ::prost::alloc::string::String,
        ///
        #[prost(message, optional, tag = "7")]
        pub layout_data: ::core::option::Option<super::InteractLayoutData>,
    }
    /// Nested message and enum types in `InteractTemplate`.
    pub mod interact_template {
        ///
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Layout {
            ///
            #[prost(string, tag = "1")]
            pub layout_id: ::prost::alloc::string::String,
            ///
            #[prost(string, tag = "2")]
            pub video_size: ::prost::alloc::string::String,
            ///
            #[prost(int64, tag = "3")]
            pub max_users: i64,
        }
        impl ::prost::Name for Layout {
            const NAME: &'static str = "Layout";
            const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
            fn full_name() -> ::prost::alloc::string::String {
                "bilibili.broadcast.live.universal_interact.InteractSceneConfiguration.InteractTemplate.Layout"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "/bilibili.broadcast.live.universal_interact.InteractSceneConfiguration.InteractTemplate.Layout"
                    .into()
            }
        }
    }
    impl ::prost::Name for InteractTemplate {
        const NAME: &'static str = "InteractTemplate";
        const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.broadcast.live.universal_interact.InteractSceneConfiguration.InteractTemplate"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.broadcast.live.universal_interact.InteractSceneConfiguration.InteractTemplate"
                .into()
        }
    }
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InteractMode {
        ///
        B2b = 0,
        ///
        B2c = 1,
    }
    impl InteractMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::B2b => "InteractModeB2B",
                Self::B2c => "InteractModeB2C",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "InteractModeB2B" => Some(Self::B2b),
                "InteractModeB2C" => Some(Self::B2c),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for InteractSceneConfiguration {
    const NAME: &'static str = "InteractSceneConfiguration";
    const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.live.universal_interact.InteractSceneConfiguration".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.live.universal_interact.InteractSceneConfiguration".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LayoutCell {
    ///
    #[prost(double, tag = "1")]
    pub x: f64,
    ///
    #[prost(double, tag = "2")]
    pub y: f64,
    ///
    #[prost(double, tag = "3")]
    pub width: f64,
    ///
    #[prost(double, tag = "4")]
    pub height: f64,
    ///
    #[prost(int32, tag = "5")]
    pub z_index: i32,
    ///
    #[prost(int64, tag = "6")]
    pub position: i64,
    ///
    #[prost(enumeration = "LayoutCellOpen", tag = "7")]
    pub default_open: i32,
    ///
    #[prost(int32, tag = "8")]
    pub mobile_font_size: i32,
    ///
    #[prost(int32, tag = "9")]
    pub mobile_avatar_size: i32,
    ///
    #[prost(int32, tag = "10")]
    pub pc_web_font_size: i32,
    ///
    #[prost(int32, tag = "11")]
    pub pc_web_avatar_size: i32,
    ///
    #[prost(int32, tag = "12")]
    pub can_zoom: i32,
    ///
    #[prost(int32, tag = "13")]
    pub video_index: i32,
    ///
    #[prost(string, tag = "14")]
    pub position_text: ::prost::alloc::string::String,
}
impl ::prost::Name for LayoutCell {
    const NAME: &'static str = "LayoutCell";
    const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.live.universal_interact.LayoutCell".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.live.universal_interact.LayoutCell".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PeerUserInfo {
    ///
    #[prost(string, tag = "1")]
    pub uname: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub fans_num: i64,
    ///
    #[prost(string, tag = "4")]
    pub area_name: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "Gender", tag = "5")]
    pub gender: i32,
}
impl ::prost::Name for PeerUserInfo {
    const NAME: &'static str = "PeerUserInfo";
    const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.live.universal_interact.PeerUserInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.live.universal_interact.PeerUserInfo".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RtcResolution {
    ///
    #[prost(int32, tag = "1")]
    pub vertical_width: i32,
    ///
    #[prost(int32, tag = "2")]
    pub vertical_height: i32,
    ///
    #[prost(int32, tag = "3")]
    pub horizontal_width: i32,
    ///
    #[prost(int32, tag = "4")]
    pub horizontal_height: i32,
    ///
    #[prost(int64, tag = "5")]
    pub code_rate_init: i64,
    ///
    #[prost(int64, tag = "6")]
    pub code_rate_min: i64,
    ///
    #[prost(int64, tag = "7")]
    pub code_rate_max: i64,
    ///
    #[prost(double, tag = "8")]
    pub scale_down_ratio: f64,
    ///
    #[prost(int64, tag = "9")]
    pub small_bitrate_weight: i64,
    ///
    #[prost(int64, tag = "10")]
    pub big_bitrate_weight: i64,
    ///
    #[prost(int64, tag = "11")]
    pub small_max_fps: i64,
    ///
    #[prost(int64, tag = "12")]
    pub big_max_fps: i64,
    ///
    #[prost(bool, tag = "13")]
    pub small_bitrate_active: bool,
}
impl ::prost::Name for RtcResolution {
    const NAME: &'static str = "RtcResolution";
    const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.live.universal_interact.RtcResolution".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.live.universal_interact.RtcResolution".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UniversalBizExtra {
    ///
    #[prost(enumeration = "InteractScene", tag = "1")]
    pub interact_scene: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub interact_scene_configuration: ::core::option::Option<InteractSceneConfiguration>,
    ///
    #[prost(string, tag = "3")]
    pub biz_extra_data: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub source: i64,
}
impl ::prost::Name for UniversalBizExtra {
    const NAME: &'static str = "UniversalBizExtra";
    const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.live.universal_interact.UniversalBizExtra".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.live.universal_interact.UniversalBizExtra".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UniversalInteractApplyEvent {
    ///
    #[prost(int64, tag = "1")]
    pub rtc_channel_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub uid: i64,
    ///
    #[prost(string, tag = "3")]
    pub biz_label: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub trace_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub biz_session_id: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "6")]
    pub apply_timeout: i64,
    ///
    #[prost(string, tag = "7")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "8")]
    pub user_info: ::core::option::Option<PeerUserInfo>,
    ///
    #[prost(int64, tag = "9")]
    pub peer_uid: i64,
}
impl ::prost::Name for UniversalInteractApplyEvent {
    const NAME: &'static str = "UniversalInteractApplyEvent";
    const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.live.universal_interact.UniversalInteractApplyEvent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.live.universal_interact.UniversalInteractApplyEvent".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UniversalInteractEventGift {
    ///
    #[prost(int64, tag = "1")]
    pub room_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub anchor_uid: i64,
    ///
    #[prost(message, optional, tag = "3")]
    pub info: ::core::option::Option<
        super::super::super::live::app::room::v1::UniversalInfoResp,
    >,
}
impl ::prost::Name for UniversalInteractEventGift {
    const NAME: &'static str = "UniversalInteractEventGift";
    const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.live.universal_interact.UniversalInteractEventGift".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.live.universal_interact.UniversalInteractEventGift".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UniversalInteractInvitationEvent {
    ///
    #[prost(int64, tag = "1")]
    pub rtc_channel_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub uid: i64,
    ///
    #[prost(string, tag = "3")]
    pub biz_label: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub trace_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub biz_session_id: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "6")]
    pub initiator: i64,
    ///
    #[prost(int64, tag = "7")]
    pub invitation_timeout: i64,
    ///
    #[prost(string, tag = "8")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "9")]
    pub user_info: ::core::option::Option<PeerUserInfo>,
    ///
    #[prost(int64, tag = "10")]
    pub peer_uid: i64,
    ///
    #[prost(int64, tag = "11")]
    pub source: i64,
    ///
    #[prost(string, tag = "12")]
    pub toast_rich: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "13")]
    pub custom_content: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "14")]
    pub custom_content_rich: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "15")]
    pub target_room_id: i64,
    ///
    #[prost(int64, tag = "16")]
    pub want_position: i64,
}
impl ::prost::Name for UniversalInteractInvitationEvent {
    const NAME: &'static str = "UniversalInteractInvitationEvent";
    const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.live.universal_interact.UniversalInteractInvitationEvent"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.live.universal_interact.UniversalInteractInvitationEvent"
            .into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UniversalInteractJoinEvent {
    ///
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<universal_interact_join_event::Config>,
    ///
    #[prost(message, optional, tag = "2")]
    pub biz_extra: ::core::option::Option<UniversalBizExtra>,
    ///
    #[prost(string, tag = "3")]
    pub trace_id: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub stream_control: ::core::option::Option<UniversalInteractStreamControl>,
    ///
    #[prost(int64, repeated, tag = "5")]
    pub channel_users: ::prost::alloc::vec::Vec<i64>,
    ///
    #[prost(bool, tag = "6")]
    pub reconnect: bool,
}
/// Nested message and enum types in `UniversalInteractJoinEvent`.
pub mod universal_interact_join_event {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Config {
        ///
        #[prost(int64, tag = "1")]
        pub rtc_channel_id: i64,
        ///
        #[prost(int64, tag = "2")]
        pub uid: i64,
        ///
        #[prost(string, tag = "3")]
        pub buvid: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "4")]
        pub link_id: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "5")]
        pub join_token: ::prost::alloc::string::String,
        ///
        #[prost(int64, tag = "6")]
        pub wait_remote_timeout: i64,
        ///
        #[prost(string, tag = "7")]
        pub biz_label: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "8")]
        pub biz_session_id: ::prost::alloc::string::String,
        ///
        #[prost(bool, tag = "9")]
        pub enable_audio: bool,
        ///
        #[prost(bool, tag = "10")]
        pub enable_video: bool,
        ///
        #[prost(bool, tag = "11")]
        pub enable_external_audio_capture: bool,
        ///
        #[prost(bool, tag = "12")]
        pub enable_external_video_capture: bool,
        ///
        #[prost(enumeration = "super::PlayMode", tag = "13")]
        pub audio_play_mode: i32,
        ///
        #[prost(enumeration = "super::PlayMode", tag = "14")]
        pub video_play_mode: i32,
        ///
        #[prost(enumeration = "super::SubMode", tag = "15")]
        pub default_sub_mode: i32,
    }
    impl ::prost::Name for Config {
        const NAME: &'static str = "Config";
        const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.broadcast.live.universal_interact.UniversalInteractJoinEvent.Config"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.broadcast.live.universal_interact.UniversalInteractJoinEvent.Config"
                .into()
        }
    }
}
impl ::prost::Name for UniversalInteractJoinEvent {
    const NAME: &'static str = "UniversalInteractJoinEvent";
    const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.live.universal_interact.UniversalInteractJoinEvent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.live.universal_interact.UniversalInteractJoinEvent".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UniversalInteractLeaveEvent {
    ///
    #[prost(int64, tag = "1")]
    pub rtc_channel_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub uid: i64,
    ///
    #[prost(string, tag = "3")]
    pub biz_label: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub trace_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub biz_session_id: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "CloseUserReason", tag = "6")]
    pub close_user_reason: i32,
    ///
    #[prost(string, tag = "7")]
    pub toast: ::prost::alloc::string::String,
}
impl ::prost::Name for UniversalInteractLeaveEvent {
    const NAME: &'static str = "UniversalInteractLeaveEvent";
    const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.live.universal_interact.UniversalInteractLeaveEvent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.live.universal_interact.UniversalInteractLeaveEvent".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UniversalInteractOperationEvent {
    ///
    #[prost(int64, tag = "1")]
    pub rtc_channel_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub operator_uid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub target_uid: i64,
    ///
    #[prost(string, tag = "4")]
    pub biz_label: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub trace_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub biz_session_id: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "UniversalInteractOperationType", tag = "7")]
    pub operation_type: i32,
    ///
    #[prost(string, tag = "8")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "UniversalInteractActionType", tag = "9")]
    pub action_type: i32,
    ///
    #[prost(string, tag = "10")]
    pub operation_uname: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "11")]
    pub peer_uid: i64,
    ///
    #[prost(enumeration = "UniversalItemStatus", tag = "12")]
    pub universal_item_status: i32,
    ///
    #[prost(int64, tag = "13")]
    pub source_uid: i64,
    ///
    #[prost(int64, tag = "14")]
    pub source: i64,
    ///
    #[prost(int64, tag = "15")]
    pub target_room_id: i64,
    ///
    #[prost(bool, tag = "16")]
    pub own_side: bool,
}
impl ::prost::Name for UniversalInteractOperationEvent {
    const NAME: &'static str = "UniversalInteractOperationEvent";
    const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.live.universal_interact.UniversalInteractOperationEvent"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.live.universal_interact.UniversalInteractOperationEvent"
            .into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UniversalInteractStreamControl {
    ///
    #[prost(message, optional, tag = "1")]
    pub audio_control: ::core::option::Option<
        universal_interact_stream_control::UserStreamControlItem,
    >,
    ///
    #[prost(message, optional, tag = "2")]
    pub video_control: ::core::option::Option<
        universal_interact_stream_control::UserStreamControlItem,
    >,
    ///
    #[prost(message, optional, tag = "3")]
    pub pub_sub_control: ::core::option::Option<
        universal_interact_stream_control::PubSubControl,
    >,
}
/// Nested message and enum types in `UniversalInteractStreamControl`.
pub mod universal_interact_stream_control {
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ExplicitSubMode {
        ///
        #[prost(int64, tag = "1")]
        pub uid: i64,
        ///
        #[prost(enumeration = "super::SubMode", tag = "2")]
        pub sub_mode: i32,
    }
    impl ::prost::Name for ExplicitSubMode {
        const NAME: &'static str = "ExplicitSubMode";
        const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.broadcast.live.universal_interact.UniversalInteractStreamControl.ExplicitSubMode"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.broadcast.live.universal_interact.UniversalInteractStreamControl.ExplicitSubMode"
                .into()
        }
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PubSubControl {
        ///
        #[prost(enumeration = "PubStatus", tag = "1")]
        pub pub_status: i32,
        ///
        #[prost(message, repeated, tag = "2")]
        pub explicit_sub_users: ::prost::alloc::vec::Vec<ExplicitSubMode>,
        ///
        #[prost(int64, tag = "3")]
        pub version: i64,
        ///
        #[prost(message, optional, tag = "4")]
        pub rtc_resolution: ::core::option::Option<super::RtcResolution>,
        ///
        #[prost(map = "int64, int32", tag = "5")]
        pub sub_video_index: ::std::collections::HashMap<i64, i32>,
        ///
        #[prost(message, optional, tag = "6")]
        pub rtc_resolution_simulcast: ::core::option::Option<super::RtcResolution>,
    }
    impl ::prost::Name for PubSubControl {
        const NAME: &'static str = "PubSubControl";
        const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.broadcast.live.universal_interact.UniversalInteractStreamControl.PubSubControl"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.broadcast.live.universal_interact.UniversalInteractStreamControl.PubSubControl"
                .into()
        }
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UserStreamControlItem {
        ///
        #[prost(enumeration = "MuteLocalMode", tag = "1")]
        pub mute_local_mode: i32,
        ///
        #[prost(int64, repeated, tag = "2")]
        pub mute_remote_uids: ::prost::alloc::vec::Vec<i64>,
        ///
        #[prost(int64, repeated, tag = "3")]
        pub receive_uids: ::prost::alloc::vec::Vec<i64>,
        ///
        #[prost(int64, tag = "4")]
        pub version: i64,
        ///
        #[prost(int64, tag = "5")]
        pub operator_uid: i64,
    }
    impl ::prost::Name for UserStreamControlItem {
        const NAME: &'static str = "UserStreamControlItem";
        const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.broadcast.live.universal_interact.UniversalInteractStreamControl.UserStreamControlItem"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.broadcast.live.universal_interact.UniversalInteractStreamControl.UserStreamControlItem"
                .into()
        }
    }
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MuteLocalMode {
        ///
        MuteModeNone = 0,
        ///
        MuteModePacket = 1,
        ///
        MuteModeCapture = 2,
    }
    impl MuteLocalMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::MuteModeNone => "mute_mode_none",
                Self::MuteModePacket => "mute_mode_packet",
                Self::MuteModeCapture => "mute_mode_capture",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "mute_mode_none" => Some(Self::MuteModeNone),
                "mute_mode_packet" => Some(Self::MuteModePacket),
                "mute_mode_capture" => Some(Self::MuteModeCapture),
                _ => None,
            }
        }
    }
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PubStatus {
        ///
        None = 0,
        ///
        Audio = 1,
        ///
        Video = 2,
        ///
        All = 3,
    }
    impl PubStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "pub_status_none",
                Self::Audio => "pub_status_audio",
                Self::Video => "pub_status_video",
                Self::All => "pub_status_all",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "pub_status_none" => Some(Self::None),
                "pub_status_audio" => Some(Self::Audio),
                "pub_status_video" => Some(Self::Video),
                "pub_status_all" => Some(Self::All),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for UniversalInteractStreamControl {
    const NAME: &'static str = "UniversalInteractStreamControl";
    const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.live.universal_interact.UniversalInteractStreamControl"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.live.universal_interact.UniversalInteractStreamControl"
            .into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UniversalInteractStreamControlEvent {
    ///
    #[prost(int64, tag = "1")]
    pub rtc_channel_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub uid: i64,
    ///
    #[prost(string, tag = "3")]
    pub biz_session_id: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub stream_control: ::core::option::Option<UniversalInteractStreamControl>,
    ///
    #[prost(int64, tag = "5")]
    pub version: i64,
    ///
    #[prost(string, tag = "6")]
    pub trace_id: ::prost::alloc::string::String,
    ///
    #[prost(int64, repeated, tag = "7")]
    pub channel_users: ::prost::alloc::vec::Vec<i64>,
}
impl ::prost::Name for UniversalInteractStreamControlEvent {
    const NAME: &'static str = "UniversalInteractStreamControlEvent";
    const PACKAGE: &'static str = "bilibili.broadcast.live.universal_interact";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.live.universal_interact.UniversalInteractStreamControlEvent"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.live.universal_interact.UniversalInteractStreamControlEvent"
            .into()
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CloseUserReason {
    ///
    Invalid = 0,
    ///
    DissolveChannel = 1,
    ///
    Remove = 2,
    ///
    Banned = 3,
    ///
    Normal = 4,
    ///
    BySelf = 5,
    ///
    ByOther = 6,
}
impl CloseUserReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "CloseUserReason_Invalid",
            Self::DissolveChannel => "CloseUserReason_DissolveChannel",
            Self::Remove => "CloseUserReason_Remove",
            Self::Banned => "CloseUserReason_Banned",
            Self::Normal => "CloseUserReason_Normal",
            Self::BySelf => "CloseUserReason_BySelf",
            Self::ByOther => "CloseUserReason_ByOther",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CloseUserReason_Invalid" => Some(Self::Invalid),
            "CloseUserReason_DissolveChannel" => Some(Self::DissolveChannel),
            "CloseUserReason_Remove" => Some(Self::Remove),
            "CloseUserReason_Banned" => Some(Self::Banned),
            "CloseUserReason_Normal" => Some(Self::Normal),
            "CloseUserReason_BySelf" => Some(Self::BySelf),
            "CloseUserReason_ByOther" => Some(Self::ByOther),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Gender {
    ///
    Woman = 0,
    ///
    Man = 1,
}
impl Gender {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Woman => "Gender_Woman",
            Self::Man => "Gender_Man",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Gender_Woman" => Some(Self::Woman),
            "Gender_Man" => Some(Self::Man),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InteractScene {
    ///
    Voice1V1 = 0,
    ///
    VideoB2b = 1,
}
impl InteractScene {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Voice1V1 => "InteractSceneVoice1V1",
            Self::VideoB2b => "InteractSceneVideoB2B",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "InteractSceneVoice1V1" => Some(Self::Voice1V1),
            "InteractSceneVideoB2B" => Some(Self::VideoB2b),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LayoutCellOpen {
    ///
    Invalid = 0,
    ///
    Visible = 1,
    ///
    Invisible = 2,
}
impl LayoutCellOpen {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "LayoutCellOpenInvalid",
            Self::Visible => "LayoutCellOpenVisible",
            Self::Invisible => "LayoutCellOpenInvisible",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LayoutCellOpenInvalid" => Some(Self::Invalid),
            "LayoutCellOpenVisible" => Some(Self::Visible),
            "LayoutCellOpenInvisible" => Some(Self::Invisible),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlayMode {
    ///
    Default = 0,
    ///
    Explicit = 1,
}
impl PlayMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "play_mode_default",
            Self::Explicit => "play_mode_explicit",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "play_mode_default" => Some(Self::Default),
            "play_mode_explicit" => Some(Self::Explicit),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SubMode {
    ///
    None = 0,
    ///
    Audio = 1,
    ///
    Video = 2,
    ///
    All = 3,
}
impl SubMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "sub_mode_none",
            Self::Audio => "sub_mode_audio",
            Self::Video => "sub_mode_video",
            Self::All => "sub_mode_all",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "sub_mode_none" => Some(Self::None),
            "sub_mode_audio" => Some(Self::Audio),
            "sub_mode_video" => Some(Self::Video),
            "sub_mode_all" => Some(Self::All),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UniversalInteractActionType {
    ///
    Apply = 0,
    ///
    Invitation = 1,
}
impl UniversalInteractActionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Apply => "UniversalInteractActionTypeApply",
            Self::Invitation => "UniversalInteractActionTypeInvitation",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UniversalInteractActionTypeApply" => Some(Self::Apply),
            "UniversalInteractActionTypeInvitation" => Some(Self::Invitation),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UniversalInteractOperationType {
    ///
    UniversalInteractOperationInvalid = 0,
    ///
    UniversalInteractOperationAccept = 1,
    ///
    UniversalInteractOperationReject = 2,
    ///
    UniversalInteractOperationCancel = 3,
    ///
    UniversalInteractOperationTimeoutCancel = 4,
}
impl UniversalInteractOperationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UniversalInteractOperationInvalid => {
                "UniversalInteractOperationInvalid"
            }
            Self::UniversalInteractOperationAccept => "UniversalInteractOperationAccept",
            Self::UniversalInteractOperationReject => "UniversalInteractOperationReject",
            Self::UniversalInteractOperationCancel => "UniversalInteractOperationCancel",
            Self::UniversalInteractOperationTimeoutCancel => {
                "UniversalInteractOperationTimeoutCancel"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UniversalInteractOperationInvalid" => {
                Some(Self::UniversalInteractOperationInvalid)
            }
            "UniversalInteractOperationAccept" => {
                Some(Self::UniversalInteractOperationAccept)
            }
            "UniversalInteractOperationReject" => {
                Some(Self::UniversalInteractOperationReject)
            }
            "UniversalInteractOperationCancel" => {
                Some(Self::UniversalInteractOperationCancel)
            }
            "UniversalInteractOperationTimeoutCancel" => {
                Some(Self::UniversalInteractOperationTimeoutCancel)
            }
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UniversalItemStatus {
    ///
    Unknown = 0,
    ///
    NotLiving = 1,
    ///
    NotAllow = 2,
    ///
    Connected = 3,
    ///
    ConnectedNoPosition = 4,
    ///
    AllowInvitation = 5,
    ///
    Applying = 6,
    ///
    Inviting = 7,
    ///
    Connecting = 8,
}
impl UniversalItemStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "UniversalItemStatus_Unknown",
            Self::NotLiving => "UniversalItemStatus_NotLiving",
            Self::NotAllow => "UniversalItemStatus_NotAllow",
            Self::Connected => "UniversalItemStatus_Connected",
            Self::ConnectedNoPosition => "UniversalItemStatus_Connected_NoPosition",
            Self::AllowInvitation => "UniversalItemStatus_AllowInvitation",
            Self::Applying => "UniversalItemStatus_Applying",
            Self::Inviting => "UniversalItemStatus_Inviting",
            Self::Connecting => "UniversalItemStatus_Connecting",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UniversalItemStatus_Unknown" => Some(Self::Unknown),
            "UniversalItemStatus_NotLiving" => Some(Self::NotLiving),
            "UniversalItemStatus_NotAllow" => Some(Self::NotAllow),
            "UniversalItemStatus_Connected" => Some(Self::Connected),
            "UniversalItemStatus_Connected_NoPosition" => Some(Self::ConnectedNoPosition),
            "UniversalItemStatus_AllowInvitation" => Some(Self::AllowInvitation),
            "UniversalItemStatus_Applying" => Some(Self::Applying),
            "UniversalItemStatus_Inviting" => Some(Self::Inviting),
            "UniversalItemStatus_Connecting" => Some(Self::Connecting),
            _ => None,
        }
    }
}
