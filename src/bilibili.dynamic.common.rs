// This file is @generated by prost-build.
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Article {
    ///
    #[prost(int64, tag = "1")]
    pub category_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub list_id: i64,
    ///
    #[prost(int32, tag = "3")]
    pub originality: i32,
    ///
    #[prost(int32, tag = "4")]
    pub reproduced: i32,
    ///
    #[prost(message, repeated, tag = "5")]
    pub cover: ::prost::alloc::vec::Vec<Pic>,
    ///
    #[prost(string, repeated, tag = "6")]
    pub biz_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for Article {
    const NAME: &'static str = "Article";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.Article".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.Article".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AtGroup {
    ///
    #[prost(int32, tag = "1")]
    pub group_type: i32,
    ///
    #[prost(string, tag = "2")]
    pub group_name: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub items: ::prost::alloc::vec::Vec<AtItem>,
}
impl ::prost::Name for AtGroup {
    const NAME: &'static str = "AtGroup";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.AtGroup".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.AtGroup".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AtItem {
    ///
    #[prost(int64, tag = "1")]
    pub uid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "4")]
    pub fans: i32,
    ///
    #[prost(int32, tag = "5")]
    pub official_verify_type: i32,
}
impl ::prost::Name for AtItem {
    const NAME: &'static str = "AtItem";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.AtItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.AtItem".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AtListReq {
    ///
    #[prost(int64, tag = "1")]
    pub uid: i64,
}
impl ::prost::Name for AtListReq {
    const NAME: &'static str = "AtListReq";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.AtListReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.AtListReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AtListRsp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub groups: ::prost::alloc::vec::Vec<AtGroup>,
}
impl ::prost::Name for AtListRsp {
    const NAME: &'static str = "AtListRsp";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.AtListRsp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.AtListRsp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AtSearchReq {
    ///
    #[prost(int64, tag = "1")]
    pub uid: i64,
    ///
    #[prost(string, tag = "2")]
    pub keyword: ::prost::alloc::string::String,
}
impl ::prost::Name for AtSearchReq {
    const NAME: &'static str = "AtSearchReq";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.AtSearchReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.AtSearchReq".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BottomBusiness {
    ///
    #[prost(int64, tag = "1")]
    pub rid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub r#type: i64,
}
impl ::prost::Name for BottomBusiness {
    const NAME: &'static str = "BottomBusiness";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.BottomBusiness".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.BottomBusiness".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardParagraph {
    ///
    #[prost(message, optional, tag = "1")]
    pub card: ::core::option::Option<LinkNode>,
    ///
    #[prost(string, tag = "2")]
    pub default_text: ::prost::alloc::string::String,
}
impl ::prost::Name for CardParagraph {
    const NAME: &'static str = "CardParagraph";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CardParagraph".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CardParagraph".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CodeParagraph {
    ///
    #[prost(string, tag = "1")]
    pub lang: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
}
impl ::prost::Name for CodeParagraph {
    const NAME: &'static str = "CodeParagraph";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CodeParagraph".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CodeParagraph".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateActivity {
    ///
    #[prost(int64, tag = "1")]
    pub activity_id: i64,
    ///
    #[prost(int32, tag = "2")]
    pub activity_state: i32,
    ///
    #[prost(int32, tag = "3")]
    pub is_new_activity: i32,
    ///
    #[prost(int32, tag = "4")]
    pub action: i32,
}
impl ::prost::Name for CreateActivity {
    const NAME: &'static str = "CreateActivity";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CreateActivity".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CreateActivity".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAttachCard {
    ///
    #[prost(message, optional, tag = "1")]
    pub goods: ::core::option::Option<CreateGoodsCard>,
    ///
    #[prost(message, optional, tag = "2")]
    pub common_card: ::core::option::Option<CreateCommonAttachCard>,
    ///
    #[prost(message, optional, tag = "3")]
    pub commercial: ::core::option::Option<CreateCommercialCard>,
}
impl ::prost::Name for CreateAttachCard {
    const NAME: &'static str = "CreateAttachCard";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CreateAttachCard".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CreateAttachCard".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCheckResp {
    ///
    #[prost(message, optional, tag = "1")]
    pub setting: ::core::option::Option<PublishSetting>,
    ///
    #[prost(message, optional, tag = "2")]
    pub permission: ::core::option::Option<UpPermission>,
    ///
    #[prost(message, optional, tag = "3")]
    pub share_info: ::core::option::Option<ShareChannel>,
    ///
    #[prost(message, optional, tag = "4")]
    pub yellow_bar: ::core::option::Option<PublishYellowBar>,
    ///
    #[prost(message, optional, tag = "5")]
    pub plus_red_dot: ::core::option::Option<PlusRedDot>,
}
impl ::prost::Name for CreateCheckResp {
    const NAME: &'static str = "CreateCheckResp";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CreateCheckResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CreateCheckResp".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateCommercialCard {
    ///
    #[prost(int64, tag = "1")]
    pub commercial_entity_type: i64,
    ///
    #[prost(int64, tag = "2")]
    pub commercial_entity_id: i64,
}
impl ::prost::Name for CreateCommercialCard {
    const NAME: &'static str = "CreateCommercialCard";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CreateCommercialCard".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CreateCommercialCard".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateCommonAttachCard {
    ///
    #[prost(enumeration = "AttachCardType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(int64, tag = "2")]
    pub biz_id: i64,
    ///
    #[prost(enumeration = "ReserveSource", tag = "3")]
    pub reserve_source: i32,
    ///
    #[prost(int32, tag = "4")]
    pub reserve_lottery: i32,
}
impl ::prost::Name for CreateCommonAttachCard {
    const NAME: &'static str = "CreateCommonAttachCard";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CreateCommonAttachCard".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CreateCommonAttachCard".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateContent {
    ///
    #[prost(message, repeated, tag = "1")]
    pub contents: ::prost::alloc::vec::Vec<CreateContentItem>,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateContent {
    const NAME: &'static str = "CreateContent";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CreateContent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CreateContent".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateContentItem {
    ///
    #[prost(string, tag = "1")]
    pub raw_text: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "ContentType", tag = "2")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "3")]
    pub biz_id: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub goods: ::core::option::Option<GoodsContent>,
}
impl ::prost::Name for CreateContentItem {
    const NAME: &'static str = "CreateContentItem";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CreateContentItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CreateContentItem".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDynVideo {
    ///
    #[prost(string, tag = "1")]
    pub relation_from: ::prost::alloc::string::String,
    ///
    #[prost(int64, repeated, tag = "2")]
    pub follow_mids: ::prost::alloc::vec::Vec<i64>,
    ///
    #[prost(int32, tag = "3")]
    pub biz_from: i32,
    ///
    #[prost(int32, tag = "4")]
    pub copyright: i32,
    ///
    #[prost(int32, tag = "5")]
    pub no_public: i32,
    ///
    #[prost(int32, tag = "6")]
    pub no_reprint: i32,
    ///
    #[prost(string, tag = "7")]
    pub source: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "10")]
    pub tid: i64,
    ///
    #[prost(string, tag = "11")]
    pub tag: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "12")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "13")]
    pub desc_format_id: i64,
    ///
    #[prost(int32, tag = "14")]
    pub open_elec: i32,
    ///
    #[prost(int32, tag = "15")]
    pub dtime: i32,
    ///
    #[prost(message, repeated, tag = "16")]
    pub videos: ::prost::alloc::vec::Vec<DynVideoMultiP>,
    ///
    #[prost(message, optional, tag = "17")]
    pub watermark: ::core::option::Option<DynVideoWatermark>,
    ///
    #[prost(int64, tag = "18")]
    pub mission_id: i64,
    ///
    #[prost(string, tag = "19")]
    pub dynamic: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "20")]
    pub dynamic_extension: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "21")]
    pub dynamic_ctrl: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "22")]
    pub dynamic_from: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "23")]
    pub lottery_id: i64,
    ///
    #[prost(message, optional, tag = "24")]
    pub vote: ::core::option::Option<DynVideoVote>,
    ///
    #[prost(bool, tag = "25")]
    pub up_selection_reply: bool,
    ///
    #[prost(bool, tag = "26")]
    pub up_close_reply: bool,
    ///
    #[prost(bool, tag = "27")]
    pub up_close_danmu: bool,
    ///
    #[prost(int64, tag = "28")]
    pub up_from: i64,
    ///
    #[prost(int64, tag = "29")]
    pub duration: i64,
    ///
    #[prost(int64, tag = "30")]
    pub topic_id: i64,
    ///
    #[prost(string, tag = "31")]
    pub upload_id: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "32")]
    pub topic_detail: ::core::option::Option<DynVideoTopic>,
}
impl ::prost::Name for CreateDynVideo {
    const NAME: &'static str = "CreateDynVideo";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CreateDynVideo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CreateDynVideo".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDynVideoResult {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub submitact_banner: ::core::option::Option<DynVideoSubmitActBanner>,
    ///
    #[prost(message, optional, tag = "4")]
    pub push_intro: ::core::option::Option<DynVideoPushIntro>,
}
impl ::prost::Name for CreateDynVideoResult {
    const NAME: &'static str = "CreateDynVideoResult";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CreateDynVideoResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CreateDynVideoResult".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateExtraInfo {
    ///
    #[prost(string, tag = "1")]
    pub adcm_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateExtraInfo {
    const NAME: &'static str = "CreateExtraInfo";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CreateExtraInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CreateExtraInfo".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateGoodsCard {
    ///
    #[prost(string, repeated, tag = "1")]
    pub item_id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub goods_card_items: ::prost::alloc::vec::Vec<CreateGoodsCardItem>,
}
impl ::prost::Name for CreateGoodsCard {
    const NAME: &'static str = "CreateGoodsCard";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CreateGoodsCard".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CreateGoodsCard".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateGoodsCardItem {
    ///
    #[prost(string, tag = "1")]
    pub item_id: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub act_id: i64,
    ///
    #[prost(int64, tag = "3")]
    pub act_mid: i64,
}
impl ::prost::Name for CreateGoodsCardItem {
    const NAME: &'static str = "CreateGoodsCardItem";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CreateGoodsCardItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CreateGoodsCardItem".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateOption {
    ///
    #[prost(int32, tag = "1")]
    pub up_choose_comment: i32,
    ///
    #[prost(int32, tag = "2")]
    pub close_comment: i32,
    ///
    #[prost(int32, tag = "3")]
    pub fold_exclude: i32,
    ///
    #[prost(int32, tag = "4")]
    pub audit_level: i32,
    ///
    #[prost(int32, tag = "5")]
    pub sync_to_comment: i32,
    ///
    #[prost(message, optional, tag = "6")]
    pub video_share_info: ::core::option::Option<VideoShareInfo>,
    ///
    #[prost(message, optional, tag = "7")]
    pub activity: ::core::option::Option<CreateActivity>,
    ///
    #[prost(int32, tag = "10")]
    pub pic_mode: i32,
    ///
    #[prost(int64, tag = "11")]
    pub only_fans: i64,
    ///
    #[prost(int32, tag = "12")]
    pub limit_pegasus: i32,
    ///
    #[prost(int32, tag = "13")]
    pub limit_search: i32,
    ///
    #[prost(int64, tag = "14")]
    pub timer_pub_time: i64,
    ///
    #[prost(int64, tag = "15")]
    pub only_fans_dnd: i64,
    ///
    #[prost(int64, tag = "17")]
    pub only_fans_level: i64,
    ///
    #[prost(int32, tag = "19")]
    pub private_pub: i32,
    ///
    #[prost(message, optional, tag = "20")]
    pub live_water_mark: ::core::option::Option<LiveWaterMark>,
}
impl ::prost::Name for CreateOption {
    const NAME: &'static str = "CreateOption";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CreateOption".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CreateOption".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePic {
    ///
    #[prost(string, tag = "1")]
    pub img_src: ::prost::alloc::string::String,
    ///
    #[prost(double, tag = "2")]
    pub img_width: f64,
    ///
    #[prost(double, tag = "3")]
    pub img_height: f64,
    ///
    #[prost(double, tag = "4")]
    pub img_size: f64,
    ///
    #[prost(message, repeated, tag = "5")]
    pub img_tags: ::prost::alloc::vec::Vec<CreatePicTag>,
    ///
    #[prost(string, tag = "6")]
    pub live_video_src: ::prost::alloc::string::String,
    ///
    #[prost(double, tag = "7")]
    pub live_video_size: f64,
}
impl ::prost::Name for CreatePic {
    const NAME: &'static str = "CreatePic";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CreatePic".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CreatePic".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePicTag {
    ///
    #[prost(int64, tag = "1")]
    pub item_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub tid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub mid: i64,
    ///
    #[prost(string, tag = "4")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub text_string: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "6")]
    pub r#type: i64,
    ///
    #[prost(int64, tag = "7")]
    pub source_type: i64,
    ///
    #[prost(string, tag = "8")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub schema_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "11")]
    pub orientation: i64,
    ///
    #[prost(int64, tag = "12")]
    pub x: i64,
    ///
    #[prost(int64, tag = "13")]
    pub y: i64,
    ///
    #[prost(string, tag = "14")]
    pub poi: ::prost::alloc::string::String,
}
impl ::prost::Name for CreatePicTag {
    const NAME: &'static str = "CreatePicTag";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CreatePicTag".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CreatePicTag".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateResp {
    ///
    #[prost(int64, tag = "1")]
    pub dyn_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub dyn_id_str: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub dyn_type: i64,
    ///
    #[prost(int64, tag = "4")]
    pub dyn_rid: i64,
    ///
    #[prost(message, optional, tag = "5")]
    pub fake_card: ::core::option::Option<super::super::app::dynamic::v2::DynamicItem>,
    ///
    #[prost(message, optional, tag = "6")]
    pub video_result: ::core::option::Option<CreateDynVideoResult>,
    ///
    #[prost(message, optional, tag = "7")]
    pub share_window: ::core::option::Option<ShareDynWindow>,
}
impl ::prost::Name for CreateResp {
    const NAME: &'static str = "CreateResp";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CreateResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CreateResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTag {
    ///
    #[prost(message, optional, tag = "1")]
    pub lbs: ::core::option::Option<ExtLbs>,
    ///
    #[prost(message, optional, tag = "2")]
    pub sdk_game: ::core::option::Option<BottomBusiness>,
    ///
    #[prost(message, optional, tag = "3")]
    pub diversion: ::core::option::Option<BottomBusiness>,
}
impl ::prost::Name for CreateTag {
    const NAME: &'static str = "CreateTag";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CreateTag".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CreateTag".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTopic {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub from_source: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub from_topic_id: i64,
    ///
    #[prost(int64, tag = "5")]
    pub super_topic_id: i64,
}
impl ::prost::Name for CreateTopic {
    const NAME: &'static str = "CreateTopic";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.CreateTopic".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.CreateTopic".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DynIdentity {
    ///
    #[prost(int64, tag = "1")]
    pub dyn_id: i64,
    ///
    #[prost(message, optional, tag = "2")]
    pub revs_id: ::core::option::Option<DynRevsId>,
}
impl ::prost::Name for DynIdentity {
    const NAME: &'static str = "DynIdentity";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.DynIdentity".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.DynIdentity".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DynRevsId {
    ///
    #[prost(int64, tag = "1")]
    pub dyn_type: i64,
    ///
    #[prost(int64, tag = "2")]
    pub rid: i64,
}
impl ::prost::Name for DynRevsId {
    const NAME: &'static str = "DynRevsId";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.DynRevsId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.DynRevsId".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynVideoEditor {
    ///
    #[prost(int64, tag = "1")]
    pub cid: i64,
    ///
    #[prost(int32, tag = "2")]
    pub upfrom: i32,
    ///
    #[prost(string, tag = "3")]
    pub filters: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub fonts: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub subtitles: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub bgms: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub stickers: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub videoup_stickers: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub trans: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub makeups: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub surgerys: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "12")]
    pub videofxs: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "13")]
    pub themes: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "14")]
    pub cooperates: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "15")]
    pub rhythms: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "16")]
    pub effects: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "17")]
    pub backgrounds: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "18")]
    pub videos: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "19")]
    pub sounds: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "20")]
    pub flowers: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "21")]
    pub cover_templates: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "22")]
    pub tts: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "23")]
    pub openings: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "24")]
    pub record_text: bool,
    ///
    #[prost(string, tag = "25")]
    pub vupers: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "26")]
    pub features: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "27")]
    pub bcut_features: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "28")]
    pub audio_record: i32,
    ///
    #[prost(int32, tag = "29")]
    pub camera: i32,
    ///
    #[prost(int32, tag = "30")]
    pub speed: i32,
    ///
    #[prost(int32, tag = "31")]
    pub camera_rotate: i32,
    ///
    #[prost(int32, tag = "32")]
    pub screen_record: i32,
    ///
    #[prost(int32, tag = "33")]
    pub default_end: i32,
    ///
    #[prost(int32, tag = "34")]
    pub duration: i32,
    ///
    #[prost(int32, tag = "35")]
    pub pic_count: i32,
    ///
    #[prost(int32, tag = "36")]
    pub video_count: i32,
    ///
    #[prost(int32, tag = "37")]
    pub shot_duration: i32,
    ///
    #[prost(string, tag = "38")]
    pub shot_game: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "39")]
    pub highlight: bool,
    ///
    #[prost(int32, tag = "40")]
    pub highlight_cnt: i32,
    ///
    #[prost(int32, tag = "41")]
    pub pip_count: i32,
}
impl ::prost::Name for DynVideoEditor {
    const NAME: &'static str = "DynVideoEditor";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.DynVideoEditor".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.DynVideoEditor".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynVideoHotAct {
    ///
    #[prost(int64, tag = "1")]
    pub act_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub etime: i64,
    ///
    #[prost(int64, tag = "3")]
    pub id: i64,
    ///
    #[prost(string, tag = "4")]
    pub pic: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "5")]
    pub stime: i64,
    ///
    #[prost(string, tag = "6")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub link: ::prost::alloc::string::String,
}
impl ::prost::Name for DynVideoHotAct {
    const NAME: &'static str = "DynVideoHotAct";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.DynVideoHotAct".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.DynVideoHotAct".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynVideoMultiP {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub filename: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub cid: i64,
    ///
    #[prost(message, optional, tag = "4")]
    pub editor: ::core::option::Option<DynVideoEditor>,
}
impl ::prost::Name for DynVideoMultiP {
    const NAME: &'static str = "DynVideoMultiP";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.DynVideoMultiP".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.DynVideoMultiP".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynVideoPushIntro {
    ///
    #[prost(int32, tag = "1")]
    pub show: i32,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
impl ::prost::Name for DynVideoPushIntro {
    const NAME: &'static str = "DynVideoPushIntro";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.DynVideoPushIntro".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.DynVideoPushIntro".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynVideoSubmitActBanner {
    ///
    #[prost(string, tag = "1")]
    pub hotact_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub hotact_url: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub list: ::prost::alloc::vec::Vec<DynVideoHotAct>,
}
impl ::prost::Name for DynVideoSubmitActBanner {
    const NAME: &'static str = "DynVideoSubmitActBanner";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.DynVideoSubmitActBanner".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.DynVideoSubmitActBanner".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynVideoTopic {
    ///
    #[prost(string, tag = "1")]
    pub from_source: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub from_topic_id: i64,
}
impl ::prost::Name for DynVideoTopic {
    const NAME: &'static str = "DynVideoTopic";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.DynVideoTopic".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.DynVideoTopic".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynVideoVote {
    ///
    #[prost(int64, tag = "1")]
    pub vote_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub vote_title: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub top_for_reply: i32,
}
impl ::prost::Name for DynVideoVote {
    const NAME: &'static str = "DynVideoVote";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.DynVideoVote".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.DynVideoVote".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DynVideoWatermark {
    ///
    #[prost(int32, tag = "1")]
    pub state: i32,
    ///
    #[prost(int32, tag = "2")]
    pub r#type: i32,
    ///
    #[prost(int32, tag = "3")]
    pub position: i32,
}
impl ::prost::Name for DynVideoWatermark {
    const NAME: &'static str = "DynVideoWatermark";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.DynVideoWatermark".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.DynVideoWatermark".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmoteNode {
    ///
    #[prost(string, tag = "1")]
    pub raw_text: ::prost::alloc::string::String,
}
impl ::prost::Name for EmoteNode {
    const NAME: &'static str = "EmoteNode";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.EmoteNode".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.EmoteNode".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtLbs {
    ///
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub distance: i64,
    ///
    #[prost(int64, tag = "3")]
    pub r#type: i64,
    ///
    #[prost(string, tag = "4")]
    pub poi: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub location: ::core::option::Option<LbsLoc>,
    ///
    #[prost(string, tag = "6")]
    pub show_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub show_distance: ::prost::alloc::string::String,
}
impl ::prost::Name for ExtLbs {
    const NAME: &'static str = "ExtLbs";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.ExtLbs".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.ExtLbs".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FormulaNode {
    ///
    #[prost(string, tag = "1")]
    pub latex_content: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub pic: ::core::option::Option<Pic>,
}
impl ::prost::Name for FormulaNode {
    const NAME: &'static str = "FormulaNode";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.FormulaNode".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.FormulaNode".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUidByNameReq {
    ///
    #[prost(string, repeated, tag = "1")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for GetUidByNameReq {
    const NAME: &'static str = "GetUidByNameReq";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.GetUidByNameReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.GetUidByNameReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUidByNameRsp {
    ///
    #[prost(map = "string, int64", tag = "1")]
    pub uids: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
}
impl ::prost::Name for GetUidByNameRsp {
    const NAME: &'static str = "GetUidByNameRsp";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.GetUidByNameRsp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.GetUidByNameRsp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoodsContent {
    ///
    #[prost(int32, tag = "1")]
    pub source_type: i32,
    ///
    #[prost(int64, tag = "2")]
    pub item_id: i64,
    ///
    #[prost(int64, tag = "3")]
    pub shop_id: i64,
    ///
    #[prost(int64, tag = "4")]
    pub act_id: i64,
    ///
    #[prost(int64, tag = "5")]
    pub act_mid: i64,
    ///
    #[prost(string, tag = "6")]
    pub item_id_str: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "7")]
    pub sub_type: i64,
}
impl ::prost::Name for GoodsContent {
    const NAME: &'static str = "GoodsContent";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.GoodsContent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.GoodsContent".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LaunchedActivity {
    ///
    #[prost(string, tag = "1")]
    pub module_title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub activities: ::prost::alloc::vec::Vec<LaunchedActivityItem>,
    ///
    #[prost(message, optional, tag = "3")]
    pub show_more: ::core::option::Option<ShowMoreLaunchedActivity>,
}
impl ::prost::Name for LaunchedActivity {
    const NAME: &'static str = "LaunchedActivity";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.LaunchedActivity".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.LaunchedActivity".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LaunchedActivityItem {
    ///
    #[prost(int64, tag = "1")]
    pub activity_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub activity_name: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub activity_state: i32,
}
impl ::prost::Name for LaunchedActivityItem {
    const NAME: &'static str = "LaunchedActivityItem";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.LaunchedActivityItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.LaunchedActivityItem".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LbsLoc {
    ///
    #[prost(double, tag = "1")]
    pub lat: f64,
    ///
    #[prost(double, tag = "2")]
    pub lng: f64,
}
impl ::prost::Name for LbsLoc {
    const NAME: &'static str = "LbsLoc";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.LbsLoc".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.LbsLoc".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LineParagraph {
    ///
    #[prost(message, optional, tag = "1")]
    pub pic: ::core::option::Option<Pic>,
}
impl ::prost::Name for LineParagraph {
    const NAME: &'static str = "LineParagraph";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.LineParagraph".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.LineParagraph".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkNode {
    ///
    #[prost(string, tag = "1")]
    pub show_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub link: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub icon_suffix: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "OpusBizType", tag = "5")]
    pub link_type: i32,
    ///
    #[prost(string, tag = "6")]
    pub biz_id: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "7")]
    pub video_ts: ::core::option::Option<VideoTs>,
    ///
    #[prost(message, optional, tag = "8")]
    pub style: ::core::option::Option<link_node::LinkNodeStyle>,
    ///
    #[prost(message, repeated, tag = "9")]
    pub pics: ::prost::alloc::vec::Vec<Pic>,
}
/// Nested message and enum types in `LinkNode`.
pub mod link_node {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinkNodeStyle {
        ///
        #[prost(bool, tag = "1")]
        pub bold: bool,
        ///
        #[prost(bool, tag = "2")]
        pub italic: bool,
        ///
        #[prost(bool, tag = "3")]
        pub strikethrough: bool,
        ///
        #[prost(bool, tag = "4")]
        pub underline: bool,
        ///
        #[prost(double, tag = "5")]
        pub font_size: f64,
        ///
        #[prost(string, tag = "7")]
        pub font_level: ::prost::alloc::string::String,
    }
    impl ::prost::Name for LinkNodeStyle {
        const NAME: &'static str = "LinkNodeStyle";
        const PACKAGE: &'static str = "bilibili.dynamic.common";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.dynamic.common.LinkNode.LinkNodeStyle".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.dynamic.common.LinkNode.LinkNodeStyle".into()
        }
    }
}
impl ::prost::Name for LinkNode {
    const NAME: &'static str = "LinkNode";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.LinkNode".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.LinkNode".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiveWaterMark {
    ///
    #[prost(int64, tag = "1")]
    pub watermark: i64,
    ///
    #[prost(string, tag = "2")]
    pub wm_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub username: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub g: ::prost::alloc::string::String,
    ///
    #[prost(double, tag = "5")]
    pub wm_transparency: f64,
    ///
    #[prost(string, tag = "6")]
    pub biz: ::prost::alloc::string::String,
}
impl ::prost::Name for LiveWaterMark {
    const NAME: &'static str = "LiveWaterMark";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.LiveWaterMark".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.LiveWaterMark".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaDataCtrl {
    ///
    #[prost(string, tag = "1")]
    pub platform: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub build: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub mobi_app: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub buvid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub device: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub from_spmid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub from: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub trace_id: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "9")]
    pub teenager_mode: i32,
    ///
    #[prost(int32, tag = "10")]
    pub cold_start: i32,
    ///
    #[prost(string, tag = "11")]
    pub version: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "12")]
    pub network: i32,
    ///
    #[prost(string, tag = "13")]
    pub ip: ::prost::alloc::string::String,
}
impl ::prost::Name for MetaDataCtrl {
    const NAME: &'static str = "MetaDataCtrl";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.MetaDataCtrl".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.MetaDataCtrl".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnlyFansDndSetting {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub pop_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub pop_desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub pop_picture: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub pop_btn_text: ::prost::alloc::string::String,
}
impl ::prost::Name for OnlyFansDndSetting {
    const NAME: &'static str = "OnlyFansDndSetting";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.OnlyFansDndSetting".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.OnlyFansDndSetting".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnlyFansOption {
    ///
    #[prost(enumeration = "OnlyFansOptionType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(int32, tag = "2")]
    pub disabled: i32,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub subtitle: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub only_fans_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub desc_subtitle: ::prost::alloc::string::String,
}
impl ::prost::Name for OnlyFansOption {
    const NAME: &'static str = "OnlyFansOption";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.OnlyFansOption".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.OnlyFansOption".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnlyFansPermission {
    ///
    #[prost(int32, tag = "1")]
    pub permission: i32,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub subtitle: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub toast: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "6")]
    pub options: ::prost::alloc::vec::Vec<OnlyFansOption>,
    ///
    #[prost(message, optional, tag = "7")]
    pub dnd_setting: ::core::option::Option<OnlyFansDndSetting>,
}
impl ::prost::Name for OnlyFansPermission {
    const NAME: &'static str = "OnlyFansPermission";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.OnlyFansPermission".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.OnlyFansPermission".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Opus {
    ///
    #[prost(int64, tag = "1")]
    pub opus_id: i64,
    ///
    #[prost(enumeration = "OpusSource", tag = "2")]
    pub opus_source: i32,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub cover_avid: i64,
    ///
    #[prost(string, tag = "5")]
    pub h5_content: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub content: ::core::option::Option<OpusContent>,
    ///
    #[prost(message, repeated, tag = "7")]
    pub tags: ::prost::alloc::vec::Vec<OpusTag>,
    ///
    #[prost(message, optional, tag = "8")]
    pub pub_info: ::core::option::Option<PubInfo>,
    ///
    #[prost(message, optional, tag = "9")]
    pub article: ::core::option::Option<Article>,
    ///
    #[prost(message, optional, tag = "10")]
    pub version: ::core::option::Option<Version>,
    ///
    #[prost(int64, tag = "11")]
    pub music_id: i64,
}
impl ::prost::Name for Opus {
    const NAME: &'static str = "Opus";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.Opus".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.Opus".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpusContent {
    ///
    #[prost(message, repeated, tag = "1")]
    pub paragraphs: ::prost::alloc::vec::Vec<Paragraph>,
}
impl ::prost::Name for OpusContent {
    const NAME: &'static str = "OpusContent";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.OpusContent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.OpusContent".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpusSummary {
    ///
    #[prost(enumeration = "OpusSource", tag = "1")]
    pub opus_source: i32,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub cover: ::prost::alloc::vec::Vec<Pic>,
    ///
    #[prost(message, optional, tag = "4")]
    pub summary: ::core::option::Option<OpusContent>,
    ///
    #[prost(message, repeated, tag = "5")]
    pub tags: ::prost::alloc::vec::Vec<OpusTag>,
    ///
    #[prost(message, optional, tag = "6")]
    pub pub_info: ::core::option::Option<PubInfo>,
    ///
    #[prost(message, optional, tag = "7")]
    pub version: ::core::option::Option<Version>,
    ///
    #[prost(int64, tag = "8")]
    pub music_id: i64,
}
impl ::prost::Name for OpusSummary {
    const NAME: &'static str = "OpusSummary";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.OpusSummary".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.OpusSummary".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpusTag {
    ///
    #[prost(message, optional, tag = "1")]
    pub tag: ::core::option::Option<LinkNode>,
}
impl ::prost::Name for OpusTag {
    const NAME: &'static str = "OpusTag";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.OpusTag".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.OpusTag".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Paragraph {
    ///
    #[prost(enumeration = "paragraph::ParagraphType", tag = "1")]
    pub para_type: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub format: ::core::option::Option<paragraph::ParagraphFormat>,
    ///
    #[prost(message, optional, tag = "3")]
    pub text: ::core::option::Option<TextParagraph>,
    ///
    #[prost(message, optional, tag = "4")]
    pub pic: ::core::option::Option<PicParagraph>,
    ///
    #[prost(message, optional, tag = "5")]
    pub line: ::core::option::Option<LineParagraph>,
    ///
    #[prost(message, optional, tag = "6")]
    pub link_card: ::core::option::Option<CardParagraph>,
    ///
    #[prost(message, optional, tag = "7")]
    pub code: ::core::option::Option<CodeParagraph>,
}
/// Nested message and enum types in `Paragraph`.
pub mod paragraph {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListFormat {
        ///
        #[prost(int32, tag = "1")]
        pub level: i32,
        ///
        #[prost(int32, tag = "2")]
        pub order: i32,
        ///
        #[prost(string, tag = "3")]
        pub theme: ::prost::alloc::string::String,
    }
    impl ::prost::Name for ListFormat {
        const NAME: &'static str = "ListFormat";
        const PACKAGE: &'static str = "bilibili.dynamic.common";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.dynamic.common.Paragraph.ListFormat".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.dynamic.common.Paragraph.ListFormat".into()
        }
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ParagraphFormat {
        ///
        #[prost(enumeration = "ParagraphAlign", tag = "1")]
        pub align: i32,
        ///
        #[prost(message, optional, tag = "2")]
        pub list_format: ::core::option::Option<ListFormat>,
    }
    impl ::prost::Name for ParagraphFormat {
        const NAME: &'static str = "ParagraphFormat";
        const PACKAGE: &'static str = "bilibili.dynamic.common";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.dynamic.common.Paragraph.ParagraphFormat".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.dynamic.common.Paragraph.ParagraphFormat".into()
        }
    }
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ParagraphAlign {
        ///
        Left = 0,
        ///
        Middle = 1,
        ///
        Right = 2,
    }
    impl ParagraphAlign {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Left => "LEFT",
                Self::Middle => "MIDDLE",
                Self::Right => "RIGHT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LEFT" => Some(Self::Left),
                "MIDDLE" => Some(Self::Middle),
                "RIGHT" => Some(Self::Right),
                _ => None,
            }
        }
    }
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ParagraphType {
        ///
        DefaultParagraphType = 0,
        ///
        TextParagraphType = 1,
        ///
        Pictures = 2,
        ///
        Line = 3,
        ///
        Reference = 4,
        ///
        SortedList = 5,
        ///
        UnsortedList = 6,
        ///
        LinkCard = 7,
    }
    impl ParagraphType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::DefaultParagraphType => "DEFAULT_ParagraphType",
                Self::TextParagraphType => "TEXT_ParagraphType",
                Self::Pictures => "PICTURES",
                Self::Line => "LINE",
                Self::Reference => "REFERENCE",
                Self::SortedList => "SORTED_LIST",
                Self::UnsortedList => "UNSORTED_LIST",
                Self::LinkCard => "LINK_CARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEFAULT_ParagraphType" => Some(Self::DefaultParagraphType),
                "TEXT_ParagraphType" => Some(Self::TextParagraphType),
                "PICTURES" => Some(Self::Pictures),
                "LINE" => Some(Self::Line),
                "REFERENCE" => Some(Self::Reference),
                "SORTED_LIST" => Some(Self::SortedList),
                "UNSORTED_LIST" => Some(Self::UnsortedList),
                "LINK_CARD" => Some(Self::LinkCard),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Paragraph {
    const NAME: &'static str = "Paragraph";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.Paragraph".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.Paragraph".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PermissionWebItem {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "3")]
    pub allowable: bool,
    ///
    #[prost(string, repeated, tag = "4")]
    pub features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for PermissionWebItem {
    const NAME: &'static str = "PermissionWebItem";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.PermissionWebItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.PermissionWebItem".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PermissionsWeb {
    ///
    #[prost(message, optional, tag = "1")]
    pub lottery: ::core::option::Option<PermissionWebItem>,
    ///
    #[prost(message, optional, tag = "2")]
    pub archive: ::core::option::Option<PermissionWebItem>,
    ///
    #[prost(message, optional, tag = "3")]
    pub control_comment: ::core::option::Option<PermissionWebItem>,
    ///
    #[prost(message, optional, tag = "4")]
    pub choose_comment: ::core::option::Option<PermissionWebItem>,
    ///
    #[prost(message, optional, tag = "5")]
    pub video_reserve: ::core::option::Option<PermissionWebItem>,
    ///
    #[prost(message, optional, tag = "6")]
    pub live_reserve: ::core::option::Option<PermissionWebItem>,
    ///
    #[prost(message, optional, tag = "7")]
    pub popularize: ::core::option::Option<PermissionWebItem>,
    ///
    #[prost(message, optional, tag = "8")]
    pub link: ::core::option::Option<PermissionWebItem>,
    ///
    #[prost(message, optional, tag = "9")]
    pub only_fans: ::core::option::Option<OnlyFansPermission>,
    ///
    #[prost(message, optional, tag = "10")]
    pub commercial: ::core::option::Option<PermissionWebItem>,
    ///
    #[prost(message, optional, tag = "11")]
    pub upower: ::core::option::Option<PermissionWebItem>,
    ///
    #[prost(message, optional, tag = "12")]
    pub goods: ::core::option::Option<PermissionWebItem>,
}
impl ::prost::Name for PermissionsWeb {
    const NAME: &'static str = "PermissionsWeb";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.PermissionsWeb".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.PermissionsWeb".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pic {
    ///
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(double, tag = "2")]
    pub width: f64,
    ///
    #[prost(double, tag = "3")]
    pub height: f64,
    ///
    #[prost(double, tag = "4")]
    pub size: f64,
    ///
    #[prost(string, tag = "5")]
    pub comment: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "6")]
    pub is_live: bool,
    ///
    #[prost(double, tag = "7")]
    pub live_video_size: f64,
    ///
    #[prost(double, tag = "8")]
    pub origin_video_size: f64,
    ///
    #[prost(string, tag = "9")]
    pub origin_video_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub live_video_url: ::prost::alloc::string::String,
}
impl ::prost::Name for Pic {
    const NAME: &'static str = "Pic";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.Pic".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.Pic".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PicParagraph {
    ///
    #[prost(message, repeated, tag = "1")]
    pub pics: ::prost::alloc::vec::Vec<Pic>,
    ///
    #[prost(enumeration = "pic_paragraph::PicParagraphStyle", tag = "2")]
    pub style: i32,
}
/// Nested message and enum types in `PicParagraph`.
pub mod pic_paragraph {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PicParagraphStyle {
        ///
        DefaultPicParagraphStyle = 0,
        ///
        NineCell = 1,
        ///
        Scroll = 2,
    }
    impl PicParagraphStyle {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::DefaultPicParagraphStyle => "DEFAULT_PicParagraphStyle",
                Self::NineCell => "NINE_CELL",
                Self::Scroll => "SCROLL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEFAULT_PicParagraphStyle" => Some(Self::DefaultPicParagraphStyle),
                "NINE_CELL" => Some(Self::NineCell),
                "SCROLL" => Some(Self::Scroll),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for PicParagraph {
    const NAME: &'static str = "PicParagraph";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.PicParagraph".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.PicParagraph".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlusRedDot {
    ///
    #[prost(int64, tag = "1")]
    pub plus_has_red_dot: i64,
}
impl ::prost::Name for PlusRedDot {
    const NAME: &'static str = "PlusRedDot";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.PlusRedDot".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.PlusRedDot".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Program {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub target_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub program_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub jump_text: ::prost::alloc::string::String,
}
impl ::prost::Name for Program {
    const NAME: &'static str = "Program";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.Program".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.Program".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PubInfo {
    ///
    #[prost(int64, tag = "1")]
    pub uid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub pub_time: i64,
    ///
    #[prost(int64, tag = "3")]
    pub last_mtime: i64,
    ///
    #[prost(int64, tag = "4")]
    pub timer_pub_time: i64,
}
impl ::prost::Name for PubInfo {
    const NAME: &'static str = "PubInfo";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.PubInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.PubInfo".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PublishSetting {
    ///
    #[prost(int32, tag = "1")]
    pub min_words_to_article: i32,
    ///
    #[prost(int32, tag = "2")]
    pub max_words_to_article: i32,
    ///
    #[prost(int32, tag = "3")]
    pub upload_size: i32,
    ///
    #[prost(int32, tag = "4")]
    pub max_at_count: i32,
    ///
    #[prost(int32, tag = "5")]
    pub max_draft_count: i32,
    ///
    #[prost(int64, tag = "6")]
    pub title_max_len: i64,
}
impl ::prost::Name for PublishSetting {
    const NAME: &'static str = "PublishSetting";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.PublishSetting".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.PublishSetting".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PublishWebSettings {
    ///
    #[prost(int32, tag = "1")]
    pub max_upload_size: i32,
    ///
    #[prost(int32, tag = "2")]
    pub max_content_length: i32,
    ///
    #[prost(int32, tag = "3")]
    pub max_at_count: i32,
    ///
    #[prost(int32, tag = "4")]
    pub max_draft_count: i32,
    ///
    #[prost(int64, tag = "5")]
    pub max_pic_count_type: i64,
}
impl ::prost::Name for PublishWebSettings {
    const NAME: &'static str = "PublishWebSettings";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.PublishWebSettings".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.PublishWebSettings".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublishYellowBar {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
}
impl ::prost::Name for PublishYellowBar {
    const NAME: &'static str = "PublishYellowBar";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.PublishYellowBar".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.PublishYellowBar".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RepostInitCheck {
    ///
    #[prost(message, optional, tag = "1")]
    pub repost_src: ::core::option::Option<DynIdentity>,
    ///
    #[prost(string, tag = "2")]
    pub share_id: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub share_mode: i32,
}
impl ::prost::Name for RepostInitCheck {
    const NAME: &'static str = "RepostInitCheck";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.RepostInitCheck".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.RepostInitCheck".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareChannel {
    ///
    #[prost(string, tag = "1")]
    pub share_origin: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub oid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub sid: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "4")]
    pub share_channels: ::prost::alloc::vec::Vec<ShareChannelItem>,
}
impl ::prost::Name for ShareChannel {
    const NAME: &'static str = "ShareChannel";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.ShareChannel".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.ShareChannel".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareChannelItem {
    ///
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub picture: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub share_channel: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub reserve: ::core::option::Option<ShareReserve>,
}
impl ::prost::Name for ShareChannelItem {
    const NAME: &'static str = "ShareChannelItem";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.ShareChannelItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.ShareChannelItem".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareDynWindow {
    ///
    #[prost(string, tag = "1")]
    pub main_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub sub_title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub dyn_item: ::core::option::Option<super::super::app::dynamic::v2::DynamicItem>,
}
impl ::prost::Name for ShareDynWindow {
    const NAME: &'static str = "ShareDynWindow";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.ShareDynWindow".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.ShareDynWindow".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareReserve {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub qr_code_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub qr_code_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub qr_code_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "8")]
    pub poster: ::core::option::Option<ShareReservePoster>,
    ///
    #[prost(message, optional, tag = "9")]
    pub reserve_lottery: ::core::option::Option<ShareReserveLottery>,
    ///
    #[prost(string, tag = "10")]
    pub badge_text: ::prost::alloc::string::String,
}
impl ::prost::Name for ShareReserve {
    const NAME: &'static str = "ShareReserve";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.ShareReserve".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.ShareReserve".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareReserveLottery {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
impl ::prost::Name for ShareReserveLottery {
    const NAME: &'static str = "ShareReserveLottery";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.ShareReserveLottery".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.ShareReserveLottery".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareReservePoster {
    ///
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(double, tag = "2")]
    pub width: f64,
    ///
    #[prost(double, tag = "3")]
    pub height: f64,
}
impl ::prost::Name for ShareReservePoster {
    const NAME: &'static str = "ShareReservePoster";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.ShareReservePoster".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.ShareReservePoster".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareResult {
    ///
    #[prost(int64, tag = "1")]
    pub share_enable: i64,
    ///
    #[prost(string, tag = "2")]
    pub toast: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub forbid_sync_comment: i64,
}
impl ::prost::Name for ShareResult {
    const NAME: &'static str = "ShareResult";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.ShareResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.ShareResult".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowMoreLaunchedActivity {
    ///
    #[prost(string, tag = "1")]
    pub button_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub jump_url: ::prost::alloc::string::String,
}
impl ::prost::Name for ShowMoreLaunchedActivity {
    const NAME: &'static str = "ShowMoreLaunchedActivity";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.ShowMoreLaunchedActivity".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.ShowMoreLaunchedActivity".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Sketch {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub desc_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub biz_id: i64,
    ///
    #[prost(int64, tag = "5")]
    pub biz_type: i64,
    ///
    #[prost(string, tag = "6")]
    pub cover_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub target_url: ::prost::alloc::string::String,
}
impl ::prost::Name for Sketch {
    const NAME: &'static str = "Sketch";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.Sketch".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.Sketch".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextNode {
    ///
    #[prost(enumeration = "text_node::TextNodeType", tag = "1")]
    pub node_type: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub word: ::core::option::Option<WordNode>,
    ///
    #[prost(message, optional, tag = "3")]
    pub emote: ::core::option::Option<EmoteNode>,
    ///
    #[prost(message, optional, tag = "4")]
    pub link: ::core::option::Option<LinkNode>,
    ///
    #[prost(message, optional, tag = "5")]
    pub formula: ::core::option::Option<FormulaNode>,
}
/// Nested message and enum types in `TextNode`.
pub mod text_node {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TextNodeType {
        ///
        DefaultTextNodeType = 0,
        ///
        Words = 1,
        ///
        Emote = 2,
        ///
        AtTextNodeType = 3,
        ///
        BizLink = 4,
        ///
        Formula = 5,
    }
    impl TextNodeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::DefaultTextNodeType => "DEFAULT_TextNodeType",
                Self::Words => "WORDS",
                Self::Emote => "EMOTE",
                Self::AtTextNodeType => "AT_TextNodeType",
                Self::BizLink => "BIZ_LINK",
                Self::Formula => "FORMULA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEFAULT_TextNodeType" => Some(Self::DefaultTextNodeType),
                "WORDS" => Some(Self::Words),
                "EMOTE" => Some(Self::Emote),
                "AT_TextNodeType" => Some(Self::AtTextNodeType),
                "BIZ_LINK" => Some(Self::BizLink),
                "FORMULA" => Some(Self::Formula),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for TextNode {
    const NAME: &'static str = "TextNode";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.TextNode".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.TextNode".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextParagraph {
    ///
    #[prost(message, repeated, tag = "1")]
    pub nodes: ::prost::alloc::vec::Vec<TextNode>,
}
impl ::prost::Name for TextParagraph {
    const NAME: &'static str = "TextParagraph";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.TextParagraph".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.TextParagraph".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpPermission {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<UpPermissionItem>,
    ///
    #[prost(message, optional, tag = "2")]
    pub launched_activity: ::core::option::Option<LaunchedActivity>,
    ///
    #[prost(message, optional, tag = "3")]
    pub share_result: ::core::option::Option<ShareResult>,
    ///
    #[prost(message, optional, tag = "4")]
    pub only_fans_permission: ::core::option::Option<OnlyFansPermission>,
}
impl ::prost::Name for UpPermission {
    const NAME: &'static str = "UpPermission";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.UpPermission".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.UpPermission".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpPermissionItem {
    ///
    #[prost(enumeration = "UpPermissionType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(int32, tag = "2")]
    pub permission: i32,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub subtitle: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub toast: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "8")]
    pub has_red_dot: i64,
}
impl ::prost::Name for UpPermissionItem {
    const NAME: &'static str = "UpPermissionItem";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.UpPermissionItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.UpPermissionItem".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserCreateMeta {
    ///
    #[prost(message, optional, tag = "1")]
    pub app_meta: ::core::option::Option<MetaDataCtrl>,
    ///
    #[prost(message, optional, tag = "2")]
    pub loc: ::core::option::Option<LbsLoc>,
    ///
    #[prost(int32, tag = "3")]
    pub repost_mode: i32,
}
impl ::prost::Name for UserCreateMeta {
    const NAME: &'static str = "UserCreateMeta";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.UserCreateMeta".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.UserCreateMeta".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Version {
    ///
    #[prost(int64, tag = "1")]
    pub cvid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub version_id: i64,
}
impl ::prost::Name for Version {
    const NAME: &'static str = "Version";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.Version".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.Version".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VideoShareInfo {
    ///
    #[prost(int64, tag = "1")]
    pub cid: i64,
    ///
    #[prost(int32, tag = "2")]
    pub part: i32,
}
impl ::prost::Name for VideoShareInfo {
    const NAME: &'static str = "VideoShareInfo";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.VideoShareInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.VideoShareInfo".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoTs {
    ///
    #[prost(int64, tag = "1")]
    pub cid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub oid_type: i64,
    ///
    #[prost(int64, tag = "3")]
    pub status: i64,
    ///
    #[prost(int64, tag = "4")]
    pub index: i64,
    ///
    #[prost(int64, tag = "5")]
    pub seconds: i64,
    ///
    #[prost(int64, tag = "6")]
    pub cid_count: i64,
    ///
    #[prost(string, tag = "7")]
    pub key: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "9")]
    pub epid: i64,
    ///
    #[prost(string, tag = "10")]
    pub desc: ::prost::alloc::string::String,
}
impl ::prost::Name for VideoTs {
    const NAME: &'static str = "VideoTs";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.VideoTs".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.VideoTs".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WordNode {
    ///
    #[prost(string, tag = "1")]
    pub words: ::prost::alloc::string::String,
    ///
    #[prost(double, tag = "2")]
    pub font_size: f64,
    ///
    #[prost(string, tag = "3")]
    pub color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub dark_color: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub style: ::core::option::Option<word_node::WordNodeStyle>,
    ///
    #[prost(string, tag = "7")]
    pub font_level: ::prost::alloc::string::String,
}
/// Nested message and enum types in `WordNode`.
pub mod word_node {
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct WordNodeStyle {
        ///
        #[prost(bool, tag = "1")]
        pub bold: bool,
        ///
        #[prost(bool, tag = "2")]
        pub italic: bool,
        ///
        #[prost(bool, tag = "3")]
        pub strikethrough: bool,
        ///
        #[prost(bool, tag = "4")]
        pub underline: bool,
    }
    impl ::prost::Name for WordNodeStyle {
        const NAME: &'static str = "WordNodeStyle";
        const PACKAGE: &'static str = "bilibili.dynamic.common";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.dynamic.common.WordNode.WordNodeStyle".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.dynamic.common.WordNode.WordNodeStyle".into()
        }
    }
}
impl ::prost::Name for WordNode {
    const NAME: &'static str = "WordNode";
    const PACKAGE: &'static str = "bilibili.dynamic.common";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.dynamic.common.WordNode".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.dynamic.common.WordNode".into()
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AttachCardType {
    ///
    AttachCardNone = 0,
    ///
    AttachCardGoods = 1,
    ///
    AttachCardVote = 2,
    ///
    AttachCardUgc = 3,
    ///
    AttachCardActivity = 4,
    ///
    AttachCardOfficialActivity = 5,
    ///
    AttachCardTopic = 6,
    ///
    AttachCardOgv = 7,
    ///
    AttachCardAutoOgv = 8,
    ///
    AttachCardGame = 9,
    ///
    AttachCardManga = 10,
    ///
    AttachCardDecoration = 11,
    ///
    AttachCardMatch = 12,
    ///
    AttachCardPugv = 13,
    ///
    AttachCardReserve = 14,
    ///
    AttachCardUpTopic = 15,
    ///
    AttachCardUpActivity = 16,
    ///
    AttachCardUpMaoer = 17,
    ///
    AttachCardMemberGoods = 18,
    ///
    AttachCardManTianXing = 19,
    ///
    AttachCardLottery = 20,
}
impl AttachCardType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AttachCardNone => "ATTACH_CARD_NONE",
            Self::AttachCardGoods => "ATTACH_CARD_GOODS",
            Self::AttachCardVote => "ATTACH_CARD_VOTE",
            Self::AttachCardUgc => "ATTACH_CARD_UGC",
            Self::AttachCardActivity => "ATTACH_CARD_ACTIVITY",
            Self::AttachCardOfficialActivity => "ATTACH_CARD_OFFICIAL_ACTIVITY",
            Self::AttachCardTopic => "ATTACH_CARD_TOPIC",
            Self::AttachCardOgv => "ATTACH_CARD_OGV",
            Self::AttachCardAutoOgv => "ATTACH_CARD_AUTO_OGV",
            Self::AttachCardGame => "ATTACH_CARD_GAME",
            Self::AttachCardManga => "ATTACH_CARD_MANGA",
            Self::AttachCardDecoration => "ATTACH_CARD_DECORATION",
            Self::AttachCardMatch => "ATTACH_CARD_MATCH",
            Self::AttachCardPugv => "ATTACH_CARD_PUGV",
            Self::AttachCardReserve => "ATTACH_CARD_RESERVE",
            Self::AttachCardUpTopic => "ATTACH_CARD_UP_TOPIC",
            Self::AttachCardUpActivity => "ATTACH_CARD_UP_ACTIVITY",
            Self::AttachCardUpMaoer => "ATTACH_CARD_UP_MAOER",
            Self::AttachCardMemberGoods => "ATTACH_CARD_MEMBER_GOODS",
            Self::AttachCardManTianXing => "ATTACH_CARD_MAN_TIAN_XING",
            Self::AttachCardLottery => "ATTACH_CARD_LOTTERY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ATTACH_CARD_NONE" => Some(Self::AttachCardNone),
            "ATTACH_CARD_GOODS" => Some(Self::AttachCardGoods),
            "ATTACH_CARD_VOTE" => Some(Self::AttachCardVote),
            "ATTACH_CARD_UGC" => Some(Self::AttachCardUgc),
            "ATTACH_CARD_ACTIVITY" => Some(Self::AttachCardActivity),
            "ATTACH_CARD_OFFICIAL_ACTIVITY" => Some(Self::AttachCardOfficialActivity),
            "ATTACH_CARD_TOPIC" => Some(Self::AttachCardTopic),
            "ATTACH_CARD_OGV" => Some(Self::AttachCardOgv),
            "ATTACH_CARD_AUTO_OGV" => Some(Self::AttachCardAutoOgv),
            "ATTACH_CARD_GAME" => Some(Self::AttachCardGame),
            "ATTACH_CARD_MANGA" => Some(Self::AttachCardManga),
            "ATTACH_CARD_DECORATION" => Some(Self::AttachCardDecoration),
            "ATTACH_CARD_MATCH" => Some(Self::AttachCardMatch),
            "ATTACH_CARD_PUGV" => Some(Self::AttachCardPugv),
            "ATTACH_CARD_RESERVE" => Some(Self::AttachCardReserve),
            "ATTACH_CARD_UP_TOPIC" => Some(Self::AttachCardUpTopic),
            "ATTACH_CARD_UP_ACTIVITY" => Some(Self::AttachCardUpActivity),
            "ATTACH_CARD_UP_MAOER" => Some(Self::AttachCardUpMaoer),
            "ATTACH_CARD_MEMBER_GOODS" => Some(Self::AttachCardMemberGoods),
            "ATTACH_CARD_MAN_TIAN_XING" => Some(Self::AttachCardManTianXing),
            "ATTACH_CARD_LOTTERY" => Some(Self::AttachCardLottery),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ContentType {
    ///
    None = 0,
    ///
    Text = 1,
    ///
    At = 2,
    ///
    Lottery = 3,
    ///
    Vote = 4,
    /// @Deprecated
    Topic = 5,
    ///
    Goods = 6,
    /// @Deprecated
    Bv = 7,
    /// @Deprecated
    Av = 8,
    ///
    Emoji = 9,
    /// @Deprecated
    User = 10,
    /// @Deprecated
    Cv = 11,
    /// @Deprecated
    Vc = 12,
    /// @Deprecated
    Web = 13,
    /// @Deprecated
    Taobao = 14,
    /// @Deprecated
    Mail = 15,
    /// @Deprecated
    OgvSeason = 16,
    /// @Deprecated
    OgvEp = 17,
}
impl ContentType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "CONTENT_TYPE_NONE",
            Self::Text => "TEXT",
            Self::At => "AT",
            Self::Lottery => "LOTTERY",
            Self::Vote => "VOTE",
            Self::Topic => "TOPIC",
            Self::Goods => "GOODS",
            Self::Bv => "BV",
            Self::Av => "AV",
            Self::Emoji => "EMOJI",
            Self::User => "USER",
            Self::Cv => "CV",
            Self::Vc => "VC",
            Self::Web => "WEB",
            Self::Taobao => "TAOBAO",
            Self::Mail => "MAIL",
            Self::OgvSeason => "OGV_SEASON",
            Self::OgvEp => "OGV_EP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONTENT_TYPE_NONE" => Some(Self::None),
            "TEXT" => Some(Self::Text),
            "AT" => Some(Self::At),
            "LOTTERY" => Some(Self::Lottery),
            "VOTE" => Some(Self::Vote),
            "TOPIC" => Some(Self::Topic),
            "GOODS" => Some(Self::Goods),
            "BV" => Some(Self::Bv),
            "AV" => Some(Self::Av),
            "EMOJI" => Some(Self::Emoji),
            "USER" => Some(Self::User),
            "CV" => Some(Self::Cv),
            "VC" => Some(Self::Vc),
            "WEB" => Some(Self::Web),
            "TAOBAO" => Some(Self::Taobao),
            "MAIL" => Some(Self::Mail),
            "OGV_SEASON" => Some(Self::OgvSeason),
            "OGV_EP" => Some(Self::OgvEp),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CreateInitCheckScene {
    ///
    Invalid = 0,
    ///
    Normal = 1,
    ///
    Repost = 2,
    ///
    Share = 3,
    ///
    ReserveShare = 4,
    ///
    Article = 5,
}
impl CreateInitCheckScene {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "CREATE_INIT_CHECK_SCENE_INVALID",
            Self::Normal => "CREATE_INIT_CHECK_SCENE_NORMAL",
            Self::Repost => "CREATE_INIT_CHECK_SCENE_REPOST",
            Self::Share => "CREATE_INIT_CHECK_SCENE_SHARE",
            Self::ReserveShare => "CREATE_INIT_CHECK_SCENE_RESERVE_SHARE",
            Self::Article => "CREATE_INIT_CHECK_SCENE_ARTICLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CREATE_INIT_CHECK_SCENE_INVALID" => Some(Self::Invalid),
            "CREATE_INIT_CHECK_SCENE_NORMAL" => Some(Self::Normal),
            "CREATE_INIT_CHECK_SCENE_REPOST" => Some(Self::Repost),
            "CREATE_INIT_CHECK_SCENE_SHARE" => Some(Self::Share),
            "CREATE_INIT_CHECK_SCENE_RESERVE_SHARE" => Some(Self::ReserveShare),
            "CREATE_INIT_CHECK_SCENE_ARTICLE" => Some(Self::Article),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CreateScene {
    ///
    Invalid = 0,
    ///
    CreateWord = 1,
    ///
    CreateDraw = 2,
    ///
    CreateDynVideo = 3,
    ///
    Repost = 4,
    ///
    ShareBiz = 5,
    ///
    SharePage = 6,
    ///
    ShareProgram = 7,
    ///
    ReplySync = 8,
    ///
    ReplyCreateActivity = 9,
    ///
    CreateAd = 10,
    ///
    CreateLiveRcmd = 11,
    ///
    CreateArticle = 12,
}
impl CreateScene {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "CREATE_SCENE_INVALID",
            Self::CreateWord => "CREATE_SCENE_CREATE_WORD",
            Self::CreateDraw => "CREATE_SCENE_CREATE_DRAW",
            Self::CreateDynVideo => "CREATE_SCENE_CREATE_DYN_VIDEO",
            Self::Repost => "CREATE_SCENE_REPOST",
            Self::ShareBiz => "CREATE_SCENE_SHARE_BIZ",
            Self::SharePage => "CREATE_SCENE_SHARE_PAGE",
            Self::ShareProgram => "CREATE_SCENE_SHARE_PROGRAM",
            Self::ReplySync => "CREATE_SCENE_REPLY_SYNC",
            Self::ReplyCreateActivity => "CREATE_SCENE_REPLY_CREATE_ACTIVITY",
            Self::CreateAd => "CREATE_SCENE_CREATE_AD",
            Self::CreateLiveRcmd => "CREATE_SCENE_CREATE_LIVE_RCMD",
            Self::CreateArticle => "CREATE_SCENE_CREATE_ARTICLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CREATE_SCENE_INVALID" => Some(Self::Invalid),
            "CREATE_SCENE_CREATE_WORD" => Some(Self::CreateWord),
            "CREATE_SCENE_CREATE_DRAW" => Some(Self::CreateDraw),
            "CREATE_SCENE_CREATE_DYN_VIDEO" => Some(Self::CreateDynVideo),
            "CREATE_SCENE_REPOST" => Some(Self::Repost),
            "CREATE_SCENE_SHARE_BIZ" => Some(Self::ShareBiz),
            "CREATE_SCENE_SHARE_PAGE" => Some(Self::SharePage),
            "CREATE_SCENE_SHARE_PROGRAM" => Some(Self::ShareProgram),
            "CREATE_SCENE_REPLY_SYNC" => Some(Self::ReplySync),
            "CREATE_SCENE_REPLY_CREATE_ACTIVITY" => Some(Self::ReplyCreateActivity),
            "CREATE_SCENE_CREATE_AD" => Some(Self::CreateAd),
            "CREATE_SCENE_CREATE_LIVE_RCMD" => Some(Self::CreateLiveRcmd),
            "CREATE_SCENE_CREATE_ARTICLE" => Some(Self::CreateArticle),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OnlyFansOptionType {
    ///
    OnlyFansOptionNone = 0,
    ///
    OnlyFansOptionUpower = 1,
    ///
    OnlyFansOptionHighUpower = 2,
}
impl OnlyFansOptionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::OnlyFansOptionNone => "ONLY_FANS_OPTION_NONE",
            Self::OnlyFansOptionUpower => "ONLY_FANS_OPTION_UPOWER",
            Self::OnlyFansOptionHighUpower => "ONLY_FANS_OPTION_HIGH_UPOWER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ONLY_FANS_OPTION_NONE" => Some(Self::OnlyFansOptionNone),
            "ONLY_FANS_OPTION_UPOWER" => Some(Self::OnlyFansOptionUpower),
            "ONLY_FANS_OPTION_HIGH_UPOWER" => Some(Self::OnlyFansOptionHighUpower),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OpusBizType {
    ///
    Default = 0,
    ///
    Video = 1,
    ///
    Reserve = 2,
    ///
    VoteOpusBizType = 3,
    ///
    Live = 4,
    ///
    LotteryOpusBizType = 5,
    ///
    Match = 6,
    ///
    GoodsOpusBizType = 7,
    ///
    OgvSs = 8,
    ///
    OgvEpOpusBizType = 9,
    ///
    Manga = 10,
    ///
    Cheese = 11,
    ///
    VideoTs = 12,
    ///
    AtOpusBizType = 13,
    ///
    HashTag = 14,
    ///
    CvOpusBizType = 15,
    ///
    Url = 16,
    ///
    MailOpusBizType = 17,
    ///
    Lbs = 18,
    ///
    Activity = 19,
    ///
    AttachCardOfficialActivityOpusBizType = 20,
    ///
    Game = 21,
    ///
    Decoration = 22,
    ///
    UpTopic = 23,
    ///
    UpActivity = 24,
    ///
    UpMaoer = 25,
    ///
    MemberGoods = 26,
    ///
    OpenmallUpItems = 27,
    ///
    Music = 29,
    ///
    MemberTicket = 31,
    ///
    RepostPicUrl = 32,
    ///
    RepostPicDynUrl = 33,
    ///
    OgvFollowCard = 34,
    ///
    ArticleGoods = 35,
    ///
    ArticleTag = 36,
}
impl OpusBizType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "DEFAULT",
            Self::Video => "VIDEO",
            Self::Reserve => "RESERVE",
            Self::VoteOpusBizType => "VOTE_OpusBizType",
            Self::Live => "LIVE",
            Self::LotteryOpusBizType => "LOTTERY_OpusBizType",
            Self::Match => "MATCH",
            Self::GoodsOpusBizType => "GOODS_OpusBizType",
            Self::OgvSs => "OGV_SS",
            Self::OgvEpOpusBizType => "OGV_EP_OpusBizType",
            Self::Manga => "MANGA",
            Self::Cheese => "CHEESE",
            Self::VideoTs => "VIDEO_TS",
            Self::AtOpusBizType => "AT_OpusBizType",
            Self::HashTag => "HASH_TAG",
            Self::CvOpusBizType => "CV_OpusBizType",
            Self::Url => "URL",
            Self::MailOpusBizType => "MAIL_OpusBizType",
            Self::Lbs => "LBS",
            Self::Activity => "ACTIVITY",
            Self::AttachCardOfficialActivityOpusBizType => {
                "ATTACH_CARD_OFFICIAL_ACTIVITY_OpusBizType"
            }
            Self::Game => "GAME",
            Self::Decoration => "DECORATION",
            Self::UpTopic => "UP_TOPIC",
            Self::UpActivity => "UP_ACTIVITY",
            Self::UpMaoer => "UP_MAOER",
            Self::MemberGoods => "MEMBER_GOODS",
            Self::OpenmallUpItems => "OPENMALL_UP_ITEMS",
            Self::Music => "MUSIC",
            Self::MemberTicket => "MEMBER_TICKET",
            Self::RepostPicUrl => "REPOST_PIC_URL",
            Self::RepostPicDynUrl => "REPOST_PIC_DYN_URL",
            Self::OgvFollowCard => "OGV_FOLLOW_CARD",
            Self::ArticleGoods => "ARTICLE_GOODS",
            Self::ArticleTag => "ARTICLE_TAG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEFAULT" => Some(Self::Default),
            "VIDEO" => Some(Self::Video),
            "RESERVE" => Some(Self::Reserve),
            "VOTE_OpusBizType" => Some(Self::VoteOpusBizType),
            "LIVE" => Some(Self::Live),
            "LOTTERY_OpusBizType" => Some(Self::LotteryOpusBizType),
            "MATCH" => Some(Self::Match),
            "GOODS_OpusBizType" => Some(Self::GoodsOpusBizType),
            "OGV_SS" => Some(Self::OgvSs),
            "OGV_EP_OpusBizType" => Some(Self::OgvEpOpusBizType),
            "MANGA" => Some(Self::Manga),
            "CHEESE" => Some(Self::Cheese),
            "VIDEO_TS" => Some(Self::VideoTs),
            "AT_OpusBizType" => Some(Self::AtOpusBizType),
            "HASH_TAG" => Some(Self::HashTag),
            "CV_OpusBizType" => Some(Self::CvOpusBizType),
            "URL" => Some(Self::Url),
            "MAIL_OpusBizType" => Some(Self::MailOpusBizType),
            "LBS" => Some(Self::Lbs),
            "ACTIVITY" => Some(Self::Activity),
            "ATTACH_CARD_OFFICIAL_ACTIVITY_OpusBizType" => {
                Some(Self::AttachCardOfficialActivityOpusBizType)
            }
            "GAME" => Some(Self::Game),
            "DECORATION" => Some(Self::Decoration),
            "UP_TOPIC" => Some(Self::UpTopic),
            "UP_ACTIVITY" => Some(Self::UpActivity),
            "UP_MAOER" => Some(Self::UpMaoer),
            "MEMBER_GOODS" => Some(Self::MemberGoods),
            "OPENMALL_UP_ITEMS" => Some(Self::OpenmallUpItems),
            "MUSIC" => Some(Self::Music),
            "MEMBER_TICKET" => Some(Self::MemberTicket),
            "REPOST_PIC_URL" => Some(Self::RepostPicUrl),
            "REPOST_PIC_DYN_URL" => Some(Self::RepostPicDynUrl),
            "OGV_FOLLOW_CARD" => Some(Self::OgvFollowCard),
            "ARTICLE_GOODS" => Some(Self::ArticleGoods),
            "ARTICLE_TAG" => Some(Self::ArticleTag),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OpusSource {
    ///
    DefaultSource = 0,
    ///
    Album = 1,
    ///
    Article = 2,
    ///
    Note = 3,
    ///
    OgvComment = 4,
    ///
    ArticleH5 = 5,
    ///
    Word = 6,
    ///
    Repost = 7,
}
impl OpusSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DefaultSource => "DEFAULT_SOURCE",
            Self::Album => "ALBUM",
            Self::Article => "ARTICLE",
            Self::Note => "NOTE",
            Self::OgvComment => "OGV_COMMENT",
            Self::ArticleH5 => "ARTICLE_H5",
            Self::Word => "WORD",
            Self::Repost => "REPOST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEFAULT_SOURCE" => Some(Self::DefaultSource),
            "ALBUM" => Some(Self::Album),
            "ARTICLE" => Some(Self::Article),
            "NOTE" => Some(Self::Note),
            "OGV_COMMENT" => Some(Self::OgvComment),
            "ARTICLE_H5" => Some(Self::ArticleH5),
            "WORD" => Some(Self::Word),
            "REPOST" => Some(Self::Repost),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReserveSource {
    ///
    New = 0,
    ///
    Associated = 1,
}
impl ReserveSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::New => "RESERVE_SOURCE_NEW",
            Self::Associated => "RESERVE_SOURCE_ASSOCIATED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESERVE_SOURCE_NEW" => Some(Self::New),
            "RESERVE_SOURCE_ASSOCIATED" => Some(Self::Associated),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UpPermissionType {
    ///
    None = 0,
    ///
    Lottery = 1,
    ///
    ClipPublished = 2,
    ///
    UgcAttachCard = 3,
    ///
    GoodsAttachCard = 4,
    ///
    ChooseComment = 5,
    ///
    ControlComment = 6,
    ///
    ControlDanmu = 7,
    ///
    VideoReserve = 8,
    ///
    LiveReserve = 9,
    ///
    BizLink = 10,
    ///
    Commercial = 11,
    ///
    BigCover = 12,
    ///
    LiveVoyage = 13,
    ///
    OnlyFans = 14,
    ///
    TimingDyn = 15,
    ///
    Public = 16,
    ///
    Private = 17,
}
impl UpPermissionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "UP_PERMISSION_TYPE_NONE",
            Self::Lottery => "UP_PERMISSION_TYPE_LOTTERY",
            Self::ClipPublished => "UP_PERMISSION_TYPE_CLIP_PUBLISHED",
            Self::UgcAttachCard => "UP_PERMISSION_TYPE_UGC_ATTACH_CARD",
            Self::GoodsAttachCard => "UP_PERMISSION_TYPE_GOODS_ATTACH_CARD",
            Self::ChooseComment => "UP_PERMISSION_TYPE_CHOOSE_COMMENT",
            Self::ControlComment => "UP_PERMISSION_TYPE_CONTROL_COMMENT",
            Self::ControlDanmu => "UP_PERMISSION_TYPE_CONTROL_DANMU",
            Self::VideoReserve => "UP_PERMISSION_TYPE_VIDEO_RESERVE",
            Self::LiveReserve => "UP_PERMISSION_TYPE_LIVE_RESERVE",
            Self::BizLink => "UP_PERMISSION_TYPE_BIZ_LINK",
            Self::Commercial => "UP_PERMISSION_TYPE_COMMERCIAL",
            Self::BigCover => "UP_PERMISSION_TYPE_BIG_COVER",
            Self::LiveVoyage => "UP_PERMISSION_TYPE_LIVE_VOYAGE",
            Self::OnlyFans => "UP_PERMISSION_TYPE_ONLY_FANS",
            Self::TimingDyn => "UP_PERMISSION_TYPE_TIMING_DYN",
            Self::Public => "UP_PERMISSION_TYPE_PUBLIC",
            Self::Private => "UP_PERMISSION_TYPE_PRIVATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UP_PERMISSION_TYPE_NONE" => Some(Self::None),
            "UP_PERMISSION_TYPE_LOTTERY" => Some(Self::Lottery),
            "UP_PERMISSION_TYPE_CLIP_PUBLISHED" => Some(Self::ClipPublished),
            "UP_PERMISSION_TYPE_UGC_ATTACH_CARD" => Some(Self::UgcAttachCard),
            "UP_PERMISSION_TYPE_GOODS_ATTACH_CARD" => Some(Self::GoodsAttachCard),
            "UP_PERMISSION_TYPE_CHOOSE_COMMENT" => Some(Self::ChooseComment),
            "UP_PERMISSION_TYPE_CONTROL_COMMENT" => Some(Self::ControlComment),
            "UP_PERMISSION_TYPE_CONTROL_DANMU" => Some(Self::ControlDanmu),
            "UP_PERMISSION_TYPE_VIDEO_RESERVE" => Some(Self::VideoReserve),
            "UP_PERMISSION_TYPE_LIVE_RESERVE" => Some(Self::LiveReserve),
            "UP_PERMISSION_TYPE_BIZ_LINK" => Some(Self::BizLink),
            "UP_PERMISSION_TYPE_COMMERCIAL" => Some(Self::Commercial),
            "UP_PERMISSION_TYPE_BIG_COVER" => Some(Self::BigCover),
            "UP_PERMISSION_TYPE_LIVE_VOYAGE" => Some(Self::LiveVoyage),
            "UP_PERMISSION_TYPE_ONLY_FANS" => Some(Self::OnlyFans),
            "UP_PERMISSION_TYPE_TIMING_DYN" => Some(Self::TimingDyn),
            "UP_PERMISSION_TYPE_PUBLIC" => Some(Self::Public),
            "UP_PERMISSION_TYPE_PRIVATE" => Some(Self::Private),
            _ => None,
        }
    }
}
