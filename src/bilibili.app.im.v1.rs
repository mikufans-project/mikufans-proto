// This file is @generated by prost-build.
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AirDropShareUserInfo {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for AirDropShareUserInfo {
    const NAME: &'static str = "AirDropShareUserInfo";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.AirDropShareUserInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.AirDropShareUserInfo".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AirDropToImReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub user_infos: ::prost::alloc::vec::Vec<AirDropShareUserInfo>,
}
impl ::prost::Name for AirDropToImReply {
    const NAME: &'static str = "AirDropToImReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.AirDropToImReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.AirDropToImReply".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AirDropToImReq {
    ///
    #[prost(enumeration = "AirDropFrom", tag = "1")]
    pub adf: i32,
}
impl ::prost::Name for AirDropToImReq {
    const NAME: &'static str = "AirDropToImReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.AirDropToImReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.AirDropToImReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoReplyToast {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
}
impl ::prost::Name for AutoReplyToast {
    const NAME: &'static str = "AutoReplyToast";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.AutoReplyToast".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.AutoReplyToast".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BehaviorAlertToast {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub type_str: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "AlertToastType", tag = "4")]
    pub r#type: i32,
}
impl ::prost::Name for BehaviorAlertToast {
    const NAME: &'static str = "BehaviorAlertToast";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.BehaviorAlertToast".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.BehaviorAlertToast".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BorderedLabel {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
impl ::prost::Name for BorderedLabel {
    const NAME: &'static str = "BorderedLabel";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.BorderedLabel".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.BorderedLabel".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CancelInterceptInDustbinReply {}
impl ::prost::Name for CancelInterceptInDustbinReply {
    const NAME: &'static str = "CancelInterceptInDustbinReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.CancelInterceptInDustbinReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.CancelInterceptInDustbinReply".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CancelInterceptInDustbinReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub session_id: ::core::option::Option<SessionId>,
}
impl ::prost::Name for CancelInterceptInDustbinReq {
    const NAME: &'static str = "CancelInterceptInDustbinReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.CancelInterceptInDustbinReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.CancelInterceptInDustbinReq".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClearAlertReply {}
impl ::prost::Name for ClearAlertReply {
    const NAME: &'static str = "ClearAlertReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.ClearAlertReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.ClearAlertReply".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClearAlertReq {
    ///
    #[prost(enumeration = "AlertToastType", tag = "1")]
    pub r#type: i32,
}
impl ::prost::Name for ClearAlertReq {
    const NAME: &'static str = "ClearAlertReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.ClearAlertReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.ClearAlertReq".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClearUnreadReply {}
impl ::prost::Name for ClearUnreadReply {
    const NAME: &'static str = "ClearUnreadReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.ClearUnreadReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.ClearUnreadReply".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClearUnreadReq {
    ///
    #[prost(enumeration = "SessionPageType", tag = "1")]
    pub page_type: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub session_id: ::core::option::Option<SessionId>,
}
impl ::prost::Name for ClearUnreadReq {
    const NAME: &'static str = "ClearUnreadReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.ClearUnreadReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.ClearUnreadReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Contact {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub avatar: ::core::option::Option<
        super::super::super::dagw::component::avatar::v1::AvatarItem,
    >,
    ///
    #[prost(string, tag = "4")]
    pub vip_info: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub name_render: ::core::option::Option<
        super::super::super::account::service::v1::NameRender,
    >,
    ///
    #[prost(bool, tag = "7")]
    pub is_special_follow: bool,
    ///
    #[prost(string, tag = "8")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "9")]
    pub official_type: i32,
}
impl ::prost::Name for Contact {
    const NAME: &'static str = "Contact";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.Contact".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.Contact".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContactTab {
    ///
    #[prost(enumeration = "ContactTabType", tag = "1")]
    pub tab: i32,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for ContactTab {
    const NAME: &'static str = "ContactTab";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.ContactTab".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.ContactTab".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContactsReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub contacts: ::prost::alloc::vec::Vec<Contact>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub tab: ::prost::alloc::vec::Vec<ContactTab>,
    ///
    #[prost(enumeration = "ContactTabType", tag = "3")]
    pub current_tab: i32,
    ///
    #[prost(message, optional, tag = "4")]
    pub pagination_params: ::core::option::Option<PaginationParams>,
}
impl ::prost::Name for ContactsReply {
    const NAME: &'static str = "ContactsReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.ContactsReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.ContactsReply".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContactsReq {
    ///
    #[prost(enumeration = "ContactTabType", tag = "1")]
    pub tab: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub pagination_params: ::core::option::Option<PaginationParams>,
}
impl ::prost::Name for ContactsReq {
    const NAME: &'static str = "ContactsReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.ContactsReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.ContactsReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContactsSearchReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub contacts: ::prost::alloc::vec::Vec<Contact>,
    ///
    #[prost(message, optional, tag = "2")]
    pub pagination_params: ::core::option::Option<PaginationParams>,
}
impl ::prost::Name for ContactsSearchReply {
    const NAME: &'static str = "ContactsSearchReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.ContactsSearchReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.ContactsSearchReply".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContactsSearchReq {
    ///
    #[prost(string, tag = "1")]
    pub keyword: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "ContactTabType", tag = "2")]
    pub tab: i32,
    ///
    #[prost(message, optional, tag = "3")]
    pub pagination_params: ::core::option::Option<PaginationParams>,
}
impl ::prost::Name for ContactsSearchReq {
    const NAME: &'static str = "ContactsSearchReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.ContactsSearchReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.ContactsSearchReq".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerId {
    ///
    #[prost(int64, tag = "1")]
    pub shop_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub shop_type: i64,
}
impl ::prost::Name for CustomerId {
    const NAME: &'static str = "CustomerId";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.CustomerId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.CustomerId".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteSessionListReply {}
impl ::prost::Name for DeleteSessionListReply {
    const NAME: &'static str = "DeleteSessionListReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.DeleteSessionListReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.DeleteSessionListReply".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteSessionListReq {
    ///
    #[prost(enumeration = "SessionPageType", tag = "1")]
    pub page_type: i32,
}
impl ::prost::Name for DeleteSessionListReq {
    const NAME: &'static str = "DeleteSessionListReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.DeleteSessionListReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.DeleteSessionListReq".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteSessionReply {}
impl ::prost::Name for DeleteSessionReply {
    const NAME: &'static str = "DeleteSessionReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.DeleteSessionReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.DeleteSessionReply".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteSessionReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub session_id: ::core::option::Option<SessionId>,
}
impl ::prost::Name for DeleteSessionReq {
    const NAME: &'static str = "DeleteSessionReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.DeleteSessionReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.DeleteSessionReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilledLabel {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
}
impl ::prost::Name for FilledLabel {
    const NAME: &'static str = "FilledLabel";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.FilledLabel".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.FilledLabel".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterConfig {
    ///
    #[prost(message, repeated, tag = "1")]
    pub filters: ::prost::alloc::vec::Vec<SessionsFilter>,
    ///
    #[prost(enumeration = "SessionFilterType", tag = "2")]
    pub current_filter: i32,
}
impl ::prost::Name for FilterConfig {
    const NAME: &'static str = "FilterConfig";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.FilterConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.FilterConfig".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FoldId {
    ///
    #[prost(enumeration = "SessionType", tag = "1")]
    pub r#type: i32,
}
impl ::prost::Name for FoldId {
    const NAME: &'static str = "FoldId";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.FoldId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.FoldId".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetImSettingsReply {
    ///
    #[prost(string, tag = "1")]
    pub page_title: ::prost::alloc::string::String,
    ///
    #[prost(map = "int32, message", tag = "2")]
    pub settings: ::std::collections::HashMap<i32, Setting>,
}
impl ::prost::Name for GetImSettingsReply {
    const NAME: &'static str = "GetImSettingsReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.GetImSettingsReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.GetImSettingsReply".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetImSettingsReq {
    ///
    #[prost(enumeration = "ImSettingType", tag = "1")]
    pub r#type: i32,
}
impl ::prost::Name for GetImSettingsReq {
    const NAME: &'static str = "GetImSettingsReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.GetImSettingsReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.GetImSettingsReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetQuickLinkUnreadReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<QuickLinkUnreadItem>,
}
impl ::prost::Name for GetQuickLinkUnreadReply {
    const NAME: &'static str = "GetQuickLinkUnreadReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.GetQuickLinkUnreadReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.GetQuickLinkUnreadReply".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetQuickLinkUnreadReq {}
impl ::prost::Name for GetQuickLinkUnreadReq {
    const NAME: &'static str = "GetQuickLinkUnreadReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.GetQuickLinkUnreadReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.GetQuickLinkUnreadReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTotalUnreadReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub total: ::core::option::Option<Unread>,
}
impl ::prost::Name for GetTotalUnreadReply {
    const NAME: &'static str = "GetTotalUnreadReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.GetTotalUnreadReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.GetTotalUnreadReply".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetTotalUnreadReq {}
impl ::prost::Name for GetTotalUnreadReq {
    const NAME: &'static str = "GetTotalUnreadReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.GetTotalUnreadReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.GetTotalUnreadReq".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GroupId {
    ///
    #[prost(int64, tag = "1")]
    pub group_id: i64,
}
impl ::prost::Name for GroupId {
    const NAME: &'static str = "GroupId";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.GroupId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.GroupId".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageLabel {
    ///
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "2")]
    pub width: i32,
    ///
    #[prost(int32, tag = "3")]
    pub height: i32,
}
impl ::prost::Name for ImageLabel {
    const NAME: &'static str = "ImageLabel";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.ImageLabel".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.ImageLabel".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordBlockingAddReply {
    ///
    #[prost(string, tag = "1")]
    pub toast: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub item: ::core::option::Option<KeywordBlockingItem>,
}
impl ::prost::Name for KeywordBlockingAddReply {
    const NAME: &'static str = "KeywordBlockingAddReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.KeywordBlockingAddReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.KeywordBlockingAddReply".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordBlockingAddReq {
    ///
    #[prost(string, tag = "1")]
    pub keyword: ::prost::alloc::string::String,
}
impl ::prost::Name for KeywordBlockingAddReq {
    const NAME: &'static str = "KeywordBlockingAddReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.KeywordBlockingAddReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.KeywordBlockingAddReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordBlockingDeleteReply {
    ///
    #[prost(string, tag = "1")]
    pub toast: ::prost::alloc::string::String,
}
impl ::prost::Name for KeywordBlockingDeleteReply {
    const NAME: &'static str = "KeywordBlockingDeleteReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.KeywordBlockingDeleteReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.KeywordBlockingDeleteReply".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordBlockingDeleteReq {
    ///
    #[prost(string, tag = "1")]
    pub keyword: ::prost::alloc::string::String,
}
impl ::prost::Name for KeywordBlockingDeleteReq {
    const NAME: &'static str = "KeywordBlockingDeleteReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.KeywordBlockingDeleteReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.KeywordBlockingDeleteReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordBlockingItem {
    ///
    #[prost(string, tag = "1")]
    pub keyword: ::prost::alloc::string::String,
}
impl ::prost::Name for KeywordBlockingItem {
    const NAME: &'static str = "KeywordBlockingItem";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.KeywordBlockingItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.KeywordBlockingItem".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeywordBlockingListReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<KeywordBlockingItem>,
    ///
    #[prost(int32, tag = "2")]
    pub list_limit: i32,
    ///
    #[prost(int32, tag = "3")]
    pub char_limit: i32,
    ///
    #[prost(string, tag = "4")]
    pub list_limit_text: ::prost::alloc::string::String,
}
impl ::prost::Name for KeywordBlockingListReply {
    const NAME: &'static str = "KeywordBlockingListReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.KeywordBlockingListReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.KeywordBlockingListReply".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordBlockingListReq {}
impl ::prost::Name for KeywordBlockingListReq {
    const NAME: &'static str = "KeywordBlockingListReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.KeywordBlockingListReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.KeywordBlockingListReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Medal {
    ///
    #[prost(int64, tag = "1")]
    pub uid: i64,
    ///
    #[prost(int32, tag = "2")]
    pub medal_id: i32,
    ///
    #[prost(int32, tag = "3")]
    pub level: i32,
    ///
    #[prost(string, tag = "4")]
    pub medal_name: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "5")]
    pub score: i32,
    ///
    #[prost(int32, tag = "6")]
    pub intimacy: i32,
    ///
    #[prost(int32, tag = "7")]
    pub master_status: i32,
    ///
    #[prost(int32, tag = "8")]
    pub is_receive: i32,
    ///
    #[prost(string, tag = "9")]
    pub medal_color_start: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub medal_color_end: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub medal_color_border: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "12")]
    pub medal_color_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "13")]
    pub medal_color_level: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "14")]
    pub guard_level: i64,
}
impl ::prost::Name for Medal {
    const NAME: &'static str = "Medal";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.Medal".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.Medal".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSummary {
    ///
    #[prost(string, tag = "1")]
    pub raw_msg: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "MsgSummaryPrefixType", tag = "2")]
    pub prefix_type: i32,
    ///
    #[prost(string, tag = "3")]
    pub prefix_text: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "4")]
    pub is_group_owner: bool,
}
impl ::prost::Name for MsgSummary {
    const NAME: &'static str = "MsgSummary";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.MsgSummary".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.MsgSummary".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Offset {
    ///
    #[prost(int64, tag = "1")]
    pub normal_offset: i64,
    ///
    #[prost(int64, tag = "2")]
    pub top_offset: i64,
}
impl ::prost::Name for Offset {
    const NAME: &'static str = "Offset";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.Offset".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.Offset".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationContent {
    ///
    #[prost(bool, tag = "1")]
    pub show: bool,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
impl ::prost::Name for OperationContent {
    const NAME: &'static str = "OperationContent";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.OperationContent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.OperationContent".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaginationParams {
    ///
    #[prost(map = "int32, message", tag = "1")]
    pub offsets: ::std::collections::HashMap<i32, Offset>,
    ///
    #[prost(bool, tag = "2")]
    pub has_more: bool,
}
impl ::prost::Name for PaginationParams {
    const NAME: &'static str = "PaginationParams";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.PaginationParams".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.PaginationParams".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PinSessionReply {
    ///
    #[prost(int64, tag = "1")]
    pub sequence_number: i64,
    ///
    #[prost(int64, tag = "2")]
    pub code: i64,
    ///
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
impl ::prost::Name for PinSessionReply {
    const NAME: &'static str = "PinSessionReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.PinSessionReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.PinSessionReply".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PinSessionReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub session_id: ::core::option::Option<SessionId>,
    ///
    #[prost(int64, tag = "2")]
    pub top_time_micros: i64,
}
impl ::prost::Name for PinSessionReq {
    const NAME: &'static str = "PinSessionReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.PinSessionReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.PinSessionReq".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PrivateId {
    ///
    #[prost(int64, tag = "1")]
    pub talker_uid: i64,
}
impl ::prost::Name for PrivateId {
    const NAME: &'static str = "PrivateId";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.PrivateId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.PrivateId".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuickLinkBubble {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub avatar: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub nick_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub content: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "QuickLinkItemType", tag = "5")]
    pub quick_link_item: i32,
    ///
    #[prost(enumeration = "QuickLinkMsgType", tag = "6")]
    pub msg_type: i32,
}
impl ::prost::Name for QuickLinkBubble {
    const NAME: &'static str = "QuickLinkBubble";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.QuickLinkBubble".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.QuickLinkBubble".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuickLinkConfig {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<QuickLinkItem>,
    ///
    #[prost(message, optional, tag = "2")]
    pub bubble: ::core::option::Option<QuickLinkBubble>,
    ///
    #[prost(bool, tag = "3")]
    pub is_legacy_style: bool,
}
impl ::prost::Name for QuickLinkConfig {
    const NAME: &'static str = "QuickLinkConfig";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.QuickLinkConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.QuickLinkConfig".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuickLinkItem {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon_dark: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub unread: ::core::option::Option<Unread>,
    ///
    #[prost(enumeration = "QuickLinkItemType", tag = "6")]
    pub item_type: i32,
}
impl ::prost::Name for QuickLinkItem {
    const NAME: &'static str = "QuickLinkItem";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.QuickLinkItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.QuickLinkItem".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuickLinkUnreadItem {
    ///
    #[prost(enumeration = "QuickLinkItemType", tag = "1")]
    pub item_type: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub unread: ::core::option::Option<Unread>,
}
impl ::prost::Name for QuickLinkUnreadItem {
    const NAME: &'static str = "QuickLinkUnreadItem";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.QuickLinkUnreadItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.QuickLinkUnreadItem".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RestrictedMode {
    ///
    #[prost(bool, tag = "1")]
    pub teenagers: bool,
    ///
    #[prost(bool, tag = "2")]
    pub lessons: bool,
}
impl ::prost::Name for RestrictedMode {
    const NAME: &'static str = "RestrictedMode";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.RestrictedMode".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.RestrictedMode".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SelectItem {
    ///
    #[prost(int32, tag = "1")]
    pub item_type: i32,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "3")]
    pub selected: bool,
}
impl ::prost::Name for SelectItem {
    const NAME: &'static str = "SelectItem";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SelectItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SelectItem".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Session {
    ///
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<SessionId>,
    ///
    #[prost(message, optional, tag = "2")]
    pub session_info: ::core::option::Option<SessionInfo>,
    ///
    #[prost(message, optional, tag = "3")]
    pub unread: ::core::option::Option<Unread>,
    ///
    #[prost(message, optional, tag = "4")]
    pub msg_summary: ::core::option::Option<MsgSummary>,
    ///
    #[prost(int64, tag = "5")]
    pub timestamp: i64,
    ///
    #[prost(bool, tag = "6")]
    pub is_pinned: bool,
    ///
    #[prost(int64, tag = "7")]
    pub sequence_number: i64,
    ///
    #[prost(bool, tag = "8")]
    pub is_muted: bool,
    ///
    #[prost(string, tag = "9")]
    pub chat_url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "10")]
    pub operation: ::core::option::Option<SessionOperation>,
    ///
    #[prost(map = "string, string", tag = "11")]
    pub trace_params: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
impl ::prost::Name for Session {
    const NAME: &'static str = "Session";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.Session".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.Session".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SessionId {
    ///
    #[prost(oneof = "session_id::Id", tags = "1, 2, 3, 4, 5")]
    pub id: ::core::option::Option<session_id::Id>,
}
/// Nested message and enum types in `SessionId`.
pub mod session_id {
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Id {
        ///
        #[prost(message, tag = "1")]
        PrivateId(super::PrivateId),
        ///
        #[prost(message, tag = "2")]
        GroupId(super::GroupId),
        ///
        #[prost(message, tag = "3")]
        FoldId(super::FoldId),
        ///
        #[prost(message, tag = "4")]
        SystemId(super::SystemId),
        ///
        #[prost(message, tag = "5")]
        CustomerId(super::CustomerId),
    }
}
impl ::prost::Name for SessionId {
    const NAME: &'static str = "SessionId";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SessionId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SessionId".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionInfo {
    ///
    #[prost(string, tag = "1")]
    pub session_name: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub name_render: ::core::option::Option<
        super::super::super::account::service::v1::NameRender,
    >,
    ///
    #[prost(message, optional, tag = "3")]
    pub avatar: ::core::option::Option<
        super::super::super::dagw::component::avatar::v1::AvatarItem,
    >,
    ///
    #[prost(string, tag = "4")]
    pub vip_info: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub user_label: ::core::option::Option<UserLabel>,
    ///
    #[prost(bool, tag = "6")]
    pub is_live: bool,
}
impl ::prost::Name for SessionInfo {
    const NAME: &'static str = "SessionInfo";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SessionInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SessionInfo".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionListExtraInfo {
    ///
    #[prost(message, optional, tag = "1")]
    pub auto_reply_toast: ::core::option::Option<AutoReplyToast>,
    ///
    #[prost(bool, tag = "2")]
    pub show_anti_harassment_popup: bool,
    ///
    #[prost(string, tag = "3")]
    pub customer_hint_title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub behavior_alert_toast: ::core::option::Option<BehaviorAlertToast>,
}
impl ::prost::Name for SessionListExtraInfo {
    const NAME: &'static str = "SessionListExtraInfo";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SessionListExtraInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SessionListExtraInfo".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionListUpdateReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub sessions: ::prost::alloc::vec::Vec<Session>,
    ///
    #[prost(message, optional, tag = "2")]
    pub update_session_params: ::core::option::Option<UpdateSessionParams>,
}
impl ::prost::Name for SessionListUpdateReply {
    const NAME: &'static str = "SessionListUpdateReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SessionListUpdateReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SessionListUpdateReply".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionListUpdateReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub restricted_mode: ::core::option::Option<RestrictedMode>,
    ///
    #[prost(message, optional, tag = "2")]
    pub update_params: ::core::option::Option<UpdateSessionParams>,
    ///
    #[prost(enumeration = "SessionPageType", tag = "3")]
    pub page_type: i32,
    ///
    #[prost(enumeration = "SessionFilterType", tag = "4")]
    pub filter_type: i32,
}
impl ::prost::Name for SessionListUpdateReq {
    const NAME: &'static str = "SessionListUpdateReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SessionListUpdateReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SessionListUpdateReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionMainReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub pagination_params: ::core::option::Option<PaginationParams>,
    ///
    #[prost(message, optional, tag = "2")]
    pub update_session_params: ::core::option::Option<UpdateSessionParams>,
    ///
    #[prost(message, optional, tag = "3")]
    pub quick_link_config: ::core::option::Option<QuickLinkConfig>,
    ///
    #[prost(message, optional, tag = "4")]
    pub filter_config: ::core::option::Option<FilterConfig>,
    ///
    #[prost(message, repeated, tag = "5")]
    pub sessions: ::prost::alloc::vec::Vec<Session>,
    ///
    #[prost(message, repeated, tag = "6")]
    pub three_dot_items: ::prost::alloc::vec::Vec<ThreeDotItem>,
    ///
    #[prost(message, repeated, tag = "7")]
    pub outside_item: ::prost::alloc::vec::Vec<ThreeDotItem>,
    ///
    #[prost(message, optional, tag = "8")]
    pub extra_info: ::core::option::Option<SessionListExtraInfo>,
}
impl ::prost::Name for SessionMainReply {
    const NAME: &'static str = "SessionMainReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SessionMainReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SessionMainReply".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionMainReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub restricted_mode: ::core::option::Option<RestrictedMode>,
    ///
    #[prost(message, optional, tag = "2")]
    pub pagination_params: ::core::option::Option<PaginationParams>,
    ///
    #[prost(enumeration = "SessionFilterType", tag = "3")]
    pub filter_type: i32,
}
impl ::prost::Name for SessionMainReq {
    const NAME: &'static str = "SessionMainReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SessionMainReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SessionMainReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionOperation {
    ///
    #[prost(message, optional, tag = "1")]
    pub pin: ::core::option::Option<OperationContent>,
    ///
    #[prost(message, optional, tag = "2")]
    pub unpin: ::core::option::Option<OperationContent>,
    ///
    #[prost(message, optional, tag = "3")]
    pub delete: ::core::option::Option<OperationContent>,
    ///
    #[prost(message, optional, tag = "4")]
    pub clear_unread: ::core::option::Option<OperationContent>,
    ///
    #[prost(message, optional, tag = "5")]
    pub unblock: ::core::option::Option<OperationContent>,
}
impl ::prost::Name for SessionOperation {
    const NAME: &'static str = "SessionOperation";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SessionOperation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SessionOperation".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionSecondaryReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub pagination_params: ::core::option::Option<PaginationParams>,
    ///
    #[prost(message, optional, tag = "2")]
    pub update_session_params: ::core::option::Option<UpdateSessionParams>,
    ///
    #[prost(message, repeated, tag = "3")]
    pub sessions: ::prost::alloc::vec::Vec<Session>,
    ///
    #[prost(message, repeated, tag = "4")]
    pub three_dot_items: ::prost::alloc::vec::Vec<ThreeDotItem>,
    ///
    #[prost(message, repeated, tag = "5")]
    pub outside_item: ::prost::alloc::vec::Vec<ThreeDotItem>,
}
impl ::prost::Name for SessionSecondaryReply {
    const NAME: &'static str = "SessionSecondaryReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SessionSecondaryReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SessionSecondaryReply".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionSecondaryReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub restricted_mode: ::core::option::Option<RestrictedMode>,
    ///
    #[prost(message, optional, tag = "2")]
    pub pagination_params: ::core::option::Option<PaginationParams>,
    ///
    #[prost(enumeration = "SessionPageType", tag = "3")]
    pub page_type: i32,
}
impl ::prost::Name for SessionSecondaryReq {
    const NAME: &'static str = "SessionSecondaryReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SessionSecondaryReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SessionSecondaryReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionUpdateReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub session: ::core::option::Option<Session>,
}
impl ::prost::Name for SessionUpdateReply {
    const NAME: &'static str = "SessionUpdateReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SessionUpdateReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SessionUpdateReply".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SessionUpdateReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub session_id: ::core::option::Option<SessionId>,
    ///
    #[prost(enumeration = "SessionPageType", tag = "2")]
    pub page_type: i32,
}
impl ::prost::Name for SessionUpdateReq {
    const NAME: &'static str = "SessionUpdateReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SessionUpdateReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SessionUpdateReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionsFilter {
    ///
    #[prost(enumeration = "SessionFilterType", tag = "1")]
    pub stype: i32,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
}
impl ::prost::Name for SessionsFilter {
    const NAME: &'static str = "SessionsFilter";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SessionsFilter".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SessionsFilter".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetImSettingsReply {
    ///
    #[prost(string, tag = "1")]
    pub toast: ::prost::alloc::string::String,
}
impl ::prost::Name for SetImSettingsReply {
    const NAME: &'static str = "SetImSettingsReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SetImSettingsReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SetImSettingsReply".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetImSettingsReq {
    ///
    #[prost(map = "int32, message", tag = "1")]
    pub settings: ::std::collections::HashMap<i32, Setting>,
}
impl ::prost::Name for SetImSettingsReq {
    const NAME: &'static str = "SetImSettingsReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SetImSettingsReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SetImSettingsReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Setting {
    ///
    #[prost(oneof = "setting::Content", tags = "1, 2, 3, 4")]
    pub content: ::core::option::Option<setting::Content>,
}
/// Nested message and enum types in `Setting`.
pub mod setting {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        ///
        #[prost(message, tag = "1")]
        Switch(super::SettingSwitch),
        ///
        #[prost(message, tag = "2")]
        Select(super::SettingSelect),
        ///
        #[prost(message, tag = "3")]
        Redirect(super::SettingRedirect),
        ///
        #[prost(message, tag = "4")]
        Text(super::SettingText),
    }
}
impl ::prost::Name for Setting {
    const NAME: &'static str = "Setting";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.Setting".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.Setting".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettingRedirect {
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub subtitle: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub selected_summary: ::prost::alloc::string::String,
    ///
    #[prost(oneof = "setting_redirect::Content", tags = "1, 2, 6, 7")]
    pub content: ::core::option::Option<setting_redirect::Content>,
}
/// Nested message and enum types in `SettingRedirect`.
pub mod setting_redirect {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        ///
        #[prost(message, tag = "1")]
        SettingPage(super::Redirect2SettingPage),
        ///
        #[prost(message, tag = "2")]
        OtherPage(super::Redirect2OtherPage),
        ///
        #[prost(message, tag = "6")]
        Popup(super::Redirect2Popup),
        ///
        #[prost(message, tag = "7")]
        WindowSelect(super::RedirectWindowSelect),
    }
}
impl ::prost::Name for SettingRedirect {
    const NAME: &'static str = "SettingRedirect";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SettingRedirect".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SettingRedirect".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettingSelect {
    ///
    #[prost(message, repeated, tag = "1")]
    pub item: ::prost::alloc::vec::Vec<SelectItem>,
}
impl ::prost::Name for SettingSelect {
    const NAME: &'static str = "SettingSelect";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SettingSelect".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SettingSelect".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettingSwitch {
    ///
    #[prost(bool, tag = "1")]
    pub switch_on: bool,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub subtitle: ::prost::alloc::string::String,
}
impl ::prost::Name for SettingSwitch {
    const NAME: &'static str = "SettingSwitch";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SettingSwitch".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SettingSwitch".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettingText {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
}
impl ::prost::Name for SettingText {
    const NAME: &'static str = "SettingText";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SettingText".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SettingText".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SystemId {
    ///
    #[prost(enumeration = "SessionType", tag = "1")]
    pub r#type: i32,
}
impl ::prost::Name for SystemId {
    const NAME: &'static str = "SystemId";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.SystemId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.SystemId".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreeDotItem {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "ThreeDotItemType", tag = "4")]
    pub r#type: i32,
    ///
    #[prost(bool, tag = "5")]
    pub has_red_dot: bool,
}
impl ::prost::Name for ThreeDotItem {
    const NAME: &'static str = "ThreeDotItem";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.ThreeDotItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.ThreeDotItem".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnPinSessionReply {
    ///
    #[prost(int64, tag = "1")]
    pub sequence_number: i64,
}
impl ::prost::Name for UnPinSessionReply {
    const NAME: &'static str = "UnPinSessionReply";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.UnPinSessionReply".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.UnPinSessionReply".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnPinSessionReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub session_id: ::core::option::Option<SessionId>,
}
impl ::prost::Name for UnPinSessionReq {
    const NAME: &'static str = "UnPinSessionReq";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.UnPinSessionReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.UnPinSessionReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Unread {
    ///
    #[prost(enumeration = "UnreadStyle", tag = "1")]
    pub style: i32,
    ///
    #[prost(int64, tag = "2")]
    pub number: i64,
    ///
    #[prost(string, tag = "3")]
    pub number_show: ::prost::alloc::string::String,
}
impl ::prost::Name for Unread {
    const NAME: &'static str = "Unread";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.Unread".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.Unread".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSessionParams {
    ///
    #[prost(map = "int32, message", tag = "1")]
    pub max_session_ts: ::std::collections::HashMap<i32, Offset>,
}
impl ::prost::Name for UpdateSessionParams {
    const NAME: &'static str = "UpdateSessionParams";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.UpdateSessionParams".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.UpdateSessionParams".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserLabel {
    ///
    #[prost(enumeration = "LabelType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub style: ::core::option::Option<UserLabelStyle>,
}
impl ::prost::Name for UserLabel {
    const NAME: &'static str = "UserLabel";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.UserLabel".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.UserLabel".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserLabelStyle {
    ///
    #[prost(oneof = "user_label_style::Style", tags = "2, 3, 4, 5")]
    pub style: ::core::option::Option<user_label_style::Style>,
}
/// Nested message and enum types in `UserLabelStyle`.
pub mod user_label_style {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Style {
        ///
        #[prost(message, tag = "2")]
        BorderedLabel(super::BorderedLabel),
        ///
        #[prost(message, tag = "3")]
        FilledLabel(super::FilledLabel),
        ///
        #[prost(message, tag = "4")]
        ImageLabel(super::ImageLabel),
        ///
        #[prost(message, tag = "5")]
        MedalLabel(super::Medal),
    }
}
impl ::prost::Name for UserLabelStyle {
    const NAME: &'static str = "UserLabelStyle";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.UserLabelStyle".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.UserLabelStyle".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Redirect2OtherPage {
    ///
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
}
impl ::prost::Name for Redirect2OtherPage {
    const NAME: &'static str = "redirect2OtherPage";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.redirect2OtherPage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.redirect2OtherPage".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Redirect2Popup {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub subtitle: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
}
impl ::prost::Name for Redirect2Popup {
    const NAME: &'static str = "redirect2Popup";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.redirect2Popup".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.redirect2Popup".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Redirect2SettingPage {
    ///
    #[prost(map = "int32, message", tag = "1")]
    pub sub_settings: ::std::collections::HashMap<i32, Setting>,
    ///
    #[prost(string, tag = "2")]
    pub page_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "ImSettingType", tag = "4")]
    pub parent_setting_type: i32,
}
impl ::prost::Name for Redirect2SettingPage {
    const NAME: &'static str = "redirect2SettingPage";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.redirect2SettingPage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.redirect2SettingPage".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedirectWindowSelect {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub item: ::prost::alloc::vec::Vec<SelectItem>,
}
impl ::prost::Name for RedirectWindowSelect {
    const NAME: &'static str = "redirectWindowSelect";
    const PACKAGE: &'static str = "bilibili.app.im.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.im.v1.redirectWindowSelect".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.im.v1.redirectWindowSelect".into()
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AirDropFrom {
    ///
    AdfUnknown = 0,
    ///
    AdfInsideApp = 1,
    ///
    AdfOutsideApp = 2,
}
impl AirDropFrom {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AdfUnknown => "ADF_UNKNOWN",
            Self::AdfInsideApp => "ADF_INSIDE_APP",
            Self::AdfOutsideApp => "ADF_OUTSIDE_APP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ADF_UNKNOWN" => Some(Self::AdfUnknown),
            "ADF_INSIDE_APP" => Some(Self::AdfInsideApp),
            "ADF_OUTSIDE_APP" => Some(Self::AdfOutsideApp),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AlertToastType {
    ///
    Unspecified = 0,
    ///
    Banned = 1,
    ///
    Report = 2,
}
impl AlertToastType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ALERT_TOAST_TYPE_UNSPECIFIED",
            Self::Banned => "ALERT_TOAST_TYPE_BANNED",
            Self::Report => "ALERT_TOAST_TYPE_REPORT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALERT_TOAST_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ALERT_TOAST_TYPE_BANNED" => Some(Self::Banned),
            "ALERT_TOAST_TYPE_REPORT" => Some(Self::Report),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ContactTabType {
    ///
    TabUnknown = 0,
    ///
    TabGroup = 1,
    ///
    TabFollow = 2,
    ///
    TabFans = 3,
}
impl ContactTabType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TabUnknown => "TAB_UNKNOWN",
            Self::TabGroup => "TAB_GROUP",
            Self::TabFollow => "TAB_FOLLOW",
            Self::TabFans => "TAB_FANS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TAB_UNKNOWN" => Some(Self::TabUnknown),
            "TAB_GROUP" => Some(Self::TabGroup),
            "TAB_FOLLOW" => Some(Self::TabFollow),
            "TAB_FANS" => Some(Self::TabFans),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ImSettingType {
    ///
    SettingTypeNeedAll = 0,
    ///
    SettingTypeReplyMe = 1,
    ///
    SettingTypeNewFans = 2,
    ///
    SettingTypeReceiveLike = 3,
    ///
    SettingTypeMsgRemind = 4,
    ///
    SettingTypeMsgInterception = 5,
    ///
    SettingTypeFansGroupMsg = 6,
    ///
    SettingTypeFansGroupMsgReceive = 7,
    ///
    SettingTypeFansGroupMsgFold = 8,
    ///
    SettingTypeFansGroupMsgJoinGuide = 9,
    ///
    SettingTypeUnfollowedMsg = 10,
    ///
    SettingTypeUnfollowedMsgFold = 11,
    ///
    SettingTypeBlackList = 12,
    ///
    SettingTypeAntiHarassment = 13,
    ///
    SettingTypeAntiHarassmentSwitch = 14,
    ///
    SettingTypeAntiHarassmentOpenTipText = 15,
    ///
    SettingTypeCloseFansGroup = 16,
    ///
    SettingTypeOldReplyMe = 17,
    ///
    SettingTypeOldAtMe = 18,
    ///
    SettingTypeOldReceiveLike = 19,
    ///
    SettingTypeAntiHarassmentInteractLimits = 20,
    ///
    SettingTypeAntiHarassmentDuration = 21,
    ///
    SettingTypeAntiHarassmentCommentLimits = 22,
    ///
    SettingTypeAntiHarassmentDanmuLimits = 23,
    ///
    SettingTypeUnfollowedMsgReceive = 24,
    ///
    SettingTypeAntiHarassmentImLimits = 25,
    ///
    SettingTypeKeywordBlocking = 26,
}
impl ImSettingType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SettingTypeNeedAll => "SETTING_TYPE_NEED_ALL",
            Self::SettingTypeReplyMe => "SETTING_TYPE_REPLY_ME",
            Self::SettingTypeNewFans => "SETTING_TYPE_NEW_FANS",
            Self::SettingTypeReceiveLike => "SETTING_TYPE_RECEIVE_LIKE",
            Self::SettingTypeMsgRemind => "SETTING_TYPE_MSG_REMIND",
            Self::SettingTypeMsgInterception => "SETTING_TYPE_MSG_INTERCEPTION",
            Self::SettingTypeFansGroupMsg => "SETTING_TYPE_FANS_GROUP_MSG",
            Self::SettingTypeFansGroupMsgReceive => "SETTING_TYPE_FANS_GROUP_MSG_RECEIVE",
            Self::SettingTypeFansGroupMsgFold => "SETTING_TYPE_FANS_GROUP_MSG_FOLD",
            Self::SettingTypeFansGroupMsgJoinGuide => {
                "SETTING_TYPE_FANS_GROUP_MSG_JOIN_GUIDE"
            }
            Self::SettingTypeUnfollowedMsg => "SETTING_TYPE_UNFOLLOWED_MSG",
            Self::SettingTypeUnfollowedMsgFold => "SETTING_TYPE_UNFOLLOWED_MSG_FOLD",
            Self::SettingTypeBlackList => "SETTING_TYPE_BLACK_LIST",
            Self::SettingTypeAntiHarassment => "SETTING_TYPE_ANTI_HARASSMENT",
            Self::SettingTypeAntiHarassmentSwitch => {
                "SETTING_TYPE_ANTI_HARASSMENT_SWITCH"
            }
            Self::SettingTypeAntiHarassmentOpenTipText => {
                "SETTING_TYPE_ANTI_HARASSMENT_OPEN_TIP_TEXT"
            }
            Self::SettingTypeCloseFansGroup => "SETTING_TYPE_CLOSE_FANS_GROUP",
            Self::SettingTypeOldReplyMe => "SETTING_TYPE_OLD_REPLY_ME",
            Self::SettingTypeOldAtMe => "SETTING_TYPE_OLD_AT_ME",
            Self::SettingTypeOldReceiveLike => "SETTING_TYPE_OLD_RECEIVE_LIKE",
            Self::SettingTypeAntiHarassmentInteractLimits => {
                "SETTING_TYPE_ANTI_HARASSMENT_INTERACT_LIMITS"
            }
            Self::SettingTypeAntiHarassmentDuration => {
                "SETTING_TYPE_ANTI_HARASSMENT_DURATION"
            }
            Self::SettingTypeAntiHarassmentCommentLimits => {
                "SETTING_TYPE_ANTI_HARASSMENT_COMMENT_LIMITS"
            }
            Self::SettingTypeAntiHarassmentDanmuLimits => {
                "SETTING_TYPE_ANTI_HARASSMENT_DANMU_LIMITS"
            }
            Self::SettingTypeUnfollowedMsgReceive => {
                "SETTING_TYPE_UNFOLLOWED_MSG_RECEIVE"
            }
            Self::SettingTypeAntiHarassmentImLimits => {
                "SETTING_TYPE_ANTI_HARASSMENT_IM_LIMITS"
            }
            Self::SettingTypeKeywordBlocking => "SETTING_TYPE_KEYWORD_BLOCKING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SETTING_TYPE_NEED_ALL" => Some(Self::SettingTypeNeedAll),
            "SETTING_TYPE_REPLY_ME" => Some(Self::SettingTypeReplyMe),
            "SETTING_TYPE_NEW_FANS" => Some(Self::SettingTypeNewFans),
            "SETTING_TYPE_RECEIVE_LIKE" => Some(Self::SettingTypeReceiveLike),
            "SETTING_TYPE_MSG_REMIND" => Some(Self::SettingTypeMsgRemind),
            "SETTING_TYPE_MSG_INTERCEPTION" => Some(Self::SettingTypeMsgInterception),
            "SETTING_TYPE_FANS_GROUP_MSG" => Some(Self::SettingTypeFansGroupMsg),
            "SETTING_TYPE_FANS_GROUP_MSG_RECEIVE" => {
                Some(Self::SettingTypeFansGroupMsgReceive)
            }
            "SETTING_TYPE_FANS_GROUP_MSG_FOLD" => Some(Self::SettingTypeFansGroupMsgFold),
            "SETTING_TYPE_FANS_GROUP_MSG_JOIN_GUIDE" => {
                Some(Self::SettingTypeFansGroupMsgJoinGuide)
            }
            "SETTING_TYPE_UNFOLLOWED_MSG" => Some(Self::SettingTypeUnfollowedMsg),
            "SETTING_TYPE_UNFOLLOWED_MSG_FOLD" => {
                Some(Self::SettingTypeUnfollowedMsgFold)
            }
            "SETTING_TYPE_BLACK_LIST" => Some(Self::SettingTypeBlackList),
            "SETTING_TYPE_ANTI_HARASSMENT" => Some(Self::SettingTypeAntiHarassment),
            "SETTING_TYPE_ANTI_HARASSMENT_SWITCH" => {
                Some(Self::SettingTypeAntiHarassmentSwitch)
            }
            "SETTING_TYPE_ANTI_HARASSMENT_OPEN_TIP_TEXT" => {
                Some(Self::SettingTypeAntiHarassmentOpenTipText)
            }
            "SETTING_TYPE_CLOSE_FANS_GROUP" => Some(Self::SettingTypeCloseFansGroup),
            "SETTING_TYPE_OLD_REPLY_ME" => Some(Self::SettingTypeOldReplyMe),
            "SETTING_TYPE_OLD_AT_ME" => Some(Self::SettingTypeOldAtMe),
            "SETTING_TYPE_OLD_RECEIVE_LIKE" => Some(Self::SettingTypeOldReceiveLike),
            "SETTING_TYPE_ANTI_HARASSMENT_INTERACT_LIMITS" => {
                Some(Self::SettingTypeAntiHarassmentInteractLimits)
            }
            "SETTING_TYPE_ANTI_HARASSMENT_DURATION" => {
                Some(Self::SettingTypeAntiHarassmentDuration)
            }
            "SETTING_TYPE_ANTI_HARASSMENT_COMMENT_LIMITS" => {
                Some(Self::SettingTypeAntiHarassmentCommentLimits)
            }
            "SETTING_TYPE_ANTI_HARASSMENT_DANMU_LIMITS" => {
                Some(Self::SettingTypeAntiHarassmentDanmuLimits)
            }
            "SETTING_TYPE_UNFOLLOWED_MSG_RECEIVE" => {
                Some(Self::SettingTypeUnfollowedMsgReceive)
            }
            "SETTING_TYPE_ANTI_HARASSMENT_IM_LIMITS" => {
                Some(Self::SettingTypeAntiHarassmentImLimits)
            }
            "SETTING_TYPE_KEYWORD_BLOCKING" => Some(Self::SettingTypeKeywordBlocking),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LabelType {
    ///
    Default = 0,
    ///
    HuaHuo = 1,
    ///
    OriginalFans = 2,
    ///
    SpecialAttention = 3,
    ///
    ContractUp = 4,
    ///
    OldFans = 5,
    ///
    SpecialAttention2 = 6,
    ///
    FansMedal = 7,
    ///
    GuardMedal = 8,
}
impl LabelType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "LABEL_TYPE_DEFAULT",
            Self::HuaHuo => "LABEL_TYPE_HUA_HUO",
            Self::OriginalFans => "LABEL_TYPE_ORIGINAL_FANS",
            Self::SpecialAttention => "LABEL_TYPE_SPECIAL_ATTENTION",
            Self::ContractUp => "LABEL_TYPE_CONTRACT_UP",
            Self::OldFans => "LABEL_TYPE_OLD_FANS",
            Self::SpecialAttention2 => "LABEL_TYPE_SPECIAL_ATTENTION_2",
            Self::FansMedal => "LABEL_TYPE_FANS_MEDAL",
            Self::GuardMedal => "LABEL_TYPE_GUARD_MEDAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LABEL_TYPE_DEFAULT" => Some(Self::Default),
            "LABEL_TYPE_HUA_HUO" => Some(Self::HuaHuo),
            "LABEL_TYPE_ORIGINAL_FANS" => Some(Self::OriginalFans),
            "LABEL_TYPE_SPECIAL_ATTENTION" => Some(Self::SpecialAttention),
            "LABEL_TYPE_CONTRACT_UP" => Some(Self::ContractUp),
            "LABEL_TYPE_OLD_FANS" => Some(Self::OldFans),
            "LABEL_TYPE_SPECIAL_ATTENTION_2" => Some(Self::SpecialAttention2),
            "LABEL_TYPE_FANS_MEDAL" => Some(Self::FansMedal),
            "LABEL_TYPE_GUARD_MEDAL" => Some(Self::GuardMedal),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MsgSummaryPrefixType {
    ///
    None = 0,
    ///
    Notification = 1,
    ///
    GroupBlocked = 2,
    ///
    Mentioned = 3,
    ///
    Unread = 4,
}
impl MsgSummaryPrefixType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "MSG_SUMMARY_PREFIX_TYPE_NONE",
            Self::Notification => "MSG_SUMMARY_PREFIX_TYPE_NOTIFICATION",
            Self::GroupBlocked => "MSG_SUMMARY_PREFIX_TYPE_GROUP_BLOCKED",
            Self::Mentioned => "MSG_SUMMARY_PREFIX_TYPE_MENTIONED",
            Self::Unread => "MSG_SUMMARY_PREFIX_TYPE_UNREAD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MSG_SUMMARY_PREFIX_TYPE_NONE" => Some(Self::None),
            "MSG_SUMMARY_PREFIX_TYPE_NOTIFICATION" => Some(Self::Notification),
            "MSG_SUMMARY_PREFIX_TYPE_GROUP_BLOCKED" => Some(Self::GroupBlocked),
            "MSG_SUMMARY_PREFIX_TYPE_MENTIONED" => Some(Self::Mentioned),
            "MSG_SUMMARY_PREFIX_TYPE_UNREAD" => Some(Self::Unread),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QuickLinkItemType {
    ///
    Unknown = 0,
    ///
    OldLike = 1,
    ///
    OldReply = 2,
    ///
    At = 3,
    ///
    System = 4,
    ///
    HuaHuo = 5,
    ///
    Follow = 6,
    ///
    Reply = 100,
    ///
    Like = 101,
}
impl QuickLinkItemType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "QUICK_LINK_ITEM_TYPE_UNKNOWN",
            Self::OldLike => "QUICK_LINK_ITEM_TYPE_OLD_LIKE",
            Self::OldReply => "QUICK_LINK_ITEM_TYPE_OLD_REPLY",
            Self::At => "QUICK_LINK_ITEM_TYPE_AT",
            Self::System => "QUICK_LINK_ITEM_TYPE_SYSTEM",
            Self::HuaHuo => "QUICK_LINK_ITEM_TYPE_HUA_HUO",
            Self::Follow => "QUICK_LINK_ITEM_TYPE_FOLLOW",
            Self::Reply => "QUICK_LINK_ITEM_TYPE_REPLY",
            Self::Like => "QUICK_LINK_ITEM_TYPE_LIKE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QUICK_LINK_ITEM_TYPE_UNKNOWN" => Some(Self::Unknown),
            "QUICK_LINK_ITEM_TYPE_OLD_LIKE" => Some(Self::OldLike),
            "QUICK_LINK_ITEM_TYPE_OLD_REPLY" => Some(Self::OldReply),
            "QUICK_LINK_ITEM_TYPE_AT" => Some(Self::At),
            "QUICK_LINK_ITEM_TYPE_SYSTEM" => Some(Self::System),
            "QUICK_LINK_ITEM_TYPE_HUA_HUO" => Some(Self::HuaHuo),
            "QUICK_LINK_ITEM_TYPE_FOLLOW" => Some(Self::Follow),
            "QUICK_LINK_ITEM_TYPE_REPLY" => Some(Self::Reply),
            "QUICK_LINK_ITEM_TYPE_LIKE" => Some(Self::Like),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QuickLinkMsgType {
    ///
    LikeMsg = 0,
    ///
    ReplyMsg = 1,
    ///
    AtMsg = 2,
    ///
    DanmuMsg = 3,
    ///
    CoinMsg = 4,
    ///
    FavoriteMsg = 5,
}
impl QuickLinkMsgType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::LikeMsg => "LikeMsg",
            Self::ReplyMsg => "ReplyMsg",
            Self::AtMsg => "AtMsg",
            Self::DanmuMsg => "DanmuMsg",
            Self::CoinMsg => "CoinMsg",
            Self::FavoriteMsg => "FavoriteMsg",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LikeMsg" => Some(Self::LikeMsg),
            "ReplyMsg" => Some(Self::ReplyMsg),
            "AtMsg" => Some(Self::AtMsg),
            "DanmuMsg" => Some(Self::DanmuMsg),
            "CoinMsg" => Some(Self::CoinMsg),
            "FavoriteMsg" => Some(Self::FavoriteMsg),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SessionFilterType {
    ///
    FilterDefault = 0,
    ///
    FilterFollow = 1,
}
impl SessionFilterType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::FilterDefault => "FILTER_DEFAULT",
            Self::FilterFollow => "FILTER_FOLLOW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FILTER_DEFAULT" => Some(Self::FilterDefault),
            "FILTER_FOLLOW" => Some(Self::FilterFollow),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SessionPageType {
    ///
    Unknown = 0,
    ///
    Home = 1,
    ///
    Unfollowed = 2,
    ///
    Stranger = 3,
    ///
    Dustbin = 4,
    ///
    Group = 5,
    ///
    HuaHuo = 6,
    ///
    Ai = 7,
    ///
    Customer = 8,
}
impl SessionPageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "SESSION_PAGE_TYPE_UNKNOWN",
            Self::Home => "SESSION_PAGE_TYPE_HOME",
            Self::Unfollowed => "SESSION_PAGE_TYPE_UNFOLLOWED",
            Self::Stranger => "SESSION_PAGE_TYPE_STRANGER",
            Self::Dustbin => "SESSION_PAGE_TYPE_DUSTBIN",
            Self::Group => "SESSION_PAGE_TYPE_GROUP",
            Self::HuaHuo => "SESSION_PAGE_TYPE_HUA_HUO",
            Self::Ai => "SESSION_PAGE_TYPE_AI",
            Self::Customer => "SESSION_PAGE_TYPE_CUSTOMER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SESSION_PAGE_TYPE_UNKNOWN" => Some(Self::Unknown),
            "SESSION_PAGE_TYPE_HOME" => Some(Self::Home),
            "SESSION_PAGE_TYPE_UNFOLLOWED" => Some(Self::Unfollowed),
            "SESSION_PAGE_TYPE_STRANGER" => Some(Self::Stranger),
            "SESSION_PAGE_TYPE_DUSTBIN" => Some(Self::Dustbin),
            "SESSION_PAGE_TYPE_GROUP" => Some(Self::Group),
            "SESSION_PAGE_TYPE_HUA_HUO" => Some(Self::HuaHuo),
            "SESSION_PAGE_TYPE_AI" => Some(Self::Ai),
            "SESSION_PAGE_TYPE_CUSTOMER" => Some(Self::Customer),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SessionType {
    ///
    Unknown = 0,
    ///
    Private = 1,
    ///
    Group = 2,
    ///
    GroupFold = 3,
    ///
    Unfollowed = 4,
    ///
    Stranger = 5,
    ///
    Dustbin = 6,
    ///
    CustomerFold = 7,
    ///
    System = 8,
    ///
    AiFold = 9,
    ///
    CustomerAccount = 10,
}
impl SessionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "SESSION_TYPE_UNKNOWN",
            Self::Private => "SESSION_TYPE_PRIVATE",
            Self::Group => "SESSION_TYPE_GROUP",
            Self::GroupFold => "SESSION_TYPE_GROUP_FOLD",
            Self::Unfollowed => "SESSION_TYPE_UNFOLLOWED",
            Self::Stranger => "SESSION_TYPE_STRANGER",
            Self::Dustbin => "SESSION_TYPE_DUSTBIN",
            Self::CustomerFold => "SESSION_TYPE_CUSTOMER_FOLD",
            Self::System => "SESSION_TYPE_SYSTEM",
            Self::AiFold => "SESSION_TYPE_AI_FOLD",
            Self::CustomerAccount => "SESSION_TYPE_CUSTOMER_ACCOUNT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SESSION_TYPE_UNKNOWN" => Some(Self::Unknown),
            "SESSION_TYPE_PRIVATE" => Some(Self::Private),
            "SESSION_TYPE_GROUP" => Some(Self::Group),
            "SESSION_TYPE_GROUP_FOLD" => Some(Self::GroupFold),
            "SESSION_TYPE_UNFOLLOWED" => Some(Self::Unfollowed),
            "SESSION_TYPE_STRANGER" => Some(Self::Stranger),
            "SESSION_TYPE_DUSTBIN" => Some(Self::Dustbin),
            "SESSION_TYPE_CUSTOMER_FOLD" => Some(Self::CustomerFold),
            "SESSION_TYPE_SYSTEM" => Some(Self::System),
            "SESSION_TYPE_AI_FOLD" => Some(Self::AiFold),
            "SESSION_TYPE_CUSTOMER_ACCOUNT" => Some(Self::CustomerAccount),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ThreeDotItemType {
    ///
    Unknown = 0,
    ///
    ReadAll = 1,
    ///
    MsgSetting = 2,
    ///
    AutoReply = 3,
    ///
    UpHelper = 4,
    ///
    LiveHelper = 5,
    ///
    FansGroupHelper = 6,
    ///
    ContributionPush = 7,
    ///
    Contacts = 8,
    ///
    ClearList = 9,
}
impl ThreeDotItemType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "THREE_DOT_ITEM_TYPE_UNKNOWN",
            Self::ReadAll => "THREE_DOT_ITEM_TYPE_READ_ALL",
            Self::MsgSetting => "THREE_DOT_ITEM_TYPE_MSG_SETTING",
            Self::AutoReply => "THREE_DOT_ITEM_TYPE_AUTO_REPLY",
            Self::UpHelper => "THREE_DOT_ITEM_TYPE_UP_HELPER",
            Self::LiveHelper => "THREE_DOT_ITEM_TYPE_LIVE_HELPER",
            Self::FansGroupHelper => "THREE_DOT_ITEM_TYPE_FANS_GROUP_HELPER",
            Self::ContributionPush => "THREE_DOT_ITEM_TYPE_CONTRIBUTION_PUSH",
            Self::Contacts => "THREE_DOT_ITEM_TYPE_CONTACTS",
            Self::ClearList => "THREE_DOT_ITEM_TYPE_CLEAR_LIST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "THREE_DOT_ITEM_TYPE_UNKNOWN" => Some(Self::Unknown),
            "THREE_DOT_ITEM_TYPE_READ_ALL" => Some(Self::ReadAll),
            "THREE_DOT_ITEM_TYPE_MSG_SETTING" => Some(Self::MsgSetting),
            "THREE_DOT_ITEM_TYPE_AUTO_REPLY" => Some(Self::AutoReply),
            "THREE_DOT_ITEM_TYPE_UP_HELPER" => Some(Self::UpHelper),
            "THREE_DOT_ITEM_TYPE_LIVE_HELPER" => Some(Self::LiveHelper),
            "THREE_DOT_ITEM_TYPE_FANS_GROUP_HELPER" => Some(Self::FansGroupHelper),
            "THREE_DOT_ITEM_TYPE_CONTRIBUTION_PUSH" => Some(Self::ContributionPush),
            "THREE_DOT_ITEM_TYPE_CONTACTS" => Some(Self::Contacts),
            "THREE_DOT_ITEM_TYPE_CLEAR_LIST" => Some(Self::ClearList),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UnreadStyle {
    ///
    None = 0,
    ///
    Dot = 1,
    ///
    Number = 2,
}
impl UnreadStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "UNREAD_STYLE_NONE",
            Self::Dot => "UNREAD_STYLE_DOT",
            Self::Number => "UNREAD_STYLE_NUMBER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNREAD_STYLE_NONE" => Some(Self::None),
            "UNREAD_STYLE_DOT" => Some(Self::Dot),
            "UNREAD_STYLE_NUMBER" => Some(Self::Number),
            _ => None,
        }
    }
}
