// This file is @generated by prost-build.
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Activity {
    ///
    #[prost(int64, tag = "1")]
    pub activity_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub activity_state: i64,
    ///
    #[prost(string, tag = "3")]
    pub activity_placeholder: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnswerQuestionReq {
    ///
    #[prost(int64, tag = "1")]
    pub qid: i64,
    ///
    #[prost(string, tag = "2")]
    pub option_key: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnswerQuestionResp {
    ///
    #[prost(bool, tag = "1")]
    pub passed: bool,
    ///
    #[prost(bool, tag = "2")]
    pub member_passed: bool,
    ///
    #[prost(message, optional, tag = "3")]
    pub member_passed_popup: ::core::option::Option<
        answer_question_resp::MemberPassedPopup,
    >,
    ///
    #[prost(string, tag = "4")]
    pub bottom_text: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub stat: ::core::option::Option<QuestionCardStat>,
}
/// Nested message and enum types in `AnswerQuestionResp`.
pub mod answer_question_resp {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MemberPassedPopup {
        ///
        #[prost(string, tag = "1")]
        pub title: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "2")]
        pub subtitle: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "3")]
        pub h5_link: ::prost::alloc::string::String,
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArticleSearchItem {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub up_nickname: ::prost::alloc::string::String,
    ///
    #[prost(string, repeated, tag = "3")]
    pub covers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AtGroup {
    ///
    #[prost(enumeration = "at_group::Type", tag = "1")]
    pub group_type: i32,
    ///
    #[prost(string, tag = "2")]
    pub group_name: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub items: ::prost::alloc::vec::Vec<AtItem>,
}
/// Nested message and enum types in `AtGroup`.
pub mod at_group {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        ///
        AtGroupTypeDefault = 0,
        ///
        AtGroupTypeRecent = 1,
        ///
        AtGroupTypeFollow = 2,
        ///
        AtGroupTypeFans = 3,
        ///
        AtGroupTypeOthers = 4,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::AtGroupTypeDefault => "AT_GROUP_TYPE_DEFAULT",
                Self::AtGroupTypeRecent => "AT_GROUP_TYPE_RECENT",
                Self::AtGroupTypeFollow => "AT_GROUP_TYPE_FOLLOW",
                Self::AtGroupTypeFans => "AT_GROUP_TYPE_FANS",
                Self::AtGroupTypeOthers => "AT_GROUP_TYPE_OTHERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AT_GROUP_TYPE_DEFAULT" => Some(Self::AtGroupTypeDefault),
                "AT_GROUP_TYPE_RECENT" => Some(Self::AtGroupTypeRecent),
                "AT_GROUP_TYPE_FOLLOW" => Some(Self::AtGroupTypeFollow),
                "AT_GROUP_TYPE_FANS" => Some(Self::AtGroupTypeFans),
                "AT_GROUP_TYPE_OTHERS" => Some(Self::AtGroupTypeOthers),
                _ => None,
            }
        }
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AtItem {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "4")]
    pub fans: i32,
    ///
    #[prost(int32, tag = "5")]
    pub official_verify_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AtSearchReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub groups: ::prost::alloc::vec::Vec<AtGroup>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AtSearchReq {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub keyword: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cm {
    ///
    #[prost(message, optional, tag = "1")]
    pub source_content: ::core::option::Option<::prost_types::Any>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Content {
    ///
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    ///
    #[prost(map = "string, message", tag = "2")]
    pub members: ::std::collections::HashMap<::prost::alloc::string::String, Member>,
    ///
    #[prost(map = "string, message", tag = "3")]
    pub emotes: ::std::collections::HashMap<::prost::alloc::string::String, Emote>,
    ///
    #[prost(map = "string, message", tag = "4")]
    pub topics: ::std::collections::HashMap<::prost::alloc::string::String, Topic>,
    ///
    #[prost(map = "string, message", tag = "5")]
    pub urls: ::std::collections::HashMap<::prost::alloc::string::String, Url>,
    ///
    #[prost(message, optional, tag = "6")]
    pub vote: ::core::option::Option<Vote>,
    ///
    #[prost(map = "string, int64", tag = "7")]
    pub at_name_to_mid: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
    ///
    #[prost(message, optional, tag = "8")]
    pub rich_text: ::core::option::Option<RichText>,
    ///
    #[prost(message, repeated, tag = "9")]
    pub pictures: ::prost::alloc::vec::Vec<Picture>,
    ///
    #[prost(double, tag = "10")]
    pub picture_scale: f64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CursorReply {
    ///
    #[prost(int64, tag = "1")]
    pub next: i64,
    ///
    #[prost(int64, tag = "2")]
    pub prev: i64,
    ///
    #[prost(bool, tag = "3")]
    pub is_begin: bool,
    ///
    #[prost(bool, tag = "4")]
    pub is_end: bool,
    ///
    #[prost(enumeration = "Mode", tag = "5")]
    pub mode: i32,
    ///
    #[prost(string, tag = "6")]
    pub mode_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CursorReq {
    ///
    #[prost(int64, tag = "1")]
    pub next: i64,
    ///
    #[prost(int64, tag = "2")]
    pub prev: i64,
    ///
    #[prost(enumeration = "Mode", tag = "4")]
    pub mode: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetailListReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub cursor: ::core::option::Option<CursorReply>,
    ///
    #[prost(message, optional, tag = "2")]
    pub subject_control: ::core::option::Option<SubjectControl>,
    ///
    #[prost(message, optional, tag = "3")]
    pub root: ::core::option::Option<ReplyInfo>,
    ///
    #[prost(message, optional, tag = "4")]
    pub activity: ::core::option::Option<Activity>,
    ///
    #[prost(message, optional, tag = "5")]
    pub likes: ::core::option::Option<LikeInfo>,
    ///
    #[prost(enumeration = "Mode", tag = "6")]
    pub mode: i32,
    ///
    #[prost(string, tag = "7")]
    pub mode_text: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "8")]
    pub pagination_reply: ::core::option::Option<
        super::super::super::super::pagination::FeedPaginationReply,
    >,
    ///
    #[prost(string, tag = "9")]
    pub session_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetailListReq {
    ///
    #[prost(int64, tag = "1")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub r#type: i64,
    ///
    #[prost(int64, tag = "3")]
    pub root: i64,
    ///
    #[prost(int64, tag = "4")]
    pub rpid: i64,
    ///
    #[prost(message, optional, tag = "5")]
    pub cursor: ::core::option::Option<CursorReq>,
    ///
    #[prost(enumeration = "DetailListScene", tag = "6")]
    pub scene: i32,
    ///
    #[prost(enumeration = "Mode", tag = "7")]
    pub mode: i32,
    ///
    #[prost(message, optional, tag = "8")]
    pub pagination: ::core::option::Option<
        super::super::super::super::pagination::FeedPagination,
    >,
    ///
    #[prost(string, tag = "9")]
    pub extra: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DialogListReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub cursor: ::core::option::Option<CursorReply>,
    ///
    #[prost(message, optional, tag = "2")]
    pub subject_control: ::core::option::Option<SubjectControl>,
    ///
    #[prost(message, repeated, tag = "3")]
    pub replies: ::prost::alloc::vec::Vec<ReplyInfo>,
    ///
    #[prost(message, optional, tag = "4")]
    pub activity: ::core::option::Option<Activity>,
    ///
    #[prost(message, optional, tag = "5")]
    pub pagination_reply: ::core::option::Option<
        super::super::super::super::pagination::FeedPaginationReply,
    >,
    ///
    #[prost(string, tag = "6")]
    pub session_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DialogListReq {
    ///
    #[prost(int64, tag = "1")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub r#type: i64,
    ///
    #[prost(int64, tag = "3")]
    pub root: i64,
    ///
    #[prost(int64, tag = "4")]
    pub dialog: i64,
    ///
    #[prost(message, optional, tag = "5")]
    pub cursor: ::core::option::Option<CursorReq>,
    ///
    #[prost(message, optional, tag = "6")]
    pub pagination: ::core::option::Option<
        super::super::super::super::pagination::FeedPagination,
    >,
    ///
    #[prost(string, tag = "7")]
    pub extra: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DoVoteReq {
    ///
    #[prost(int64, tag = "1")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub r#type: i64,
    ///
    #[prost(int64, tag = "3")]
    pub vote_id: i64,
    ///
    #[prost(int64, tag = "4")]
    pub option: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DoVoteResp {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ESportsGradeCard {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub image: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub link: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Effects {
    ///
    #[prost(string, tag = "1")]
    pub preloading: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Emote {
    ///
    #[prost(int64, tag = "1")]
    pub size: i64,
    ///
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub jump_title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "5")]
    pub id: i64,
    ///
    #[prost(int64, tag = "6")]
    pub package_id: i64,
    ///
    #[prost(string, tag = "7")]
    pub gif_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub webp_url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmptyPage {
    ///
    #[prost(string, tag = "1")]
    pub image_url: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub texts: ::prost::alloc::vec::Vec<empty_page::Text>,
    ///
    #[prost(message, optional, tag = "3")]
    pub left_button: ::core::option::Option<empty_page::Button>,
    ///
    #[prost(message, optional, tag = "4")]
    pub right_button: ::core::option::Option<empty_page::Button>,
}
/// Nested message and enum types in `EmptyPage`.
pub mod empty_page {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Button {
        ///
        #[prost(string, tag = "1")]
        pub title: ::prost::alloc::string::String,
        ///
        #[prost(enumeration = "Action", tag = "2")]
        pub action: i32,
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Text {
        ///
        #[prost(string, tag = "1")]
        pub raw: ::prost::alloc::string::String,
        ///
        #[prost(message, optional, tag = "2")]
        pub style: ::core::option::Option<super::TextStyle>,
        ///
        #[prost(enumeration = "Action", tag = "3")]
        pub action: i32,
    }
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        ///
        Unavailable = 0,
        ///
        ShowKeyboard = 1,
        ///
        SendReplyWithBoldText = 2,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unavailable => "UNAVAILABLE",
                Self::ShowKeyboard => "SHOW_KEYBOARD",
                Self::SendReplyWithBoldText => "SEND_REPLY_WITH_BOLD_TEXT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNAVAILABLE" => Some(Self::Unavailable),
                "SHOW_KEYBOARD" => Some(Self::ShowKeyboard),
                "SEND_REPLY_WITH_BOLD_TEXT" => Some(Self::SendReplyWithBoldText),
                _ => None,
            }
        }
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Form {
    ///
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    ///
    #[prost(message, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<QoeOption>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoodsSearchItem {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub price: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub income: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub img: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub label: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LikeInfo {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<like_info::Item>,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
}
/// Nested message and enum types in `LikeInfo`.
pub mod like_info {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Item {
        ///
        #[prost(message, optional, tag = "1")]
        pub member: ::core::option::Option<super::Member>,
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Lottery {
    ///
    #[prost(int64, tag = "1")]
    pub lottery_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub lottery_status: i64,
    ///
    #[prost(int64, tag = "3")]
    pub lottery_mid: i64,
    ///
    #[prost(int64, tag = "4")]
    pub lottery_time: i64,
    ///
    #[prost(int64, tag = "5")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "6")]
    pub r#type: i64,
    ///
    #[prost(int64, tag = "7")]
    pub ctime: i64,
    ///
    #[prost(message, optional, tag = "8")]
    pub content: ::core::option::Option<Content>,
    ///
    #[prost(message, optional, tag = "9")]
    pub member: ::core::option::Option<Member>,
    ///
    #[prost(message, optional, tag = "10")]
    pub reply_control: ::core::option::Option<ReplyControl>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MainListReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub cursor: ::core::option::Option<CursorReply>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub replies: ::prost::alloc::vec::Vec<ReplyInfo>,
    ///
    #[prost(message, optional, tag = "3")]
    pub subject_control: ::core::option::Option<SubjectControl>,
    ///
    #[prost(message, optional, tag = "4")]
    pub up_top: ::core::option::Option<ReplyInfo>,
    ///
    #[prost(message, optional, tag = "5")]
    pub admin_top: ::core::option::Option<ReplyInfo>,
    ///
    #[prost(message, optional, tag = "6")]
    pub vote_top: ::core::option::Option<ReplyInfo>,
    ///
    #[prost(message, optional, tag = "7")]
    pub notice: ::core::option::Option<Notice>,
    ///
    #[prost(message, optional, tag = "8")]
    pub lottery: ::core::option::Option<Lottery>,
    ///
    #[prost(message, optional, tag = "9")]
    pub activity: ::core::option::Option<Activity>,
    ///
    #[prost(message, optional, tag = "10")]
    pub up_selection: ::core::option::Option<UpSelection>,
    ///
    #[prost(message, optional, tag = "11")]
    pub cm: ::core::option::Option<Cm>,
    ///
    #[prost(message, optional, tag = "12")]
    pub effects: ::core::option::Option<Effects>,
    ///
    #[prost(message, optional, tag = "13")]
    pub operation: ::core::option::Option<Operation>,
    ///
    #[prost(message, repeated, tag = "14")]
    pub top_replies: ::prost::alloc::vec::Vec<ReplyInfo>,
    ///
    #[prost(message, optional, tag = "15")]
    pub qoe: ::core::option::Option<QoeInfo>,
    ///
    #[prost(map = "string, int32", tag = "16")]
    pub callbacks: ::std::collections::HashMap<::prost::alloc::string::String, i32>,
    ///
    #[prost(message, optional, tag = "17")]
    pub operation_v2: ::core::option::Option<OperationV2>,
    ///
    #[prost(enumeration = "Mode", tag = "18")]
    pub mode: i32,
    ///
    #[prost(string, tag = "19")]
    pub mode_text: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "20")]
    pub pagination_reply: ::core::option::Option<
        super::super::super::super::pagination::FeedPaginationReply,
    >,
    ///
    #[prost(string, tag = "21")]
    pub session_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "22")]
    pub report_params: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "23")]
    pub vote_card: ::core::option::Option<VoteCard>,
    ///
    #[prost(message, optional, tag = "24")]
    pub esports_grade_card: ::core::option::Option<ESportsGradeCard>,
    ///
    #[prost(string, tag = "25")]
    pub context_feature: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "26")]
    pub pagination_end_text: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "27")]
    pub mixed_cards: ::prost::alloc::vec::Vec<MixedCard>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MainListReq {
    ///
    #[prost(int64, tag = "1")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub r#type: i64,
    ///
    #[prost(message, optional, tag = "3")]
    pub cursor: ::core::option::Option<CursorReq>,
    ///
    #[prost(string, tag = "4")]
    pub extra: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub ad_extra: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "6")]
    pub rpid: i64,
    ///
    #[prost(int64, tag = "7")]
    pub seek_rpid: i64,
    ///
    #[prost(string, tag = "8")]
    pub filter_tag_name: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "Mode", tag = "9")]
    pub mode: i32,
    ///
    #[prost(message, optional, tag = "10")]
    pub pagination: ::core::option::Option<
        super::super::super::super::pagination::FeedPagination,
    >,
    ///
    #[prost(int64, repeated, tag = "11")]
    pub client_recall_rpids: ::prost::alloc::vec::Vec<i64>,
    ///
    #[prost(message, optional, tag = "12")]
    pub word_search_param: ::core::option::Option<WordSearchParam>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Member {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub sex: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "5")]
    pub level: i64,
    ///
    #[prost(int64, tag = "6")]
    pub official_verify_type: i64,
    ///
    #[prost(int64, tag = "7")]
    pub vip_type: i64,
    ///
    #[prost(int64, tag = "8")]
    pub vip_status: i64,
    ///
    #[prost(int64, tag = "9")]
    pub vip_theme_type: i64,
    ///
    #[prost(string, tag = "10")]
    pub vip_label_path: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub garb_pendant_image: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "12")]
    pub garb_card_image: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "13")]
    pub garb_card_image_with_focus: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "14")]
    pub garb_card_jump_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "15")]
    pub garb_card_number: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "16")]
    pub garb_card_fan_color: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "17")]
    pub garb_card_is_fan: bool,
    ///
    #[prost(string, tag = "18")]
    pub fans_medal_name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "19")]
    pub fans_medal_level: i64,
    ///
    #[prost(int64, tag = "20")]
    pub fans_medal_color: i64,
    ///
    #[prost(string, tag = "21")]
    pub vip_nickname_color: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "22")]
    pub vip_avatar_subscript: i32,
    ///
    #[prost(string, tag = "23")]
    pub vip_label_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "24")]
    pub vip_label_theme: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "25")]
    pub fans_medal_color_end: i64,
    ///
    #[prost(int64, tag = "26")]
    pub fans_medal_color_border: i64,
    ///
    #[prost(int64, tag = "27")]
    pub fans_medal_color_name: i64,
    ///
    #[prost(int64, tag = "28")]
    pub fans_medal_color_level: i64,
    ///
    #[prost(int64, tag = "29")]
    pub fans_guard_level: i64,
    ///
    #[prost(int32, tag = "30")]
    pub face_nft: i32,
    ///
    #[prost(int32, tag = "31")]
    pub face_nft_new: i32,
    ///
    #[prost(int32, tag = "32")]
    pub is_senior_member: i32,
    ///
    #[prost(message, optional, tag = "33")]
    pub nft_interaction: ::core::option::Option<member::NftInteraction>,
    ///
    #[prost(string, tag = "34")]
    pub fans_guard_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "35")]
    pub fans_honor_icon: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Member`.
pub mod member {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NftInteraction {
        ///
        #[prost(string, tag = "1")]
        pub itype: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "2")]
        pub metadata_url: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "3")]
        pub nft_id: ::prost::alloc::string::String,
        ///
        #[prost(message, optional, tag = "4")]
        pub region: ::core::option::Option<nft_interaction::Region>,
    }
    /// Nested message and enum types in `NftInteraction`.
    pub mod nft_interaction {
        ///
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Region {
            ///
            #[prost(enumeration = "RegionType", tag = "1")]
            pub r#type: i32,
            ///
            #[prost(string, tag = "2")]
            pub icon: ::prost::alloc::string::String,
            ///
            #[prost(enumeration = "ShowStatus", tag = "3")]
            pub show_status: i32,
        }
        ///
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum RegionType {
            ///
            Default = 0,
            ///
            Mainland = 1,
            ///
            Gat = 2,
        }
        impl RegionType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Default => "DEFAULT",
                    Self::Mainland => "MAINLAND",
                    Self::Gat => "GAT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DEFAULT" => Some(Self::Default),
                    "MAINLAND" => Some(Self::Mainland),
                    "GAT" => Some(Self::Gat),
                    _ => None,
                }
            }
        }
        ///
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ShowStatus {
            ///
            Showdefault = 0,
            ///
            Zoominmainland = 1,
            ///
            Raw = 2,
        }
        impl ShowStatus {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Showdefault => "SHOWDEFAULT",
                    Self::Zoominmainland => "ZOOMINMAINLAND",
                    Self::Raw => "RAW",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SHOWDEFAULT" => Some(Self::Showdefault),
                    "ZOOMINMAINLAND" => Some(Self::Zoominmainland),
                    "RAW" => Some(Self::Raw),
                    _ => None,
                }
            }
        }
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemberV2 {
    ///
    #[prost(message, optional, tag = "1")]
    pub basic: ::core::option::Option<member_v2::Basic>,
    ///
    #[prost(message, optional, tag = "2")]
    pub official: ::core::option::Option<member_v2::Official>,
    ///
    #[prost(message, optional, tag = "3")]
    pub vip: ::core::option::Option<member_v2::Vip>,
    ///
    #[prost(message, optional, tag = "4")]
    pub garb: ::core::option::Option<member_v2::Garb>,
    ///
    #[prost(message, optional, tag = "5")]
    pub medal: ::core::option::Option<member_v2::Medal>,
    ///
    #[prost(message, optional, tag = "6")]
    pub nft: ::core::option::Option<member_v2::Nft>,
    ///
    #[prost(message, optional, tag = "7")]
    pub senior: ::core::option::Option<member_v2::Senior>,
    ///
    #[prost(message, optional, tag = "8")]
    pub contractor: ::core::option::Option<member_v2::Contractor>,
    ///
    #[prost(message, optional, tag = "9")]
    pub user_sailing: ::core::option::Option<
        super::super::super::super::vas::garb::model::UserSailing,
    >,
}
/// Nested message and enum types in `MemberV2`.
pub mod member_v2 {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Basic {
        ///
        #[prost(int64, tag = "1")]
        pub mid: i64,
        ///
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "3")]
        pub sex: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "4")]
        pub face: ::prost::alloc::string::String,
        ///
        #[prost(int64, tag = "5")]
        pub level: i64,
        ///
        #[prost(message, optional, tag = "6")]
        pub avatar_item: ::core::option::Option<
            super::super::super::super::super::dagw::component::avatar::v1::AvatarItem,
        >,
        ///
        #[prost(message, optional, tag = "7")]
        pub name_render: ::core::option::Option<
            super::super::super::super::super::account::service::v1::NameRender,
        >,
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Contractor {
        ///
        #[prost(bool, tag = "1")]
        pub is_contractor: bool,
        ///
        #[prost(string, tag = "2")]
        pub contract_desc: ::prost::alloc::string::String,
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Garb {
        ///
        #[prost(string, tag = "1")]
        pub pendant_image: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "2")]
        pub card_image: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "3")]
        pub card_image_with_focus: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "4")]
        pub card_jump_url: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "5")]
        pub card_number: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "6")]
        pub card_fan_color: ::prost::alloc::string::String,
        ///
        #[prost(bool, tag = "7")]
        pub card_is_fan: bool,
        ///
        #[prost(string, tag = "8")]
        pub fan_num_prefix: ::prost::alloc::string::String,
        ///
        #[prost(message, optional, tag = "9")]
        pub fan_num_color_format: ::core::option::Option<garb::FanNumColorFormat>,
    }
    /// Nested message and enum types in `Garb`.
    pub mod garb {
        ///
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FanNumColorFormat {
            ///
            #[prost(string, tag = "1")]
            pub start_point: ::prost::alloc::string::String,
            ///
            #[prost(string, tag = "2")]
            pub end_point: ::prost::alloc::string::String,
            ///
            #[prost(string, repeated, tag = "3")]
            pub colors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            ///
            #[prost(int64, repeated, tag = "4")]
            pub gradients: ::prost::alloc::vec::Vec<i64>,
        }
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Medal {
        ///
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        ///
        #[prost(int64, tag = "2")]
        pub level: i64,
        ///
        #[prost(int64, tag = "3")]
        pub color_start: i64,
        ///
        #[prost(int64, tag = "4")]
        pub color_end: i64,
        ///
        #[prost(int64, tag = "5")]
        pub color_border: i64,
        ///
        #[prost(int64, tag = "6")]
        pub color_name: i64,
        ///
        #[prost(int64, tag = "7")]
        pub color_level: i64,
        ///
        #[prost(int64, tag = "8")]
        pub guard_level: i64,
        ///
        #[prost(string, tag = "9")]
        pub first_icon: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "10")]
        pub second_icon: ::prost::alloc::string::String,
        ///
        #[prost(int64, tag = "11")]
        pub level_bg_color: i64,
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Nft {
        ///
        #[prost(int32, tag = "1")]
        pub face: i32,
        ///
        #[prost(message, optional, tag = "2")]
        pub interaction: ::core::option::Option<nft::Interaction>,
    }
    /// Nested message and enum types in `Nft`.
    pub mod nft {
        ///
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Interaction {
            ///
            #[prost(string, tag = "1")]
            pub itype: ::prost::alloc::string::String,
            ///
            #[prost(string, tag = "2")]
            pub metadata_url: ::prost::alloc::string::String,
            ///
            #[prost(string, tag = "3")]
            pub nft_id: ::prost::alloc::string::String,
            ///
            #[prost(message, optional, tag = "4")]
            pub region: ::core::option::Option<interaction::Region>,
        }
        /// Nested message and enum types in `Interaction`.
        pub mod interaction {
            ///
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Region {
                ///
                #[prost(enumeration = "RegionType", tag = "1")]
                pub r#type: i32,
                ///
                #[prost(string, tag = "2")]
                pub icon: ::prost::alloc::string::String,
                ///
                #[prost(enumeration = "ShowStatus", tag = "3")]
                pub show_status: i32,
            }
            ///
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum RegionType {
                ///
                DefaultRegionType = 0,
                ///
                MainlandRegionType = 1,
                ///
                GatRegionType = 2,
            }
            impl RegionType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::DefaultRegionType => "DEFAULT_RegionType",
                        Self::MainlandRegionType => "MAINLAND_RegionType",
                        Self::GatRegionType => "GAT_RegionType",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "DEFAULT_RegionType" => Some(Self::DefaultRegionType),
                        "MAINLAND_RegionType" => Some(Self::MainlandRegionType),
                        "GAT_RegionType" => Some(Self::GatRegionType),
                        _ => None,
                    }
                }
            }
            ///
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum ShowStatus {
                ///
                ShowdefaultShowStatus = 0,
                ///
                ZoominmainlandShowStatus = 1,
                ///
                RawShowStatus = 2,
            }
            impl ShowStatus {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::ShowdefaultShowStatus => "SHOWDEFAULT_ShowStatus",
                        Self::ZoominmainlandShowStatus => "ZOOMINMAINLAND_ShowStatus",
                        Self::RawShowStatus => "RAW_ShowStatus",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "SHOWDEFAULT_ShowStatus" => Some(Self::ShowdefaultShowStatus),
                        "ZOOMINMAINLAND_ShowStatus" => {
                            Some(Self::ZoominmainlandShowStatus)
                        }
                        "RAW_ShowStatus" => Some(Self::RawShowStatus),
                        _ => None,
                    }
                }
            }
        }
    }
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Official {
        ///
        #[prost(int64, tag = "1")]
        pub verify_type: i64,
    }
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Senior {
        ///
        #[prost(int32, tag = "1")]
        pub is_senior_member: i32,
        ///
        #[prost(enumeration = "senior::Status", tag = "2")]
        pub status: i32,
    }
    /// Nested message and enum types in `Senior`.
    pub mod senior {
        ///
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Status {
            ///
            Normal = 0,
            ///
            Pending = 1,
            ///
            Senior = 2,
            ///
            WillExpire = 3,
            ///
            Expired = 4,
        }
        impl Status {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Normal => "Normal",
                    Self::Pending => "Pending",
                    Self::Senior => "Senior",
                    Self::WillExpire => "WillExpire",
                    Self::Expired => "Expired",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "Normal" => Some(Self::Normal),
                    "Pending" => Some(Self::Pending),
                    "Senior" => Some(Self::Senior),
                    "WillExpire" => Some(Self::WillExpire),
                    "Expired" => Some(Self::Expired),
                    _ => None,
                }
            }
        }
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Vip {
        ///
        #[prost(int64, tag = "1")]
        pub r#type: i64,
        ///
        #[prost(int64, tag = "2")]
        pub status: i64,
        ///
        #[prost(int64, tag = "3")]
        pub theme_type: i64,
        ///
        #[prost(string, tag = "4")]
        pub label_path: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "5")]
        pub nickname_color: ::prost::alloc::string::String,
        ///
        #[prost(int32, tag = "6")]
        pub avatar_subscript: i32,
        ///
        #[prost(string, tag = "7")]
        pub label_text: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "8")]
        pub vip_label_theme: ::prost::alloc::string::String,
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MixedCard {
    ///
    #[prost(enumeration = "mixed_card::Type", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "2")]
    pub oid: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub display_rank: i64,
    ///
    #[prost(oneof = "mixed_card::Item", tags = "4")]
    pub item: ::core::option::Option<mixed_card::Item>,
}
/// Nested message and enum types in `MixedCard`.
pub mod mixed_card {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        ///
        Unknown = 0,
        ///
        Question = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Question => "QUESTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "QUESTION" => Some(Self::Question),
                _ => None,
            }
        }
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Item {
        ///
        #[prost(message, tag = "4")]
        Question(super::QuestionCard),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Notice {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub link: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Operation {
    ///
    #[prost(enumeration = "operation::Type", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(int64, tag = "2")]
    pub id: i64,
    ///
    #[prost(message, optional, tag = "3")]
    pub title: ::core::option::Option<OperationTitle>,
    ///
    #[prost(message, optional, tag = "4")]
    pub subtitle: ::core::option::Option<OperationTitle>,
    ///
    #[prost(string, tag = "5")]
    pub link: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub report_extra: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub icon: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Operation`.
pub mod operation {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        ///
        UnknownType = 0,
        ///
        Note = 1,
        ///
        Topic = 2,
        /// @Deprecated
        Notice = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownType => "UNKNOWN_Type",
                Self::Note => "NOTE",
                Self::Topic => "TOPIC",
                Self::Notice => "NOTICE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_Type" => Some(Self::UnknownType),
                "NOTE" => Some(Self::Note),
                "TOPIC" => Some(Self::Topic),
                "NOTICE" => Some(Self::Notice),
                _ => None,
            }
        }
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationTitle {
    ///
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "2")]
    pub is_highlight: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationV2 {
    ///
    #[prost(enumeration = "operation_v2::Type", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "2")]
    pub prefix_text: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub icon: ::core::option::Option<operation_v2::Icon>,
    ///
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub link: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub report_extra: ::prost::alloc::string::String,
}
/// Nested message and enum types in `OperationV2`.
pub mod operation_v2 {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Icon {
        ///
        #[prost(enumeration = "icon::Position", tag = "1")]
        pub position: i32,
        ///
        #[prost(string, tag = "2")]
        pub url: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `Icon`.
    pub mod icon {
        ///
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Position {
            ///
            Prefix = 0,
            ///
            Suffix = 1,
        }
        impl Position {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Prefix => "PREFIX",
                    Self::Suffix => "SUFFIX",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PREFIX" => Some(Self::Prefix),
                    "SUFFIX" => Some(Self::Suffix),
                    _ => None,
                }
            }
        }
    }
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        ///
        UnknownType = 0,
        ///
        NoteType = 1,
        ///
        TopicType = 2,
        ///
        Search = 4,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownType => "UNKNOWN_Type",
                Self::NoteType => "NOTE_Type",
                Self::TopicType => "TOPIC_Type",
                Self::Search => "SEARCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_Type" => Some(Self::UnknownType),
                "NOTE_Type" => Some(Self::NoteType),
                "TOPIC_Type" => Some(Self::TopicType),
                "SEARCH" => Some(Self::Search),
                _ => None,
            }
        }
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PgcVideoSearchItem {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub category: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cover: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Picture {
    ///
    #[prost(string, tag = "1")]
    pub img_src: ::prost::alloc::string::String,
    ///
    #[prost(double, tag = "2")]
    pub img_width: f64,
    ///
    #[prost(double, tag = "3")]
    pub img_height: f64,
    ///
    #[prost(double, tag = "4")]
    pub img_size: f64,
    ///
    #[prost(string, tag = "5")]
    pub top_right_icon: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "6")]
    pub play_gif_thumbnail: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreviewListReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub cursor: ::core::option::Option<CursorReply>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub replies: ::prost::alloc::vec::Vec<ReplyInfo>,
    ///
    #[prost(message, optional, tag = "3")]
    pub subject_control: ::core::option::Option<SubjectControl>,
    ///
    #[prost(message, optional, tag = "4")]
    pub up_top: ::core::option::Option<ReplyInfo>,
    ///
    #[prost(message, optional, tag = "5")]
    pub admin_top: ::core::option::Option<ReplyInfo>,
    ///
    #[prost(message, optional, tag = "6")]
    pub vote_top: ::core::option::Option<ReplyInfo>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PreviewListReq {
    ///
    #[prost(int64, tag = "1")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub r#type: i64,
    ///
    #[prost(message, optional, tag = "3")]
    pub cursor: ::core::option::Option<CursorReq>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QoeInfo {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(int32, tag = "2")]
    pub r#type: i32,
    ///
    #[prost(int32, tag = "3")]
    pub style: i32,
    ///
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub feedback_title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "6")]
    pub score_items: ::prost::alloc::vec::Vec<QoeScoreItem>,
    ///
    #[prost(int64, tag = "7")]
    pub display_rank: i64,
    ///
    #[prost(message, optional, tag = "8")]
    pub form: ::core::option::Option<Form>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QoeOption {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(float, tag = "2")]
    pub score: f32,
    ///
    #[prost(string, tag = "3")]
    pub img_url: ::prost::alloc::string::String,
    ///
    #[prost(string, repeated, tag = "4")]
    pub desc: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QoeOptionDesc {
    ///
    #[prost(string, repeated, tag = "1")]
    pub desc: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QoeScoreItem {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(float, tag = "3")]
    pub score: f32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestionCard {
    ///
    #[prost(message, optional, tag = "1")]
    pub question: ::core::option::Option<question_card::Question>,
    ///
    #[prost(message, optional, tag = "2")]
    pub stat: ::core::option::Option<QuestionCardStat>,
    ///
    #[prost(string, tag = "3")]
    pub bottom_text: ::prost::alloc::string::String,
}
/// Nested message and enum types in `QuestionCard`.
pub mod question_card {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Option {
        ///
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "2")]
        pub title: ::prost::alloc::string::String,
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Question {
        ///
        #[prost(int64, tag = "1")]
        pub qid: i64,
        ///
        #[prost(string, tag = "2")]
        pub title: ::prost::alloc::string::String,
        ///
        #[prost(bool, tag = "3")]
        pub must_right: bool,
        ///
        #[prost(message, repeated, tag = "4")]
        pub options: ::prost::alloc::vec::Vec<Option>,
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuestionCardStat {
    ///
    #[prost(int64, tag = "1")]
    pub right_cnt: i64,
    ///
    #[prost(int64, tag = "2")]
    pub right_mid_cnt: i64,
    ///
    #[prost(int64, tag = "3")]
    pub submit_mid_cnt: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplyCardLabel {
    ///
    #[prost(string, tag = "1")]
    pub text_content: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text_color_day: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub label_color_day: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub label_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub image: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "reply_card_label::Type", tag = "7")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "8")]
    pub background: ::prost::alloc::string::String,
    ///
    #[prost(double, tag = "9")]
    pub background_width: f64,
    ///
    #[prost(double, tag = "10")]
    pub background_height: f64,
    ///
    #[prost(string, tag = "11")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "12")]
    pub effect: i64,
    ///
    #[prost(int64, tag = "13")]
    pub effect_start_time: i64,
}
/// Nested message and enum types in `ReplyCardLabel`.
pub mod reply_card_label {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        ///
        Underline = 0,
        ///
        Background = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Underline => "UNDERLINE",
                Self::Background => "BACKGROUND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDERLINE" => Some(Self::Underline),
                "BACKGROUND" => Some(Self::Background),
                _ => None,
            }
        }
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplyControl {
    ///
    #[prost(int64, tag = "1")]
    pub action: i64,
    ///
    #[prost(bool, tag = "2")]
    pub up_like: bool,
    ///
    #[prost(bool, tag = "3")]
    pub up_reply: bool,
    ///
    #[prost(bool, tag = "4")]
    pub show_follow_btn: bool,
    ///
    #[prost(bool, tag = "5")]
    pub is_assist: bool,
    ///
    #[prost(string, tag = "6")]
    pub label_text: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "7")]
    pub following: bool,
    ///
    #[prost(bool, tag = "8")]
    pub followed: bool,
    ///
    #[prost(bool, tag = "9")]
    pub blocked: bool,
    ///
    #[prost(bool, tag = "10")]
    pub has_folded_reply: bool,
    ///
    #[prost(bool, tag = "11")]
    pub is_folded_reply: bool,
    ///
    #[prost(bool, tag = "12")]
    pub is_up_top: bool,
    ///
    #[prost(bool, tag = "13")]
    pub is_admin_top: bool,
    ///
    #[prost(bool, tag = "14")]
    pub is_vote_top: bool,
    ///
    #[prost(int64, tag = "15")]
    pub max_line: i64,
    ///
    #[prost(bool, tag = "16")]
    pub invisible: bool,
    ///
    #[prost(bool, tag = "17")]
    pub is_contractor: bool,
    ///
    #[prost(bool, tag = "18")]
    pub is_note: bool,
    ///
    #[prost(message, repeated, tag = "19")]
    pub card_labels: ::prost::alloc::vec::Vec<ReplyCardLabel>,
    ///
    #[prost(string, tag = "20")]
    pub sub_reply_entry_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "21")]
    pub sub_reply_title_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "22")]
    pub contract_desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "23")]
    pub time_desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "24")]
    pub biz_scene: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "25")]
    pub location: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "26")]
    pub fold_pictures: bool,
    ///
    #[prost(bool, tag = "27")]
    pub is_note_v2: bool,
    ///
    #[prost(bool, tag = "28")]
    pub hide_note_icon: bool,
    ///
    #[prost(string, tag = "29")]
    pub cm_recommend_component: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "30")]
    pub vote_option: ::core::option::Option<reply_control::VoteOption>,
    ///
    #[prost(string, tag = "31")]
    pub charged_desc: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "32")]
    pub grade_record: ::core::option::Option<reply_control::GradeRecord>,
    ///
    #[prost(string, tag = "33")]
    pub preset_reply_text: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "34")]
    pub easter_egg_label: ::core::option::Option<reply_control::EasterEggLabel>,
    ///
    #[prost(string, tag = "35")]
    pub context_feature: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "36")]
    pub insert_effect: ::core::option::Option<reply_control::InsertEffect>,
}
/// Nested message and enum types in `ReplyControl`.
pub mod reply_control {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EasterEggLabel {
        ///
        #[prost(string, tag = "1")]
        pub image: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "2")]
        pub jump_url: ::prost::alloc::string::String,
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GradeRecord {
        ///
        #[prost(int32, tag = "1")]
        pub score: i32,
        ///
        #[prost(message, repeated, tag = "2")]
        pub texts: ::prost::alloc::vec::Vec<grade_record::Text>,
    }
    /// Nested message and enum types in `GradeRecord`.
    pub mod grade_record {
        ///
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Text {
            ///
            #[prost(string, tag = "1")]
            pub raw: ::prost::alloc::string::String,
            ///
            #[prost(message, optional, tag = "2")]
            pub style: ::core::option::Option<super::super::TextStyle>,
        }
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InsertEffect {
        ///
        #[prost(string, tag = "1")]
        pub content: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "2")]
        pub icon: ::prost::alloc::string::String,
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VoteOption {
        ///
        #[prost(enumeration = "vote_option::LabelKind", tag = "1")]
        pub label_kind: i32,
        ///
        #[prost(string, tag = "2")]
        pub desc: ::prost::alloc::string::String,
        ///
        #[prost(int64, tag = "3")]
        pub idx: i64,
        ///
        #[prost(int64, tag = "4")]
        pub vote_id: i64,
    }
    /// Nested message and enum types in `VoteOption`.
    pub mod vote_option {
        ///
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum LabelKind {
            ///
            DefaultLabelKind = 0,
            ///
            Red = 1,
            ///
            Blue = 2,
            ///
            Plain = 3,
        }
        impl LabelKind {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::DefaultLabelKind => "DEFAULT_LabelKind",
                    Self::Red => "RED",
                    Self::Blue => "BLUE",
                    Self::Plain => "PLAIN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DEFAULT_LabelKind" => Some(Self::DefaultLabelKind),
                    "RED" => Some(Self::Red),
                    "BLUE" => Some(Self::Blue),
                    "PLAIN" => Some(Self::Plain),
                    _ => None,
                }
            }
        }
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplyExtra {
    ///
    #[prost(int64, tag = "1")]
    pub season_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub season_type: i64,
    ///
    #[prost(int64, tag = "3")]
    pub ep_id: i64,
    ///
    #[prost(bool, tag = "4")]
    pub is_story: bool,
    ///
    #[prost(string, tag = "5")]
    pub spmid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub from_spmid: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "7")]
    pub disable_underline: bool,
    ///
    #[prost(bool, tag = "8")]
    pub disable_we_search: bool,
    ///
    #[prost(bool, tag = "9")]
    pub disable_filter_tag: bool,
    ///
    #[prost(bool, tag = "10")]
    pub is_activity_mode: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplyInfo {
    ///
    #[prost(message, repeated, tag = "1")]
    pub replies: ::prost::alloc::vec::Vec<ReplyInfo>,
    ///
    #[prost(int64, tag = "2")]
    pub id: i64,
    ///
    #[prost(int64, tag = "3")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "4")]
    pub r#type: i64,
    ///
    #[prost(int64, tag = "5")]
    pub mid: i64,
    ///
    #[prost(int64, tag = "6")]
    pub root: i64,
    ///
    #[prost(int64, tag = "7")]
    pub parent: i64,
    ///
    #[prost(int64, tag = "8")]
    pub dialog: i64,
    ///
    #[prost(int64, tag = "9")]
    pub like: i64,
    ///
    #[prost(int64, tag = "10")]
    pub ctime: i64,
    ///
    #[prost(int64, tag = "11")]
    pub count: i64,
    ///
    #[prost(message, optional, tag = "12")]
    pub content: ::core::option::Option<Content>,
    ///
    #[prost(message, optional, tag = "13")]
    pub member: ::core::option::Option<Member>,
    ///
    #[prost(message, optional, tag = "14")]
    pub reply_control: ::core::option::Option<ReplyControl>,
    ///
    #[prost(message, optional, tag = "15")]
    pub member_v2: ::core::option::Option<MemberV2>,
    ///
    #[prost(string, tag = "16")]
    pub track_info: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplyInfoReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub reply: ::core::option::Option<ReplyInfo>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReplyInfoReq {
    ///
    #[prost(int64, tag = "1")]
    pub rpid: i64,
    ///
    #[prost(enumeration = "reply_info_req::ReplyInfoScene", tag = "2")]
    pub scene: i32,
}
/// Nested message and enum types in `ReplyInfoReq`.
pub mod reply_info_req {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReplyInfoScene {
        ///
        Insert = 0,
    }
    impl ReplyInfoScene {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Insert => "Insert",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Insert" => Some(Self::Insert),
                _ => None,
            }
        }
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplyTrackInfo {
    ///
    #[prost(string, tag = "1")]
    pub track_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RichText {
    ///
    #[prost(oneof = "rich_text::Item", tags = "1, 2")]
    pub item: ::core::option::Option<rich_text::Item>,
}
/// Nested message and enum types in `RichText`.
pub mod rich_text {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Item {
        ///
        #[prost(message, tag = "1")]
        Note(super::RichTextNote),
        ///
        #[prost(message, tag = "2")]
        Opus(super::super::super::super::super::app::dynamic::v2::OpusItem),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RichTextNote {
    ///
    #[prost(string, tag = "1")]
    pub summary: ::prost::alloc::string::String,
    ///
    #[prost(string, repeated, tag = "2")]
    pub images: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(string, tag = "3")]
    pub click_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub last_mtime_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchItem {
    ///
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(oneof = "search_item::Item", tags = "2, 3, 4")]
    pub item: ::core::option::Option<search_item::Item>,
}
/// Nested message and enum types in `SearchItem`.
pub mod search_item {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Item {
        ///
        #[prost(message, tag = "2")]
        Goods(super::GoodsSearchItem),
        ///
        #[prost(message, tag = "3")]
        Video(super::VideoSearchItem),
        ///
        #[prost(message, tag = "4")]
        Article(super::ArticleSearchItem),
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SearchItemCursorReply {
    ///
    #[prost(bool, tag = "1")]
    pub has_next: bool,
    ///
    #[prost(int64, tag = "2")]
    pub next: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SearchItemCursorReq {
    ///
    #[prost(int64, tag = "1")]
    pub next: i64,
    ///
    #[prost(enumeration = "SearchItemType", tag = "2")]
    pub item_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchItemPreHookReply {
    ///
    #[prost(string, tag = "1")]
    pub placeholder_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub background_text: ::prost::alloc::string::String,
    ///
    #[prost(int32, repeated, tag = "3")]
    pub ordered_type: ::prost::alloc::vec::Vec<i32>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SearchItemPreHookReq {
    ///
    #[prost(int64, tag = "1")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub r#type: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchItemReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub cursor: ::core::option::Option<SearchItemCursorReply>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<SearchItem>,
    ///
    #[prost(message, optional, tag = "3")]
    pub extra: ::core::option::Option<SearchItemReplyExtraInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchItemReplyExtraInfo {
    ///
    #[prost(string, tag = "1")]
    pub event_id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchItemReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub cursor: ::core::option::Option<SearchItemCursorReq>,
    ///
    #[prost(int64, tag = "2")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub r#type: i64,
    ///
    #[prost(string, tag = "4")]
    pub keyword: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareRepliesInfoReq {
    ///
    #[prost(int64, repeated, tag = "1")]
    pub rpids: ::prost::alloc::vec::Vec<i64>,
    ///
    #[prost(int64, tag = "2")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub r#type: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareRepliesInfoResp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub infos: ::prost::alloc::vec::Vec<ShareReplyInfo>,
    ///
    #[prost(string, tag = "2")]
    pub from_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub from_up: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub from_pic: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub slogan_pic: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub slogan_text: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "8")]
    pub topic: ::core::option::Option<ShareReplyTopic>,
    ///
    #[prost(message, optional, tag = "9")]
    pub extra: ::core::option::Option<share_replies_info_resp::ShareExtra>,
}
/// Nested message and enum types in `ShareRepliesInfoResp`.
pub mod share_replies_info_resp {
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ShareExtra {
        ///
        #[prost(bool, tag = "1")]
        pub is_pgc: bool,
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareReplyInfo {
    ///
    #[prost(message, optional, tag = "1")]
    pub member: ::core::option::Option<Member>,
    ///
    #[prost(message, optional, tag = "2")]
    pub content: ::core::option::Option<Content>,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub sub_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub achievement_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub label_url: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShareReplyMaterialReq {
    ///
    #[prost(int64, tag = "1")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub r#type: i64,
    ///
    #[prost(int64, tag = "3")]
    pub rpid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareReplyMaterialResp {
    ///
    #[prost(message, optional, tag = "1")]
    pub subject_material: ::core::option::Option<
        share_reply_material_resp::SubjectMaterial,
    >,
    ///
    #[prost(string, tag = "2")]
    pub qrcode_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub save_pic_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub open_app_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub share_time_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub bili_logo_icon: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "7")]
    pub extra: ::core::option::Option<share_reply_material_resp::ExtraData>,
}
/// Nested message and enum types in `ShareReplyMaterialResp`.
pub mod share_reply_material_resp {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ArchiveMaterial {
        ///
        #[prost(string, tag = "1")]
        pub title: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "2")]
        pub cover: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "3")]
        pub up_name: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "4")]
        pub up_icon: ::prost::alloc::string::String,
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ArticleMaterial {
        ///
        #[prost(string, tag = "1")]
        pub title: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "2")]
        pub message: ::prost::alloc::string::String,
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DynamicMaterial {
        ///
        #[prost(string, tag = "1")]
        pub title: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "2")]
        pub message: ::prost::alloc::string::String,
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExtraData {
        ///
        #[prost(bool, tag = "1")]
        pub is_pgc: bool,
        ///
        #[prost(string, tag = "2")]
        pub origin_text: ::prost::alloc::string::String,
        ///
        #[prost(int64, tag = "3")]
        pub topic_id: i64,
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SubjectMaterial {
        ///
        #[prost(oneof = "subject_material::Item", tags = "1, 2, 3")]
        pub item: ::core::option::Option<subject_material::Item>,
    }
    /// Nested message and enum types in `SubjectMaterial`.
    pub mod subject_material {
        ///
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Item {
            ///
            #[prost(message, tag = "1")]
            ArchiveMaterial(super::ArchiveMaterial),
            ///
            #[prost(message, tag = "2")]
            DynamicMaterial(super::DynamicMaterial),
            ///
            #[prost(message, tag = "3")]
            ArticleMaterial(super::ArticleMaterial),
        }
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareReplyTopic {
    ///
    #[prost(message, optional, tag = "1")]
    pub topic: ::core::option::Option<Topic>,
    ///
    #[prost(string, tag = "2")]
    pub origin_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubjectControl {
    ///
    #[prost(int64, tag = "1")]
    pub up_mid: i64,
    ///
    #[prost(bool, tag = "2")]
    pub is_assist: bool,
    ///
    #[prost(bool, tag = "3")]
    pub read_only: bool,
    ///
    #[prost(bool, tag = "4")]
    pub has_vote_access: bool,
    ///
    #[prost(bool, tag = "5")]
    pub has_lottery_access: bool,
    ///
    #[prost(bool, tag = "6")]
    pub has_folded_reply: bool,
    ///
    #[prost(string, tag = "7")]
    pub bg_text: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "8")]
    pub up_blocked: bool,
    ///
    #[prost(bool, tag = "9")]
    pub has_activity_access: bool,
    ///
    #[prost(bool, tag = "10")]
    pub show_title: bool,
    ///
    #[prost(bool, tag = "11")]
    pub show_up_action: bool,
    ///
    #[prost(int64, tag = "12")]
    pub switcher_type: i64,
    ///
    #[prost(bool, tag = "13")]
    pub input_disable: bool,
    ///
    #[prost(string, tag = "14")]
    pub root_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "15")]
    pub child_text: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "16")]
    pub count: i64,
    ///
    #[prost(string, tag = "17")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "18")]
    pub giveup_text: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "19")]
    pub has_note_access: bool,
    ///
    #[prost(bool, tag = "20")]
    pub disable_jump_emote: bool,
    ///
    #[prost(string, tag = "21")]
    pub empty_background_text_plain: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "22")]
    pub empty_background_text_highlight: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "23")]
    pub empty_background_uri: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "24")]
    pub support_filter_tags: ::prost::alloc::vec::Vec<subject_control::FilterTag>,
    ///
    #[prost(enumeration = "EditorIconState", tag = "25")]
    pub screenshot_icon_state: i32,
    ///
    #[prost(enumeration = "EditorIconState", tag = "26")]
    pub upload_picture_icon_state: i32,
    ///
    #[prost(message, optional, tag = "27")]
    pub empty_page: ::core::option::Option<EmptyPage>,
    ///
    #[prost(message, optional, tag = "28")]
    pub cm_top_reply_protection: ::core::option::Option<
        subject_control::CmTopReplyProtection,
    >,
    ///
    #[prost(bool, tag = "29")]
    pub enable_charged: bool,
}
/// Nested message and enum types in `SubjectControl`.
pub mod subject_control {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CmTopReplyProtection {
        ///
        #[prost(int64, tag = "1")]
        pub protected_top_rpid: i64,
        ///
        #[prost(string, tag = "2")]
        pub popup_message: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "3")]
        pub appeal_url: ::prost::alloc::string::String,
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FilterTag {
        ///
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "2")]
        pub event_id: ::prost::alloc::string::String,
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SuggestEmotesReq {
    ///
    #[prost(int64, tag = "1")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub r#type: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestEmotesResp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub emotes: ::prost::alloc::vec::Vec<Emote>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextStyle {
    ///
    #[prost(int32, tag = "1")]
    pub font_size: i32,
    ///
    #[prost(enumeration = "text_style::FontStyle", tag = "2")]
    pub font_style: i32,
    ///
    #[prost(string, tag = "3")]
    pub text_day_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub text_night_color: ::prost::alloc::string::String,
}
/// Nested message and enum types in `TextStyle`.
pub mod text_style {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FontStyle {
        ///
        Normal = 0,
        ///
        Bold = 1,
    }
    impl FontStyle {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Normal => "NORMAL",
                Self::Bold => "BOLD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NORMAL" => Some(Self::Normal),
                "BOLD" => Some(Self::Bold),
                _ => None,
            }
        }
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Topic {
    ///
    #[prost(string, tag = "1")]
    pub link: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UgcVideoSearchItem {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub up_nickname: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub duration: i64,
    ///
    #[prost(string, tag = "4")]
    pub cover: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpSelection {
    ///
    #[prost(int64, tag = "1")]
    pub pending_count: i64,
    ///
    #[prost(int64, tag = "2")]
    pub ignore_count: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Url {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub state: i64,
    ///
    #[prost(string, tag = "3")]
    pub prefix_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub app_url_schema: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub app_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub app_package_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub click_report: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "8")]
    pub is_half_screen: bool,
    ///
    #[prost(string, tag = "9")]
    pub exposure_report: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "10")]
    pub extra: ::core::option::Option<url::Extra>,
    ///
    #[prost(bool, tag = "11")]
    pub underline: bool,
    ///
    #[prost(bool, tag = "12")]
    pub match_once: bool,
    ///
    #[prost(string, tag = "13")]
    pub pc_url: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "url::IconPosition", tag = "14")]
    pub icon_position: i32,
}
/// Nested message and enum types in `Url`.
pub mod url {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Extra {
        ///
        #[prost(int64, tag = "1")]
        pub goods_item_id: i64,
        ///
        #[prost(string, tag = "2")]
        pub goods_prefetched_cache: ::prost::alloc::string::String,
        ///
        #[prost(enumeration = "extra::GoodsShowType", tag = "3")]
        pub goods_show_type: i32,
        ///
        #[prost(bool, tag = "4")]
        pub is_word_search: bool,
        ///
        #[prost(int64, tag = "5")]
        pub goods_cm_control: i64,
        ///
        #[prost(string, tag = "6")]
        pub goods_click_report: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "7")]
        pub goods_exposure_report: ::prost::alloc::string::String,
        ///
        #[prost(int64, tag = "8")]
        pub goods_show_pop_window: i64,
    }
    /// Nested message and enum types in `Extra`.
    pub mod extra {
        ///
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum GoodsShowType {
            ///
            Popup = 0,
            ///
            FullScreen = 1,
            ///
            HalfScreen = 2,
        }
        impl GoodsShowType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Popup => "Popup",
                    Self::FullScreen => "FullScreen",
                    Self::HalfScreen => "HalfScreen",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "Popup" => Some(Self::Popup),
                    "FullScreen" => Some(Self::FullScreen),
                    "HalfScreen" => Some(Self::HalfScreen),
                    _ => None,
                }
            }
        }
    }
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IconPosition {
        ///
        Prefix = 0,
        ///
        Suffix = 1,
    }
    impl IconPosition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Prefix => "Prefix",
                Self::Suffix => "Suffix",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Prefix" => Some(Self::Prefix),
                "Suffix" => Some(Self::Suffix),
                _ => None,
            }
        }
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserCallbackReply {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserCallbackReq {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(enumeration = "UserCallbackScene", tag = "2")]
    pub scene: i32,
    ///
    #[prost(enumeration = "UserCallbackAction", tag = "3")]
    pub action: i32,
    ///
    #[prost(int64, tag = "4")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "5")]
    pub r#type: i64,
    ///
    #[prost(int64, repeated, tag = "6")]
    pub rpids: ::prost::alloc::vec::Vec<i64>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoSearchItem {
    ///
    #[prost(enumeration = "SearchItemVideoSubType", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(oneof = "video_search_item::VideoItem", tags = "2, 3")]
    pub video_item: ::core::option::Option<video_search_item::VideoItem>,
}
/// Nested message and enum types in `VideoSearchItem`.
pub mod video_search_item {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum VideoItem {
        ///
        #[prost(message, tag = "2")]
        Ugc(super::UgcVideoSearchItem),
        ///
        #[prost(message, tag = "3")]
        Pgc(super::PgcVideoSearchItem),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Vote {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub count: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VoteCard {
    ///
    #[prost(int64, tag = "1")]
    pub vote_id: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub count: i64,
    ///
    #[prost(message, repeated, tag = "4")]
    pub options: ::prost::alloc::vec::Vec<vote_card::Option>,
    ///
    #[prost(int64, tag = "5")]
    pub my_vote_option: i64,
}
/// Nested message and enum types in `VoteCard`.
pub mod vote_card {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Option {
        ///
        #[prost(int64, tag = "1")]
        pub idx: i64,
        ///
        #[prost(string, tag = "2")]
        pub desc: ::prost::alloc::string::String,
        ///
        #[prost(int64, tag = "3")]
        pub count: i64,
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WordSearchParam {
    ///
    #[prost(int64, tag = "1")]
    pub shown_count: i64,
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DetailListScene {
    ///
    Reply = 0,
    ///
    MsgFeed = 1,
    ///
    Notify = 2,
}
impl DetailListScene {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Reply => "REPLY",
            Self::MsgFeed => "MSG_FEED",
            Self::Notify => "NOTIFY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REPLY" => Some(Self::Reply),
            "MSG_FEED" => Some(Self::MsgFeed),
            "NOTIFY" => Some(Self::Notify),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EditorIconState {
    ///
    Default = 0,
    ///
    Enable = 1,
    ///
    Disable = 2,
    ///
    Hide = 3,
}
impl EditorIconState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "EditorIconState_DEFAULT",
            Self::Enable => "EditorIconState_ENABLE",
            Self::Disable => "EditorIconState_DISABLE",
            Self::Hide => "EditorIconState_HIDE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EditorIconState_DEFAULT" => Some(Self::Default),
            "EditorIconState_ENABLE" => Some(Self::Enable),
            "EditorIconState_DISABLE" => Some(Self::Disable),
            "EditorIconState_HIDE" => Some(Self::Hide),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Mode {
    ///
    DefaultMode = 0,
    /// @Deprecated
    Unspecified = 1,
    ///
    MainListTime = 2,
    ///
    MainListHot = 3,
}
impl Mode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DefaultMode => "DEFAULT_Mode",
            Self::Unspecified => "UNSPECIFIED",
            Self::MainListTime => "MAIN_LIST_TIME",
            Self::MainListHot => "MAIN_LIST_HOT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEFAULT_Mode" => Some(Self::DefaultMode),
            "UNSPECIFIED" => Some(Self::Unspecified),
            "MAIN_LIST_TIME" => Some(Self::MainListTime),
            "MAIN_LIST_HOT" => Some(Self::MainListHot),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SearchItemType {
    ///
    DefaultItemType = 0,
    ///
    Goods = 1,
    ///
    Video = 2,
    ///
    Article = 3,
}
impl SearchItemType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DefaultItemType => "DEFAULT_ITEM_TYPE",
            Self::Goods => "GOODS",
            Self::Video => "VIDEO",
            Self::Article => "ARTICLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEFAULT_ITEM_TYPE" => Some(Self::DefaultItemType),
            "GOODS" => Some(Self::Goods),
            "VIDEO" => Some(Self::Video),
            "ARTICLE" => Some(Self::Article),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SearchItemVideoSubType {
    ///
    Ugc = 0,
    ///
    Pgc = 1,
}
impl SearchItemVideoSubType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Ugc => "UGC",
            Self::Pgc => "PGC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UGC" => Some(Self::Ugc),
            "PGC" => Some(Self::Pgc),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UserCallbackAction {
    ///
    Dismiss = 0,
}
impl UserCallbackAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Dismiss => "Dismiss",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Dismiss" => Some(Self::Dismiss),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UserCallbackScene {
    ///
    InsertUserCallbackScene = 0,
    ///
    RecommendSuperbReply = 1,
}
impl UserCallbackScene {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::InsertUserCallbackScene => "Insert_UserCallbackScene",
            Self::RecommendSuperbReply => "RecommendSuperbReply",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Insert_UserCallbackScene" => Some(Self::InsertUserCallbackScene),
            "RecommendSuperbReply" => Some(Self::RecommendSuperbReply),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod reply_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct ReplyClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ReplyClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ReplyClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ReplyClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn answer_question(
            &mut self,
            request: impl tonic::IntoRequest<super::AnswerQuestionReq>,
        ) -> std::result::Result<
            tonic::Response<super::AnswerQuestionResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.main.community.reply.v1.Reply/AnswerQuestion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.main.community.reply.v1.Reply",
                        "AnswerQuestion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn at_search(
            &mut self,
            request: impl tonic::IntoRequest<super::AtSearchReq>,
        ) -> std::result::Result<tonic::Response<super::AtSearchReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.main.community.reply.v1.Reply/AtSearch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.main.community.reply.v1.Reply", "AtSearch"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn detail_list(
            &mut self,
            request: impl tonic::IntoRequest<super::DetailListReq>,
        ) -> std::result::Result<
            tonic::Response<super::DetailListReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.main.community.reply.v1.Reply/DetailList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.main.community.reply.v1.Reply",
                        "DetailList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dialog_list(
            &mut self,
            request: impl tonic::IntoRequest<super::DialogListReq>,
        ) -> std::result::Result<
            tonic::Response<super::DialogListReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.main.community.reply.v1.Reply/DialogList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.main.community.reply.v1.Reply",
                        "DialogList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn do_vote(
            &mut self,
            request: impl tonic::IntoRequest<super::DoVoteReq>,
        ) -> std::result::Result<tonic::Response<super::DoVoteResp>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.main.community.reply.v1.Reply/DoVote",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.main.community.reply.v1.Reply", "DoVote"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn main_list(
            &mut self,
            request: impl tonic::IntoRequest<super::MainListReq>,
        ) -> std::result::Result<tonic::Response<super::MainListReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.main.community.reply.v1.Reply/MainList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.main.community.reply.v1.Reply", "MainList"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn preview_list(
            &mut self,
            request: impl tonic::IntoRequest<super::PreviewListReq>,
        ) -> std::result::Result<
            tonic::Response<super::PreviewListReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.main.community.reply.v1.Reply/PreviewList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.main.community.reply.v1.Reply",
                        "PreviewList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn reply_info(
            &mut self,
            request: impl tonic::IntoRequest<super::ReplyInfoReq>,
        ) -> std::result::Result<tonic::Response<super::ReplyInfoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.main.community.reply.v1.Reply/ReplyInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.main.community.reply.v1.Reply",
                        "ReplyInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn search_item(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchItemReq>,
        ) -> std::result::Result<
            tonic::Response<super::SearchItemReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.main.community.reply.v1.Reply/SearchItem",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.main.community.reply.v1.Reply",
                        "SearchItem",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn search_item_pre_hook(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchItemPreHookReq>,
        ) -> std::result::Result<
            tonic::Response<super::SearchItemPreHookReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.main.community.reply.v1.Reply/SearchItemPreHook",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.main.community.reply.v1.Reply",
                        "SearchItemPreHook",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn share_replies_info(
            &mut self,
            request: impl tonic::IntoRequest<super::ShareRepliesInfoReq>,
        ) -> std::result::Result<
            tonic::Response<super::ShareRepliesInfoResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.main.community.reply.v1.Reply/ShareRepliesInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.main.community.reply.v1.Reply",
                        "ShareRepliesInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn share_reply_material(
            &mut self,
            request: impl tonic::IntoRequest<super::ShareReplyMaterialReq>,
        ) -> std::result::Result<
            tonic::Response<super::ShareReplyMaterialResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.main.community.reply.v1.Reply/ShareReplyMaterial",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.main.community.reply.v1.Reply",
                        "ShareReplyMaterial",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn suggest_emotes(
            &mut self,
            request: impl tonic::IntoRequest<super::SuggestEmotesReq>,
        ) -> std::result::Result<
            tonic::Response<super::SuggestEmotesResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.main.community.reply.v1.Reply/SuggestEmotes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.main.community.reply.v1.Reply",
                        "SuggestEmotes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn user_callback(
            &mut self,
            request: impl tonic::IntoRequest<super::UserCallbackReq>,
        ) -> std::result::Result<
            tonic::Response<super::UserCallbackReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.main.community.reply.v1.Reply/UserCallback",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.main.community.reply.v1.Reply",
                        "UserCallback",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod reply_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ReplyServer.
    #[async_trait]
    pub trait Reply: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn answer_question(
            &self,
            request: tonic::Request<super::AnswerQuestionReq>,
        ) -> std::result::Result<
            tonic::Response<super::AnswerQuestionResp>,
            tonic::Status,
        >;
        ///
        async fn at_search(
            &self,
            request: tonic::Request<super::AtSearchReq>,
        ) -> std::result::Result<tonic::Response<super::AtSearchReply>, tonic::Status>;
        ///
        async fn detail_list(
            &self,
            request: tonic::Request<super::DetailListReq>,
        ) -> std::result::Result<tonic::Response<super::DetailListReply>, tonic::Status>;
        ///
        async fn dialog_list(
            &self,
            request: tonic::Request<super::DialogListReq>,
        ) -> std::result::Result<tonic::Response<super::DialogListReply>, tonic::Status>;
        ///
        async fn do_vote(
            &self,
            request: tonic::Request<super::DoVoteReq>,
        ) -> std::result::Result<tonic::Response<super::DoVoteResp>, tonic::Status>;
        ///
        async fn main_list(
            &self,
            request: tonic::Request<super::MainListReq>,
        ) -> std::result::Result<tonic::Response<super::MainListReply>, tonic::Status>;
        ///
        async fn preview_list(
            &self,
            request: tonic::Request<super::PreviewListReq>,
        ) -> std::result::Result<
            tonic::Response<super::PreviewListReply>,
            tonic::Status,
        >;
        ///
        async fn reply_info(
            &self,
            request: tonic::Request<super::ReplyInfoReq>,
        ) -> std::result::Result<tonic::Response<super::ReplyInfoReply>, tonic::Status>;
        ///
        async fn search_item(
            &self,
            request: tonic::Request<super::SearchItemReq>,
        ) -> std::result::Result<tonic::Response<super::SearchItemReply>, tonic::Status>;
        ///
        async fn search_item_pre_hook(
            &self,
            request: tonic::Request<super::SearchItemPreHookReq>,
        ) -> std::result::Result<
            tonic::Response<super::SearchItemPreHookReply>,
            tonic::Status,
        >;
        ///
        async fn share_replies_info(
            &self,
            request: tonic::Request<super::ShareRepliesInfoReq>,
        ) -> std::result::Result<
            tonic::Response<super::ShareRepliesInfoResp>,
            tonic::Status,
        >;
        ///
        async fn share_reply_material(
            &self,
            request: tonic::Request<super::ShareReplyMaterialReq>,
        ) -> std::result::Result<
            tonic::Response<super::ShareReplyMaterialResp>,
            tonic::Status,
        >;
        ///
        async fn suggest_emotes(
            &self,
            request: tonic::Request<super::SuggestEmotesReq>,
        ) -> std::result::Result<
            tonic::Response<super::SuggestEmotesResp>,
            tonic::Status,
        >;
        ///
        async fn user_callback(
            &self,
            request: tonic::Request<super::UserCallbackReq>,
        ) -> std::result::Result<
            tonic::Response<super::UserCallbackReply>,
            tonic::Status,
        >;
    }
    ///
    #[derive(Debug)]
    pub struct ReplyServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ReplyServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ReplyServer<T>
    where
        T: Reply,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.main.community.reply.v1.Reply/AnswerQuestion" => {
                    #[allow(non_camel_case_types)]
                    struct AnswerQuestionSvc<T: Reply>(pub Arc<T>);
                    impl<T: Reply> tonic::server::UnaryService<super::AnswerQuestionReq>
                    for AnswerQuestionSvc<T> {
                        type Response = super::AnswerQuestionResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AnswerQuestionReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Reply>::answer_question(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AnswerQuestionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.main.community.reply.v1.Reply/AtSearch" => {
                    #[allow(non_camel_case_types)]
                    struct AtSearchSvc<T: Reply>(pub Arc<T>);
                    impl<T: Reply> tonic::server::UnaryService<super::AtSearchReq>
                    for AtSearchSvc<T> {
                        type Response = super::AtSearchReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AtSearchReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Reply>::at_search(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AtSearchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.main.community.reply.v1.Reply/DetailList" => {
                    #[allow(non_camel_case_types)]
                    struct DetailListSvc<T: Reply>(pub Arc<T>);
                    impl<T: Reply> tonic::server::UnaryService<super::DetailListReq>
                    for DetailListSvc<T> {
                        type Response = super::DetailListReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DetailListReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Reply>::detail_list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DetailListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.main.community.reply.v1.Reply/DialogList" => {
                    #[allow(non_camel_case_types)]
                    struct DialogListSvc<T: Reply>(pub Arc<T>);
                    impl<T: Reply> tonic::server::UnaryService<super::DialogListReq>
                    for DialogListSvc<T> {
                        type Response = super::DialogListReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DialogListReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Reply>::dialog_list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DialogListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.main.community.reply.v1.Reply/DoVote" => {
                    #[allow(non_camel_case_types)]
                    struct DoVoteSvc<T: Reply>(pub Arc<T>);
                    impl<T: Reply> tonic::server::UnaryService<super::DoVoteReq>
                    for DoVoteSvc<T> {
                        type Response = super::DoVoteResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DoVoteReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Reply>::do_vote(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DoVoteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.main.community.reply.v1.Reply/MainList" => {
                    #[allow(non_camel_case_types)]
                    struct MainListSvc<T: Reply>(pub Arc<T>);
                    impl<T: Reply> tonic::server::UnaryService<super::MainListReq>
                    for MainListSvc<T> {
                        type Response = super::MainListReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MainListReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Reply>::main_list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MainListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.main.community.reply.v1.Reply/PreviewList" => {
                    #[allow(non_camel_case_types)]
                    struct PreviewListSvc<T: Reply>(pub Arc<T>);
                    impl<T: Reply> tonic::server::UnaryService<super::PreviewListReq>
                    for PreviewListSvc<T> {
                        type Response = super::PreviewListReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PreviewListReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Reply>::preview_list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PreviewListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.main.community.reply.v1.Reply/ReplyInfo" => {
                    #[allow(non_camel_case_types)]
                    struct ReplyInfoSvc<T: Reply>(pub Arc<T>);
                    impl<T: Reply> tonic::server::UnaryService<super::ReplyInfoReq>
                    for ReplyInfoSvc<T> {
                        type Response = super::ReplyInfoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReplyInfoReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Reply>::reply_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReplyInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.main.community.reply.v1.Reply/SearchItem" => {
                    #[allow(non_camel_case_types)]
                    struct SearchItemSvc<T: Reply>(pub Arc<T>);
                    impl<T: Reply> tonic::server::UnaryService<super::SearchItemReq>
                    for SearchItemSvc<T> {
                        type Response = super::SearchItemReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SearchItemReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Reply>::search_item(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SearchItemSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.main.community.reply.v1.Reply/SearchItemPreHook" => {
                    #[allow(non_camel_case_types)]
                    struct SearchItemPreHookSvc<T: Reply>(pub Arc<T>);
                    impl<
                        T: Reply,
                    > tonic::server::UnaryService<super::SearchItemPreHookReq>
                    for SearchItemPreHookSvc<T> {
                        type Response = super::SearchItemPreHookReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SearchItemPreHookReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Reply>::search_item_pre_hook(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SearchItemPreHookSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.main.community.reply.v1.Reply/ShareRepliesInfo" => {
                    #[allow(non_camel_case_types)]
                    struct ShareRepliesInfoSvc<T: Reply>(pub Arc<T>);
                    impl<
                        T: Reply,
                    > tonic::server::UnaryService<super::ShareRepliesInfoReq>
                    for ShareRepliesInfoSvc<T> {
                        type Response = super::ShareRepliesInfoResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ShareRepliesInfoReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Reply>::share_replies_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ShareRepliesInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.main.community.reply.v1.Reply/ShareReplyMaterial" => {
                    #[allow(non_camel_case_types)]
                    struct ShareReplyMaterialSvc<T: Reply>(pub Arc<T>);
                    impl<
                        T: Reply,
                    > tonic::server::UnaryService<super::ShareReplyMaterialReq>
                    for ShareReplyMaterialSvc<T> {
                        type Response = super::ShareReplyMaterialResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ShareReplyMaterialReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Reply>::share_reply_material(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ShareReplyMaterialSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.main.community.reply.v1.Reply/SuggestEmotes" => {
                    #[allow(non_camel_case_types)]
                    struct SuggestEmotesSvc<T: Reply>(pub Arc<T>);
                    impl<T: Reply> tonic::server::UnaryService<super::SuggestEmotesReq>
                    for SuggestEmotesSvc<T> {
                        type Response = super::SuggestEmotesResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SuggestEmotesReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Reply>::suggest_emotes(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SuggestEmotesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.main.community.reply.v1.Reply/UserCallback" => {
                    #[allow(non_camel_case_types)]
                    struct UserCallbackSvc<T: Reply>(pub Arc<T>);
                    impl<T: Reply> tonic::server::UnaryService<super::UserCallbackReq>
                    for UserCallbackSvc<T> {
                        type Response = super::UserCallbackReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UserCallbackReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Reply>::user_callback(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UserCallbackSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ReplyServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.main.community.reply.v1.Reply";
    impl<T> tonic::server::NamedService for ReplyServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
