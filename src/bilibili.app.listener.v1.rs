// This file is @generated by prost-build.
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Author {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub avatar: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub relation: ::core::option::Option<FollowRelation>,
}
impl ::prost::Name for Author {
    const NAME: &'static str = "Author";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.Author".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.Author".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BkArcDetailsReq {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<PlayItem>,
    ///
    #[prost(message, optional, tag = "2")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
}
impl ::prost::Name for BkArcDetailsReq {
    const NAME: &'static str = "BKArcDetailsReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.BKArcDetailsReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.BKArcDetailsReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BkArcDetailsResp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<DetailItem>,
}
impl ::prost::Name for BkArcDetailsResp {
    const NAME: &'static str = "BKArcDetailsResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.BKArcDetailsResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.BKArcDetailsResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BkArcPart {
    ///
    #[prost(int64, tag = "1")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub sub_id: i64,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub duration: i64,
    ///
    #[prost(int32, tag = "5")]
    pub page: i32,
}
impl ::prost::Name for BkArcPart {
    const NAME: &'static str = "BKArcPart";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.BKArcPart".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.BKArcPart".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BkArcRights {
    ///
    #[prost(int32, tag = "1")]
    pub no_reprint: i32,
}
impl ::prost::Name for BkArcRights {
    const NAME: &'static str = "BKArcRights";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.BKArcRights".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.BKArcRights".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BkArchive {
    ///
    #[prost(int64, tag = "1")]
    pub oid: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "5")]
    pub duration: i64,
    ///
    #[prost(int32, tag = "6")]
    pub rid: i32,
    ///
    #[prost(string, tag = "7")]
    pub rname: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "8")]
    pub publish: i64,
    ///
    #[prost(string, tag = "9")]
    pub displayed_oid: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "10")]
    pub copyright: i32,
    ///
    #[prost(message, optional, tag = "11")]
    pub rights: ::core::option::Option<BkArcRights>,
}
impl ::prost::Name for BkArchive {
    const NAME: &'static str = "BKArchive";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.BKArchive".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.BKArchive".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BkStat {
    ///
    #[prost(int32, tag = "1")]
    pub like: i32,
    ///
    #[prost(int32, tag = "2")]
    pub coin: i32,
    ///
    #[prost(int32, tag = "3")]
    pub favourite: i32,
    ///
    #[prost(int32, tag = "4")]
    pub reply: i32,
    ///
    #[prost(int32, tag = "5")]
    pub share: i32,
    ///
    #[prost(int32, tag = "6")]
    pub view: i32,
    ///
    #[prost(bool, tag = "7")]
    pub has_like: bool,
    ///
    #[prost(bool, tag = "8")]
    pub has_coin: bool,
    ///
    #[prost(bool, tag = "9")]
    pub has_fav: bool,
    ///
    #[prost(bool, tag = "10")]
    pub use_view_vt: bool,
    ///
    #[prost(string, tag = "11")]
    pub view_vt_text: ::prost::alloc::string::String,
}
impl ::prost::Name for BkStat {
    const NAME: &'static str = "BKStat";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.BKStat".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.BKStat".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardModule {
    ///
    #[prost(enumeration = "CardModuleType", tag = "1")]
    pub module_type: i32,
    ///
    #[prost(oneof = "card_module::Module", tags = "2, 3, 4")]
    pub module: ::core::option::Option<card_module::Module>,
}
/// Nested message and enum types in `CardModule`.
pub mod card_module {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Module {
        ///
        #[prost(message, tag = "2")]
        ModuleHeader(::prost::alloc::boxed::Box<super::PkcmHeader>),
        ///
        #[prost(message, tag = "3")]
        ModuleArchive(::prost::alloc::boxed::Box<super::PkcmArchive>),
        ///
        #[prost(message, tag = "4")]
        ModuleCbtn(::prost::alloc::boxed::Box<super::PkcmCenterButton>),
    }
}
impl ::prost::Name for CardModule {
    const NAME: &'static str = "CardModule";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.CardModule".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.CardModule".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClickReq {
    ///
    #[prost(int64, tag = "1")]
    pub sid: i64,
    ///
    #[prost(enumeration = "click_req::ClickAction", tag = "2")]
    pub action: i32,
}
/// Nested message and enum types in `ClickReq`.
pub mod click_req {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ClickAction {
        ///
        Invalid = 0,
        ///
        Share = 1,
    }
    impl ClickAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Invalid => "INVALID",
                Self::Share => "SHARE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INVALID" => Some(Self::Invalid),
                "SHARE" => Some(Self::Share),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for ClickReq {
    const NAME: &'static str = "ClickReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.ClickReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.ClickReq".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClickResp {}
impl ::prost::Name for ClickResp {
    const NAME: &'static str = "ClickResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.ClickResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.ClickResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoinAddReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<PlayItem>,
    ///
    #[prost(int32, tag = "2")]
    pub num: i32,
    ///
    #[prost(bool, tag = "3")]
    pub thumb_up: bool,
}
impl ::prost::Name for CoinAddReq {
    const NAME: &'static str = "CoinAddReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.CoinAddReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.CoinAddReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoinAddResp {
    ///
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
impl ::prost::Name for CoinAddResp {
    const NAME: &'static str = "CoinAddResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.CoinAddResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.CoinAddResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DashItem {
    ///
    #[prost(int32, tag = "1")]
    pub id: i32,
    ///
    #[prost(string, tag = "2")]
    pub base_url: ::prost::alloc::string::String,
    ///
    #[prost(string, repeated, tag = "3")]
    pub backup_url: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(int32, tag = "4")]
    pub bandwidth: i32,
    ///
    #[prost(string, tag = "5")]
    pub mime_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub codecs: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "12")]
    pub segment_base: ::core::option::Option<DashSegmentBase>,
    ///
    #[prost(int32, tag = "13")]
    pub codecid: i32,
    ///
    #[prost(string, tag = "14")]
    pub md5: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "15")]
    pub size: i64,
}
impl ::prost::Name for DashItem {
    const NAME: &'static str = "DashItem";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.DashItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.DashItem".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DashSegmentBase {
    ///
    #[prost(string, tag = "1")]
    pub initialization: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub index_range: ::prost::alloc::string::String,
}
impl ::prost::Name for DashSegmentBase {
    const NAME: &'static str = "DashSegmentBase";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.DashSegmentBase".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.DashSegmentBase".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetailItem {
    ///
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<PlayItem>,
    ///
    #[prost(message, optional, tag = "2")]
    pub arc: ::core::option::Option<BkArchive>,
    ///
    #[prost(message, repeated, tag = "3")]
    pub parts: ::prost::alloc::vec::Vec<BkArcPart>,
    ///
    #[prost(message, optional, tag = "4")]
    pub owner: ::core::option::Option<Author>,
    ///
    #[prost(message, optional, tag = "5")]
    pub stat: ::core::option::Option<BkStat>,
    ///
    #[prost(int64, tag = "6")]
    pub last_part: i64,
    ///
    #[prost(int64, tag = "7")]
    pub progress: i64,
    ///
    #[prost(int32, tag = "8")]
    pub playable: i32,
    ///
    #[prost(string, tag = "9")]
    pub message: ::prost::alloc::string::String,
    ///
    #[prost(map = "int64, message", tag = "10")]
    pub player_info: ::std::collections::HashMap<i64, PlayInfo>,
    ///
    #[prost(message, optional, tag = "11")]
    pub associated_item: ::core::option::Option<PlayItem>,
    ///
    #[prost(int64, tag = "12")]
    pub last_play_time: i64,
    ///
    #[prost(string, tag = "13")]
    pub history_tag: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "14")]
    pub device_type: ::core::option::Option<super::super::interfaces::v1::DeviceType>,
    ///
    #[prost(message, optional, tag = "15")]
    pub ugc_season_info: ::core::option::Option<FavFolder>,
}
impl ::prost::Name for DetailItem {
    const NAME: &'static str = "DetailItem";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.DetailItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.DetailItem".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventReq {
    ///
    #[prost(enumeration = "event_req::EventType", tag = "1")]
    pub event_type: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub item: ::core::option::Option<PlayItem>,
}
/// Nested message and enum types in `EventReq`.
pub mod event_req {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EventType {
        ///
        InvalidEventType = 0,
        ///
        GuideBarShow = 1,
    }
    impl EventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::InvalidEventType => "INVALID_EventType",
                Self::GuideBarShow => "GUIDE_BAR_SHOW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INVALID_EventType" => Some(Self::InvalidEventType),
                "GUIDE_BAR_SHOW" => Some(Self::GuideBarShow),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for EventReq {
    const NAME: &'static str = "EventReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.EventReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.EventReq".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EventResp {}
impl ::prost::Name for EventResp {
    const NAME: &'static str = "EventResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.EventResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.EventResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventTracking {
    ///
    #[prost(string, tag = "1")]
    pub operator: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub batch: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub track_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub entity_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub entity_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub track_json: ::prost::alloc::string::String,
}
impl ::prost::Name for EventTracking {
    const NAME: &'static str = "EventTracking";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.EventTracking".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.EventTracking".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavFolder {
    ///
    #[prost(int64, tag = "1")]
    pub fid: i64,
    ///
    #[prost(int32, tag = "2")]
    pub folder_type: i32,
    ///
    #[prost(message, optional, tag = "3")]
    pub owner: ::core::option::Option<FavFolderAuthor>,
    ///
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "7")]
    pub count: i32,
    ///
    #[prost(int32, tag = "8")]
    pub attr: i32,
    ///
    #[prost(int32, tag = "9")]
    pub state: i32,
    ///
    #[prost(int32, tag = "10")]
    pub favored: i32,
    ///
    #[prost(int64, tag = "11")]
    pub ctime: i64,
    ///
    #[prost(int64, tag = "12")]
    pub mtime: i64,
    ///
    #[prost(int32, tag = "13")]
    pub stat_fav_cnt: i32,
    ///
    #[prost(int32, tag = "14")]
    pub stat_share_cnt: i32,
    ///
    #[prost(int32, tag = "15")]
    pub stat_like_cnt: i32,
    ///
    #[prost(int32, tag = "16")]
    pub stat_play_cnt: i32,
    ///
    #[prost(int32, tag = "17")]
    pub stat_reply_cnt: i32,
    ///
    #[prost(int32, tag = "18")]
    pub fav_state: i32,
    ///
    #[prost(bool, tag = "19")]
    pub use_view_vt: bool,
    ///
    #[prost(string, tag = "20")]
    pub view_vt_text: ::prost::alloc::string::String,
}
impl ::prost::Name for FavFolder {
    const NAME: &'static str = "FavFolder";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavFolder".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavFolder".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FavFolderAction {
    ///
    #[prost(int64, tag = "1")]
    pub fid: i64,
    ///
    #[prost(int32, tag = "2")]
    pub folder_type: i32,
    ///
    #[prost(enumeration = "fav_folder_action::Action", tag = "3")]
    pub action: i32,
}
/// Nested message and enum types in `FavFolderAction`.
pub mod fav_folder_action {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        ///
        Unspecified = 0,
        ///
        Add = 1,
        ///
        Del = 2,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Add => "ADD",
                Self::Del => "DEL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ADD" => Some(Self::Add),
                "DEL" => Some(Self::Del),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for FavFolderAction {
    const NAME: &'static str = "FavFolderAction";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavFolderAction".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavFolderAction".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavFolderAuthor {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for FavFolderAuthor {
    const NAME: &'static str = "FavFolderAuthor";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavFolderAuthor".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavFolderAuthor".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavFolderCreateReq {
    ///
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub public: i32,
    ///
    #[prost(int32, tag = "4")]
    pub folder_type: i32,
}
impl ::prost::Name for FavFolderCreateReq {
    const NAME: &'static str = "FavFolderCreateReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavFolderCreateReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavFolderCreateReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavFolderCreateResp {
    ///
    #[prost(int64, tag = "1")]
    pub fid: i64,
    ///
    #[prost(int32, tag = "2")]
    pub folder_type: i32,
    ///
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
impl ::prost::Name for FavFolderCreateResp {
    const NAME: &'static str = "FavFolderCreateResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavFolderCreateResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavFolderCreateResp".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FavFolderDeleteReq {
    ///
    #[prost(int64, tag = "1")]
    pub fid: i64,
    ///
    #[prost(int32, tag = "2")]
    pub folder_type: i32,
}
impl ::prost::Name for FavFolderDeleteReq {
    const NAME: &'static str = "FavFolderDeleteReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavFolderDeleteReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavFolderDeleteReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavFolderDeleteResp {
    ///
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
impl ::prost::Name for FavFolderDeleteResp {
    const NAME: &'static str = "FavFolderDeleteResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavFolderDeleteResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavFolderDeleteResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavFolderDetailReq {
    ///
    #[prost(int64, tag = "1")]
    pub fid: i64,
    ///
    #[prost(int32, tag = "2")]
    pub folder_type: i32,
    ///
    #[prost(int64, tag = "3")]
    pub fav_mid: i64,
    ///
    #[prost(message, optional, tag = "4")]
    pub last_item: ::core::option::Option<FavItem>,
    ///
    #[prost(int32, tag = "5")]
    pub page_size: i32,
    ///
    #[prost(bool, tag = "6")]
    pub need_folder_info: bool,
}
impl ::prost::Name for FavFolderDetailReq {
    const NAME: &'static str = "FavFolderDetailReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavFolderDetailReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavFolderDetailReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavFolderDetailResp {
    ///
    #[prost(int32, tag = "1")]
    pub total: i32,
    ///
    #[prost(bool, tag = "2")]
    pub reach_end: bool,
    ///
    #[prost(message, repeated, tag = "3")]
    pub list: ::prost::alloc::vec::Vec<FavItemDetail>,
    ///
    #[prost(message, optional, tag = "4")]
    pub folder_info: ::core::option::Option<FavFolder>,
}
impl ::prost::Name for FavFolderDetailResp {
    const NAME: &'static str = "FavFolderDetailResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavFolderDetailResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavFolderDetailResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavFolderListReq {
    ///
    #[prost(int32, repeated, tag = "1")]
    pub folder_types: ::prost::alloc::vec::Vec<i32>,
    ///
    #[prost(message, optional, tag = "2")]
    pub item: ::core::option::Option<PlayItem>,
}
impl ::prost::Name for FavFolderListReq {
    const NAME: &'static str = "FavFolderListReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavFolderListReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavFolderListReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavFolderListResp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<FavFolder>,
}
impl ::prost::Name for FavFolderListResp {
    const NAME: &'static str = "FavFolderListResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavFolderListResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavFolderListResp".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FavFolderMeta {
    ///
    #[prost(int64, tag = "1")]
    pub fid: i64,
    ///
    #[prost(int32, tag = "2")]
    pub folder_type: i32,
}
impl ::prost::Name for FavFolderMeta {
    const NAME: &'static str = "FavFolderMeta";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavFolderMeta".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavFolderMeta".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavItem {
    ///
    #[prost(int32, tag = "1")]
    pub item_type: i32,
    ///
    #[prost(int64, tag = "2")]
    pub oid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub fid: i64,
    ///
    #[prost(int64, tag = "4")]
    pub mid: i64,
    ///
    #[prost(int64, tag = "5")]
    pub mtime: i64,
    ///
    #[prost(int64, tag = "6")]
    pub ctime: i64,
    ///
    #[prost(message, optional, tag = "7")]
    pub et: ::core::option::Option<EventTracking>,
}
impl ::prost::Name for FavItem {
    const NAME: &'static str = "FavItem";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavItem".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavItemAddReq {
    ///
    #[prost(int64, tag = "1")]
    pub fid: i64,
    ///
    #[prost(int32, tag = "2")]
    pub folder_type: i32,
    ///
    #[prost(bool, tag = "5")]
    pub is_fast_add_fav: bool,
    ///
    #[prost(oneof = "fav_item_add_req::Item", tags = "3, 4")]
    pub item: ::core::option::Option<fav_item_add_req::Item>,
}
/// Nested message and enum types in `FavItemAddReq`.
pub mod fav_item_add_req {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Item {
        ///
        #[prost(message, tag = "3")]
        Play(super::PlayItem),
        ///
        #[prost(message, tag = "4")]
        Fav(super::FavItem),
    }
}
impl ::prost::Name for FavItemAddReq {
    const NAME: &'static str = "FavItemAddReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavItemAddReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavItemAddReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavItemAddResp {
    ///
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
impl ::prost::Name for FavItemAddResp {
    const NAME: &'static str = "FavItemAddResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavItemAddResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavItemAddResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavItemAuthor {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for FavItemAuthor {
    const NAME: &'static str = "FavItemAuthor";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavItemAuthor".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavItemAuthor".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavItemBatchReq {
    ///
    #[prost(message, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<FavFolderAction>,
    ///
    #[prost(oneof = "fav_item_batch_req::Item", tags = "2, 3")]
    pub item: ::core::option::Option<fav_item_batch_req::Item>,
}
/// Nested message and enum types in `FavItemBatchReq`.
pub mod fav_item_batch_req {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Item {
        ///
        #[prost(message, tag = "2")]
        Play(super::PlayItem),
        ///
        #[prost(message, tag = "3")]
        Fav(super::FavItem),
    }
}
impl ::prost::Name for FavItemBatchReq {
    const NAME: &'static str = "FavItemBatchReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavItemBatchReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavItemBatchReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavItemBatchResp {
    ///
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
impl ::prost::Name for FavItemBatchResp {
    const NAME: &'static str = "FavItemBatchResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavItemBatchResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavItemBatchResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavItemDelReq {
    ///
    #[prost(int64, tag = "1")]
    pub fid: i64,
    ///
    #[prost(int32, tag = "2")]
    pub folder_type: i32,
    ///
    #[prost(bool, tag = "5")]
    pub is_fast_del_fav: bool,
    ///
    #[prost(oneof = "fav_item_del_req::Item", tags = "3, 4")]
    pub item: ::core::option::Option<fav_item_del_req::Item>,
}
/// Nested message and enum types in `FavItemDelReq`.
pub mod fav_item_del_req {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Item {
        ///
        #[prost(message, tag = "3")]
        Play(super::PlayItem),
        ///
        #[prost(message, tag = "4")]
        Fav(super::FavItem),
    }
}
impl ::prost::Name for FavItemDelReq {
    const NAME: &'static str = "FavItemDelReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavItemDelReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavItemDelReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavItemDelResp {
    ///
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
impl ::prost::Name for FavItemDelResp {
    const NAME: &'static str = "FavItemDelResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavItemDelResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavItemDelResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavItemDetail {
    ///
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<FavItem>,
    ///
    #[prost(message, optional, tag = "2")]
    pub owner: ::core::option::Option<FavItemAuthor>,
    ///
    #[prost(message, optional, tag = "3")]
    pub stat: ::core::option::Option<FavItemStat>,
    ///
    #[prost(string, tag = "4")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "6")]
    pub duration: i64,
    ///
    #[prost(int32, tag = "7")]
    pub state: i32,
    ///
    #[prost(string, tag = "8")]
    pub message: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "9")]
    pub parts: i32,
}
impl ::prost::Name for FavItemDetail {
    const NAME: &'static str = "FavItemDetail";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavItemDetail".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavItemDetail".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavItemStat {
    ///
    #[prost(int32, tag = "1")]
    pub view: i32,
    ///
    #[prost(int32, tag = "2")]
    pub reply: i32,
    ///
    #[prost(bool, tag = "3")]
    pub use_view_vt: bool,
    ///
    #[prost(string, tag = "4")]
    pub view_vt_text: ::prost::alloc::string::String,
}
impl ::prost::Name for FavItemStat {
    const NAME: &'static str = "FavItemStat";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavItemStat".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavItemStat".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FavTabShowReq {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
}
impl ::prost::Name for FavTabShowReq {
    const NAME: &'static str = "FavTabShowReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavTabShowReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavTabShowReq".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FavTabShowResp {
    ///
    #[prost(bool, tag = "1")]
    pub show_menu: bool,
}
impl ::prost::Name for FavTabShowResp {
    const NAME: &'static str = "FavTabShowResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavTabShowResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavTabShowResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavoredInAnyFoldersReq {
    ///
    #[prost(int32, repeated, tag = "1")]
    pub folder_types: ::prost::alloc::vec::Vec<i32>,
    ///
    #[prost(message, optional, tag = "2")]
    pub item: ::core::option::Option<PlayItem>,
}
impl ::prost::Name for FavoredInAnyFoldersReq {
    const NAME: &'static str = "FavoredInAnyFoldersReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavoredInAnyFoldersReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavoredInAnyFoldersReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FavoredInAnyFoldersResp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub folders: ::prost::alloc::vec::Vec<FavFolderMeta>,
    ///
    #[prost(message, optional, tag = "2")]
    pub item: ::core::option::Option<PlayItem>,
}
impl ::prost::Name for FavoredInAnyFoldersResp {
    const NAME: &'static str = "FavoredInAnyFoldersResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FavoredInAnyFoldersResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FavoredInAnyFoldersResp".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FollowRelation {
    ///
    #[prost(enumeration = "follow_relation::RelationStatus", tag = "1")]
    pub status: i32,
}
/// Nested message and enum types in `FollowRelation`.
pub mod follow_relation {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RelationStatus {
        ///
        UnspecifiedRelationStatus = 0,
        ///
        NoFollow = 1,
        ///
        Following = 2,
        ///
        Followed = 3,
        ///
        MutualFollowing = 4,
        ///
        SpecialFollowing = 5,
    }
    impl RelationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnspecifiedRelationStatus => "UNSPECIFIED_RelationStatus",
                Self::NoFollow => "NO_FOLLOW",
                Self::Following => "FOLLOWING",
                Self::Followed => "FOLLOWED",
                Self::MutualFollowing => "MUTUAL_FOLLOWING",
                Self::SpecialFollowing => "SPECIAL_FOLLOWING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED_RelationStatus" => Some(Self::UnspecifiedRelationStatus),
                "NO_FOLLOW" => Some(Self::NoFollow),
                "FOLLOWING" => Some(Self::Following),
                "FOLLOWED" => Some(Self::Followed),
                "MUTUAL_FOLLOWING" => Some(Self::MutualFollowing),
                "SPECIAL_FOLLOWING" => Some(Self::SpecialFollowing),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for FollowRelation {
    const NAME: &'static str = "FollowRelation";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FollowRelation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FollowRelation".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FormatDescription {
    ///
    #[prost(int32, tag = "1")]
    pub quality: i32,
    ///
    #[prost(string, tag = "2")]
    pub format: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub display_desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub superscript: ::prost::alloc::string::String,
}
impl ::prost::Name for FormatDescription {
    const NAME: &'static str = "FormatDescription";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.FormatDescription".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.FormatDescription".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MainFavMusicMenuListReq {
    ///
    #[prost(int32, tag = "1")]
    pub tab_type: i32,
    ///
    #[prost(string, tag = "2")]
    pub offset: ::prost::alloc::string::String,
}
impl ::prost::Name for MainFavMusicMenuListReq {
    const NAME: &'static str = "MainFavMusicMenuListReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.MainFavMusicMenuListReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.MainFavMusicMenuListReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MainFavMusicMenuListResp {
    ///
    #[prost(int32, tag = "1")]
    pub tab_type: i32,
    ///
    #[prost(message, repeated, tag = "2")]
    pub menu_list: ::prost::alloc::vec::Vec<MusicMenu>,
    ///
    #[prost(bool, tag = "3")]
    pub has_more: bool,
    ///
    #[prost(string, tag = "4")]
    pub offset: ::prost::alloc::string::String,
}
impl ::prost::Name for MainFavMusicMenuListResp {
    const NAME: &'static str = "MainFavMusicMenuListResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.MainFavMusicMenuListResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.MainFavMusicMenuListResp".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MainFavMusicSubTabListReq {}
impl ::prost::Name for MainFavMusicSubTabListReq {
    const NAME: &'static str = "MainFavMusicSubTabListReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.MainFavMusicSubTabListReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.MainFavMusicSubTabListReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MainFavMusicSubTabListResp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub tabs: ::prost::alloc::vec::Vec<MusicSubTab>,
    ///
    #[prost(message, optional, tag = "2")]
    pub default_tab_res: ::core::option::Option<MainFavMusicMenuListResp>,
    ///
    #[prost(map = "int32, message", tag = "3")]
    pub first_page_res: ::std::collections::HashMap<i32, MainFavMusicMenuListResp>,
}
impl ::prost::Name for MainFavMusicSubTabListResp {
    const NAME: &'static str = "MainFavMusicSubTabListResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.MainFavMusicSubTabListResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.MainFavMusicSubTabListResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MedialistItem {
    ///
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<PlayItem>,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub duration: i64,
    ///
    #[prost(int32, tag = "5")]
    pub parts: i32,
    ///
    #[prost(int64, tag = "6")]
    pub up_mid: i64,
    ///
    #[prost(string, tag = "7")]
    pub up_name: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "8")]
    pub state: i32,
    ///
    #[prost(string, tag = "9")]
    pub message: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "10")]
    pub stat_view: i64,
    ///
    #[prost(int64, tag = "11")]
    pub stat_reply: i64,
    ///
    #[prost(bool, tag = "12")]
    pub use_stat_view_vt: bool,
    ///
    #[prost(string, tag = "13")]
    pub stat_view_vt_text: ::prost::alloc::string::String,
}
impl ::prost::Name for MedialistItem {
    const NAME: &'static str = "MedialistItem";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.MedialistItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.MedialistItem".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MedialistReq {
    ///
    #[prost(int64, tag = "1")]
    pub list_type: i64,
    ///
    #[prost(int64, tag = "2")]
    pub biz_id: i64,
    ///
    #[prost(string, tag = "3")]
    pub offset: ::prost::alloc::string::String,
}
impl ::prost::Name for MedialistReq {
    const NAME: &'static str = "MedialistReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.MedialistReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.MedialistReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MedialistResp {
    ///
    #[prost(int64, tag = "1")]
    pub total: i64,
    ///
    #[prost(bool, tag = "2")]
    pub has_more: bool,
    ///
    #[prost(string, tag = "3")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "4")]
    pub items: ::prost::alloc::vec::Vec<MedialistItem>,
    ///
    #[prost(message, optional, tag = "5")]
    pub up_info: ::core::option::Option<MedialistUpInfo>,
}
impl ::prost::Name for MedialistResp {
    const NAME: &'static str = "MedialistResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.MedialistResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.MedialistResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MedialistUpInfo {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub avatar: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub fans: i64,
    ///
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for MedialistUpInfo {
    const NAME: &'static str = "MedialistUpInfo";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.MedialistUpInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.MedialistUpInfo".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MenuDeleteReq {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
}
impl ::prost::Name for MenuDeleteReq {
    const NAME: &'static str = "MenuDeleteReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.MenuDeleteReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.MenuDeleteReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MenuDeleteResp {
    ///
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
impl ::prost::Name for MenuDeleteResp {
    const NAME: &'static str = "MenuDeleteResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.MenuDeleteResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.MenuDeleteResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MenuEditReq {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "4")]
    pub is_public: i32,
}
impl ::prost::Name for MenuEditReq {
    const NAME: &'static str = "MenuEditReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.MenuEditReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.MenuEditReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MenuEditResp {
    ///
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
impl ::prost::Name for MenuEditResp {
    const NAME: &'static str = "MenuEditResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.MenuEditResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.MenuEditResp".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MenuSubscribeReq {
    ///
    #[prost(enumeration = "menu_subscribe_req::SubscribeAction", tag = "1")]
    pub action: i32,
    ///
    #[prost(int64, tag = "2")]
    pub target_id: i64,
}
/// Nested message and enum types in `MenuSubscribeReq`.
pub mod menu_subscribe_req {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SubscribeAction {
        ///
        InvalidSubscribeAction = 0,
        ///
        AddSubscribeAction = 1,
        ///
        DelSubscribeAction = 2,
    }
    impl SubscribeAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::InvalidSubscribeAction => "INVALID_SubscribeAction",
                Self::AddSubscribeAction => "ADD_SubscribeAction",
                Self::DelSubscribeAction => "DEL_SubscribeAction",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INVALID_SubscribeAction" => Some(Self::InvalidSubscribeAction),
                "ADD_SubscribeAction" => Some(Self::AddSubscribeAction),
                "DEL_SubscribeAction" => Some(Self::DelSubscribeAction),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for MenuSubscribeReq {
    const NAME: &'static str = "MenuSubscribeReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.MenuSubscribeReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.MenuSubscribeReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MenuSubscribeResp {
    ///
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
impl ::prost::Name for MenuSubscribeResp {
    const NAME: &'static str = "MenuSubscribeResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.MenuSubscribeResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.MenuSubscribeResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MusicMenu {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(int32, tag = "2")]
    pub menu_type: i32,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub owner: ::core::option::Option<MusicMenuAuthor>,
    ///
    #[prost(int32, tag = "7")]
    pub state: i32,
    ///
    #[prost(int64, tag = "8")]
    pub attr: i64,
    ///
    #[prost(message, optional, tag = "9")]
    pub stat: ::core::option::Option<MusicMenuStat>,
    ///
    #[prost(int64, tag = "10")]
    pub total: i64,
    ///
    #[prost(int64, tag = "11")]
    pub ctime: i64,
    ///
    #[prost(string, tag = "12")]
    pub uri: ::prost::alloc::string::String,
}
impl ::prost::Name for MusicMenu {
    const NAME: &'static str = "MusicMenu";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.MusicMenu".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.MusicMenu".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MusicMenuAuthor {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub avatar: ::prost::alloc::string::String,
}
impl ::prost::Name for MusicMenuAuthor {
    const NAME: &'static str = "MusicMenuAuthor";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.MusicMenuAuthor".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.MusicMenuAuthor".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MusicMenuStat {
    ///
    #[prost(int64, tag = "1")]
    pub play: i64,
    ///
    #[prost(int64, tag = "2")]
    pub reply: i64,
}
impl ::prost::Name for MusicMenuStat {
    const NAME: &'static str = "MusicMenuStat";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.MusicMenuStat".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.MusicMenuStat".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MusicSubTab {
    ///
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "2")]
    pub tab_type: i32,
    ///
    #[prost(int64, tag = "3")]
    pub total: i64,
}
impl ::prost::Name for MusicSubTab {
    const NAME: &'static str = "MusicSubTab";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.MusicSubTab".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.MusicSubTab".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PageOption {
    ///
    #[prost(int32, tag = "1")]
    pub page_size: i32,
    ///
    #[prost(enumeration = "page_option::Direction", tag = "2")]
    pub direction: i32,
    ///
    #[prost(message, optional, tag = "3")]
    pub last_item: ::core::option::Option<PlayItem>,
}
/// Nested message and enum types in `PageOption`.
pub mod page_option {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Direction {
        ///
        ScrollDown = 0,
        ///
        ScrollUp = 1,
    }
    impl Direction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ScrollDown => "SCROLL_DOWN",
                Self::ScrollUp => "SCROLL_UP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCROLL_DOWN" => Some(Self::ScrollDown),
                "SCROLL_UP" => Some(Self::ScrollUp),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for PageOption {
    const NAME: &'static str = "PageOption";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PageOption".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PageOption".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PickArchive {
    ///
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<PlayItem>,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub owner: ::core::option::Option<PickArchiveAuthor>,
    ///
    #[prost(string, tag = "4")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "5")]
    pub duration: i64,
    ///
    #[prost(int32, tag = "6")]
    pub parts: i32,
    ///
    #[prost(int32, tag = "7")]
    pub stat_view: i32,
    ///
    #[prost(int32, tag = "8")]
    pub stat_reply: i32,
    ///
    #[prost(int32, tag = "9")]
    pub state: i32,
    ///
    #[prost(string, tag = "10")]
    pub message: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "11")]
    pub use_stat_view_vt: bool,
    ///
    #[prost(string, tag = "12")]
    pub stat_view_vt_text: ::prost::alloc::string::String,
}
impl ::prost::Name for PickArchive {
    const NAME: &'static str = "PickArchive";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PickArchive".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PickArchive".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PickArchiveAuthor {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for PickArchiveAuthor {
    const NAME: &'static str = "PickArchiveAuthor";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PickArchiveAuthor".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PickArchiveAuthor".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PickCard {
    ///
    #[prost(int64, tag = "1")]
    pub pick_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub card_id: i64,
    ///
    #[prost(string, tag = "3")]
    pub card_name: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "4")]
    pub modules: ::prost::alloc::vec::Vec<CardModule>,
}
impl ::prost::Name for PickCard {
    const NAME: &'static str = "PickCard";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PickCard".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PickCard".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PickCardDetailReq {
    ///
    #[prost(int64, tag = "1")]
    pub card_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub pick_id: i64,
}
impl ::prost::Name for PickCardDetailReq {
    const NAME: &'static str = "PickCardDetailReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PickCardDetailReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PickCardDetailReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PickCardDetailResp {
    ///
    #[prost(int64, tag = "1")]
    pub card_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub pick_id: i64,
    ///
    #[prost(message, repeated, tag = "3")]
    pub modules: ::prost::alloc::vec::Vec<CardModule>,
}
impl ::prost::Name for PickCardDetailResp {
    const NAME: &'static str = "PickCardDetailResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PickCardDetailResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PickCardDetailResp".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PickFeedReq {
    ///
    #[prost(int64, tag = "1")]
    pub offset: i64,
}
impl ::prost::Name for PickFeedReq {
    const NAME: &'static str = "PickFeedReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PickFeedReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PickFeedReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PickFeedResp {
    ///
    #[prost(int64, tag = "1")]
    pub offset: i64,
    ///
    #[prost(message, repeated, tag = "2")]
    pub cards: ::prost::alloc::vec::Vec<PickCard>,
}
impl ::prost::Name for PickFeedResp {
    const NAME: &'static str = "PickFeedResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PickFeedResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PickFeedResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PkcmArchive {
    ///
    #[prost(message, optional, tag = "1")]
    pub arc: ::core::option::Option<PickArchive>,
    ///
    #[prost(string, tag = "2")]
    pub pick_reason: ::prost::alloc::string::String,
}
impl ::prost::Name for PkcmArchive {
    const NAME: &'static str = "PkcmArchive";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PkcmArchive".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PkcmArchive".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PkcmCenterButton {
    ///
    #[prost(string, tag = "1")]
    pub icon_head: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub icon_tail: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub uri: ::prost::alloc::string::String,
}
impl ::prost::Name for PkcmCenterButton {
    const NAME: &'static str = "PkcmCenterButton";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PkcmCenterButton".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PkcmCenterButton".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PkcmHeader {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub btn_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub btn_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub btn_uri: ::prost::alloc::string::String,
}
impl ::prost::Name for PkcmHeader {
    const NAME: &'static str = "PkcmHeader";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PkcmHeader".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PkcmHeader".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayActionReportReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<PlayItem>,
    ///
    #[prost(string, tag = "2")]
    pub from_spmid: ::prost::alloc::string::String,
}
impl ::prost::Name for PlayActionReportReq {
    const NAME: &'static str = "PlayActionReportReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PlayActionReportReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PlayActionReportReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayDash {
    ///
    #[prost(int32, tag = "1")]
    pub duration: i32,
    ///
    #[prost(float, tag = "2")]
    pub min_buffer_time: f32,
    ///
    #[prost(message, repeated, tag = "3")]
    pub audio: ::prost::alloc::vec::Vec<DashItem>,
}
impl ::prost::Name for PlayDash {
    const NAME: &'static str = "PlayDASH";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PlayDASH".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PlayDASH".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayHistoryAddReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<PlayItem>,
    ///
    #[prost(int64, tag = "2")]
    pub progress: i64,
    ///
    #[prost(int64, tag = "3")]
    pub duration: i64,
    ///
    #[prost(int32, tag = "4")]
    pub play_style: i32,
}
impl ::prost::Name for PlayHistoryAddReq {
    const NAME: &'static str = "PlayHistoryAddReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PlayHistoryAddReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PlayHistoryAddReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayHistoryDelReq {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<PlayItem>,
    ///
    #[prost(bool, tag = "2")]
    pub truncate: bool,
}
impl ::prost::Name for PlayHistoryDelReq {
    const NAME: &'static str = "PlayHistoryDelReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PlayHistoryDelReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PlayHistoryDelReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayHistoryReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub page_opt: ::core::option::Option<PageOption>,
    ///
    #[prost(int64, tag = "2")]
    pub local_today_zero: i64,
    ///
    #[prost(message, optional, tag = "3")]
    pub pagination: ::core::option::Option<super::super::super::pagination::Pagination>,
}
impl ::prost::Name for PlayHistoryReq {
    const NAME: &'static str = "PlayHistoryReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PlayHistoryReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PlayHistoryReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayHistoryResp {
    ///
    #[prost(int32, tag = "1")]
    pub total: i32,
    ///
    #[prost(bool, tag = "2")]
    pub reach_end: bool,
    ///
    #[prost(message, repeated, tag = "3")]
    pub list: ::prost::alloc::vec::Vec<DetailItem>,
    ///
    #[prost(message, optional, tag = "4")]
    pub pagination_reply: ::core::option::Option<
        super::super::super::pagination::PaginationReply,
    >,
}
impl ::prost::Name for PlayHistoryResp {
    const NAME: &'static str = "PlayHistoryResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PlayHistoryResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PlayHistoryResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayInfo {
    ///
    #[prost(int32, tag = "1")]
    pub qn: i32,
    ///
    #[prost(string, tag = "2")]
    pub format: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub qn_type: i32,
    ///
    #[prost(int32, tag = "6")]
    pub fnver: i32,
    ///
    #[prost(int32, tag = "7")]
    pub fnval: i32,
    ///
    #[prost(message, repeated, tag = "8")]
    pub formats: ::prost::alloc::vec::Vec<FormatDescription>,
    ///
    #[prost(int32, tag = "9")]
    pub video_codecid: i32,
    ///
    #[prost(int64, tag = "10")]
    pub length: i64,
    ///
    #[prost(int32, tag = "11")]
    pub code: i32,
    ///
    #[prost(string, tag = "12")]
    pub message: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "13")]
    pub expire_time: i64,
    ///
    #[prost(message, optional, tag = "14")]
    pub volume: ::core::option::Option<super::super::playurl::v1::VolumeInfo>,
    ///
    #[prost(oneof = "play_info::Info", tags = "4, 5")]
    pub info: ::core::option::Option<play_info::Info>,
}
/// Nested message and enum types in `PlayInfo`.
pub mod play_info {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Info {
        ///
        #[prost(message, tag = "4")]
        PlayUrl(super::PlayUrl),
        ///
        #[prost(message, tag = "5")]
        PlayDash(super::PlayDash),
    }
}
impl ::prost::Name for PlayInfo {
    const NAME: &'static str = "PlayInfo";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PlayInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PlayInfo".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayItem {
    ///
    #[prost(int32, tag = "1")]
    pub item_type: i32,
    ///
    #[prost(int64, tag = "3")]
    pub oid: i64,
    ///
    #[prost(int64, repeated, tag = "4")]
    pub sub_id: ::prost::alloc::vec::Vec<i64>,
    ///
    #[prost(message, optional, tag = "5")]
    pub et: ::core::option::Option<EventTracking>,
    ///
    #[prost(int64, tag = "6")]
    pub pos: i64,
}
impl ::prost::Name for PlayItem {
    const NAME: &'static str = "PlayItem";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PlayItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PlayItem".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayUrl {
    ///
    #[prost(message, repeated, tag = "1")]
    pub durl: ::prost::alloc::vec::Vec<ResponseUrl>,
}
impl ::prost::Name for PlayUrl {
    const NAME: &'static str = "PlayURL";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PlayURL".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PlayURL".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayUrlReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<PlayItem>,
    ///
    #[prost(message, optional, tag = "2")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
}
impl ::prost::Name for PlayUrlReq {
    const NAME: &'static str = "PlayURLReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PlayURLReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PlayURLReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayUrlResp {
    ///
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<PlayItem>,
    ///
    #[prost(int32, tag = "2")]
    pub playable: i32,
    ///
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    ///
    #[prost(map = "int64, message", tag = "4")]
    pub player_info: ::std::collections::HashMap<i64, PlayInfo>,
}
impl ::prost::Name for PlayUrlResp {
    const NAME: &'static str = "PlayURLResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PlayURLResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PlayURLResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlaylistAddReq {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<PlayItem>,
    ///
    #[prost(oneof = "playlist_add_req::Pos", tags = "2, 3, 4")]
    pub pos: ::core::option::Option<playlist_add_req::Pos>,
}
/// Nested message and enum types in `PlaylistAddReq`.
pub mod playlist_add_req {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Pos {
        ///
        #[prost(message, tag = "2")]
        After(super::PlayItem),
        ///
        #[prost(bool, tag = "3")]
        Head(bool),
        ///
        #[prost(bool, tag = "4")]
        Tail(bool),
    }
}
impl ::prost::Name for PlaylistAddReq {
    const NAME: &'static str = "PlaylistAddReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PlaylistAddReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PlaylistAddReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlaylistDelReq {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<PlayItem>,
    ///
    #[prost(bool, tag = "2")]
    pub truncate: bool,
}
impl ::prost::Name for PlaylistDelReq {
    const NAME: &'static str = "PlaylistDelReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PlaylistDelReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PlaylistDelReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlaylistOffset {
    ///
    #[prost(enumeration = "playlist_offset::PlaylistScrollDirection", tag = "1")]
    pub direction: i32,
    ///
    #[prost(message, optional, tag = "2")]
    pub last_item: ::core::option::Option<PlayItem>,
    ///
    #[prost(message, optional, tag = "3")]
    pub random_state: ::core::option::Option<RandomOrderStatus>,
    ///
    #[prost(message, optional, tag = "4")]
    pub sort_opt: ::core::option::Option<SortOption>,
}
/// Nested message and enum types in `PlaylistOffset`.
pub mod playlist_offset {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PlaylistScrollDirection {
        ///
        Down = 0,
        ///
        Up = 1,
    }
    impl PlaylistScrollDirection {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Down => "DOWN",
                Self::Up => "UP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DOWN" => Some(Self::Down),
                "UP" => Some(Self::Up),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for PlaylistOffset {
    const NAME: &'static str = "PlaylistOffset";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PlaylistOffset".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PlaylistOffset".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlaylistReq {
    ///
    #[prost(enumeration = "PlaylistSource", tag = "1")]
    pub from: i32,
    ///
    #[prost(int64, tag = "2")]
    pub id: i64,
    ///
    #[prost(message, optional, tag = "3")]
    pub anchor: ::core::option::Option<PlayItem>,
    ///
    #[prost(message, optional, tag = "4")]
    pub page_opt: ::core::option::Option<PageOption>,
    ///
    #[prost(message, optional, tag = "5")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(int64, tag = "6")]
    pub extra_id: i64,
    ///
    #[prost(message, optional, tag = "7")]
    pub sort_opt: ::core::option::Option<SortOption>,
    ///
    #[prost(message, optional, tag = "8")]
    pub pagination: ::core::option::Option<super::super::super::pagination::Pagination>,
}
impl ::prost::Name for PlaylistReq {
    const NAME: &'static str = "PlaylistReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PlaylistReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PlaylistReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlaylistResp {
    ///
    #[prost(int32, tag = "1")]
    pub total: i32,
    ///
    #[prost(bool, tag = "2")]
    pub reach_start: bool,
    ///
    #[prost(bool, tag = "3")]
    pub reach_end: bool,
    ///
    #[prost(message, repeated, tag = "4")]
    pub list: ::prost::alloc::vec::Vec<DetailItem>,
    ///
    #[prost(message, optional, tag = "5")]
    pub last_play: ::core::option::Option<PlayItem>,
    ///
    #[prost(int64, tag = "6")]
    pub last_progress: i64,
    ///
    #[prost(message, optional, tag = "7")]
    pub pagination_reply: ::core::option::Option<
        super::super::super::pagination::PaginationReply,
    >,
}
impl ::prost::Name for PlaylistResp {
    const NAME: &'static str = "PlaylistResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.PlaylistResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.PlaylistResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RandomOrderStatus {
    ///
    #[prost(int64, repeated, tag = "1")]
    pub exposed_pos: ::prost::alloc::vec::Vec<i64>,
}
impl ::prost::Name for RandomOrderStatus {
    const NAME: &'static str = "RandomOrderStatus";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.RandomOrderStatus".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.RandomOrderStatus".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RcmdOffset {
    ///
    #[prost(int64, tag = "1")]
    pub rcmd_from: i64,
    ///
    #[prost(int64, tag = "2")]
    pub id: i64,
    ///
    #[prost(int32, tag = "3")]
    pub page: i32,
    ///
    #[prost(string, tag = "4")]
    pub session_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub from_trackid: ::prost::alloc::string::String,
}
impl ::prost::Name for RcmdOffset {
    const NAME: &'static str = "RcmdOffset";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.RcmdOffset".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.RcmdOffset".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RcmdPlaylistReq {
    ///
    #[prost(enumeration = "rcmd_playlist_req::RcmdFrom", tag = "1")]
    pub from: i32,
    ///
    #[prost(int64, tag = "2")]
    pub id: i64,
    ///
    #[prost(bool, tag = "3")]
    pub need_history: bool,
    ///
    #[prost(bool, tag = "4")]
    pub need_top_cards: bool,
    ///
    #[prost(message, optional, tag = "5")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(message, optional, tag = "6")]
    pub page: ::core::option::Option<super::super::super::pagination::Pagination>,
    ///
    #[prost(map = "string, string", tag = "7")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `RcmdPlaylistReq`.
pub mod rcmd_playlist_req {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RcmdFrom {
        ///
        UnspecifiedRcmdFrom = 0,
        ///
        UpArchiveRcmdFrom = 1,
        ///
        IndexEntry = 2,
        ///
        ArchiveView = 3,
    }
    impl RcmdFrom {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnspecifiedRcmdFrom => "UNSPECIFIED_RcmdFrom",
                Self::UpArchiveRcmdFrom => "UP_ARCHIVE_RcmdFrom",
                Self::IndexEntry => "INDEX_ENTRY",
                Self::ArchiveView => "ARCHIVE_VIEW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED_RcmdFrom" => Some(Self::UnspecifiedRcmdFrom),
                "UP_ARCHIVE_RcmdFrom" => Some(Self::UpArchiveRcmdFrom),
                "INDEX_ENTRY" => Some(Self::IndexEntry),
                "ARCHIVE_VIEW" => Some(Self::ArchiveView),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for RcmdPlaylistReq {
    const NAME: &'static str = "RcmdPlaylistReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.RcmdPlaylistReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.RcmdPlaylistReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RcmdPlaylistResp {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<DetailItem>,
    ///
    #[prost(int64, tag = "2")]
    pub history_len: i64,
    ///
    #[prost(message, repeated, tag = "3")]
    pub top_cards: ::prost::alloc::vec::Vec<TopCard>,
    ///
    #[prost(message, optional, tag = "4")]
    pub next_page: ::core::option::Option<
        super::super::super::pagination::PaginationReply,
    >,
}
impl ::prost::Name for RcmdPlaylistResp {
    const NAME: &'static str = "RcmdPlaylistResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.RcmdPlaylistResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.RcmdPlaylistResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseUrl {
    ///
    #[prost(int32, tag = "1")]
    pub order: i32,
    ///
    #[prost(int64, tag = "2")]
    pub length: i64,
    ///
    #[prost(int64, tag = "3")]
    pub size: i64,
    ///
    #[prost(string, tag = "4")]
    pub ahead: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub vhead: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, repeated, tag = "7")]
    pub backup_url: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(string, tag = "8")]
    pub md5: ::prost::alloc::string::String,
}
impl ::prost::Name for ResponseUrl {
    const NAME: &'static str = "ResponseUrl";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.ResponseUrl".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.ResponseUrl".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SortOption {
    ///
    #[prost(enumeration = "ListOrder", tag = "1")]
    pub order: i32,
    ///
    #[prost(enumeration = "ListSortField", tag = "2")]
    pub sort_field: i32,
    ///
    #[prost(bool, tag = "3")]
    pub is_switching: bool,
}
impl ::prost::Name for SortOption {
    const NAME: &'static str = "SortOption";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.SortOption".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.SortOption".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThumbUpReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<PlayItem>,
    ///
    #[prost(enumeration = "thumb_up_req::ThumbType", tag = "2")]
    pub action: i32,
}
/// Nested message and enum types in `ThumbUpReq`.
pub mod thumb_up_req {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ThumbType {
        ///
        Like = 0,
        ///
        CancelLike = 1,
        ///
        Dislike = 2,
        ///
        CancelDislike = 3,
    }
    impl ThumbType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Like => "LIKE",
                Self::CancelLike => "CANCEL_LIKE",
                Self::Dislike => "DISLIKE",
                Self::CancelDislike => "CANCEL_DISLIKE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LIKE" => Some(Self::Like),
                "CANCEL_LIKE" => Some(Self::CancelLike),
                "DISLIKE" => Some(Self::Dislike),
                "CANCEL_DISLIKE" => Some(Self::CancelDislike),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for ThumbUpReq {
    const NAME: &'static str = "ThumbUpReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.ThumbUpReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.ThumbUpReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThumbUpResp {
    ///
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
impl ::prost::Name for ThumbUpResp {
    const NAME: &'static str = "ThumbUpResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.ThumbUpResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.ThumbUpResp".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopCard {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "top_card::PlayStrategy", tag = "2")]
    pub play_style: i32,
    ///
    #[prost(enumeration = "TopCardType", tag = "3")]
    pub card_type: i32,
    ///
    #[prost(int64, tag = "8")]
    pub pos: i64,
    ///
    #[prost(string, tag = "9")]
    pub title_icon: ::prost::alloc::string::String,
    ///
    #[prost(oneof = "top_card::Card", tags = "4, 5, 6, 7")]
    pub card: ::core::option::Option<top_card::Card>,
}
/// Nested message and enum types in `TopCard`.
pub mod top_card {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PlayStrategy {
        ///
        NoInterrupt = 0,
        ///
        PlayTarget = 1,
        ///
        PlayFirst = 2,
    }
    impl PlayStrategy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::NoInterrupt => "NO_INTERRUPT",
                Self::PlayTarget => "PLAY_TARGET",
                Self::PlayFirst => "PLAY_FIRST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NO_INTERRUPT" => Some(Self::NoInterrupt),
                "PLAY_TARGET" => Some(Self::PlayTarget),
                "PLAY_FIRST" => Some(Self::PlayFirst),
                _ => None,
            }
        }
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Card {
        ///
        #[prost(message, tag = "4")]
        ListenHistory(super::TpcdHistory),
        ///
        #[prost(message, tag = "5")]
        FavFolder(super::TpcdFavFolder),
        ///
        #[prost(message, tag = "6")]
        UpRecall(super::TpcdUpRecall),
        ///
        #[prost(message, tag = "7")]
        PickToday(super::TpcdPickToday),
    }
}
impl ::prost::Name for TopCard {
    const NAME: &'static str = "TopCard";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.TopCard".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.TopCard".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TpcdFavFolder {
    ///
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<DetailItem>,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub pic: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub fid: i64,
    ///
    #[prost(int32, tag = "5")]
    pub folder_type: i32,
}
impl ::prost::Name for TpcdFavFolder {
    const NAME: &'static str = "TpcdFavFolder";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.TpcdFavFolder".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.TpcdFavFolder".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TpcdHistory {
    ///
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<DetailItem>,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub pic: ::prost::alloc::string::String,
}
impl ::prost::Name for TpcdHistory {
    const NAME: &'static str = "TpcdHistory";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.TpcdHistory".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.TpcdHistory".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TpcdPickToday {
    ///
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<DetailItem>,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub pic: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub pick_id: i64,
    ///
    #[prost(int64, tag = "5")]
    pub pick_card_id: i64,
}
impl ::prost::Name for TpcdPickToday {
    const NAME: &'static str = "TpcdPickToday";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.TpcdPickToday".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.TpcdPickToday".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TpcdUpRecall {
    ///
    #[prost(int64, tag = "1")]
    pub up_mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub avatar: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub medialist_type: i64,
    ///
    #[prost(int64, tag = "5")]
    pub medialist_biz_id: i64,
    ///
    #[prost(message, optional, tag = "6")]
    pub item: ::core::option::Option<DetailItem>,
}
impl ::prost::Name for TpcdUpRecall {
    const NAME: &'static str = "TpcdUpRecall";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.TpcdUpRecall".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.TpcdUpRecall".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TripleLikeReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<PlayItem>,
}
impl ::prost::Name for TripleLikeReq {
    const NAME: &'static str = "TripleLikeReq";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.TripleLikeReq".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.TripleLikeReq".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TripleLikeResp {
    ///
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "2")]
    pub thumb_ok: bool,
    ///
    #[prost(bool, tag = "3")]
    pub coin_ok: bool,
    ///
    #[prost(bool, tag = "4")]
    pub fav_ok: bool,
}
impl ::prost::Name for TripleLikeResp {
    const NAME: &'static str = "TripleLikeResp";
    const PACKAGE: &'static str = "bilibili.app.listener.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.app.listener.v1.TripleLikeResp".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.app.listener.v1.TripleLikeResp".into()
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CardModuleType {
    ///
    ModuleInvalid = 0,
    ///
    ModuleHeader = 1,
    ///
    ModuleArchive = 2,
    ///
    ModuleCbtn = 3,
}
impl CardModuleType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ModuleInvalid => "Module_invalid",
            Self::ModuleHeader => "Module_header",
            Self::ModuleArchive => "Module_archive",
            Self::ModuleCbtn => "Module_cbtn",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Module_invalid" => Some(Self::ModuleInvalid),
            "Module_header" => Some(Self::ModuleHeader),
            "Module_archive" => Some(Self::ModuleArchive),
            "Module_cbtn" => Some(Self::ModuleCbtn),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ListOrder {
    ///
    NoOrder = 0,
    ///
    OrderNormal = 1,
    ///
    OrderReverse = 2,
    ///
    OrderRandom = 3,
}
impl ListOrder {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoOrder => "NO_ORDER",
            Self::OrderNormal => "ORDER_NORMAL",
            Self::OrderReverse => "ORDER_REVERSE",
            Self::OrderRandom => "ORDER_RANDOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NO_ORDER" => Some(Self::NoOrder),
            "ORDER_NORMAL" => Some(Self::OrderNormal),
            "ORDER_REVERSE" => Some(Self::OrderReverse),
            "ORDER_RANDOM" => Some(Self::OrderRandom),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ListSortField {
    ///
    NoSort = 0,
    ///
    SortCtime = 1,
    ///
    SortViewcnt = 2,
    ///
    SortFavcnt = 3,
}
impl ListSortField {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoSort => "NO_SORT",
            Self::SortCtime => "SORT_CTIME",
            Self::SortViewcnt => "SORT_VIEWCNT",
            Self::SortFavcnt => "SORT_FAVCNT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NO_SORT" => Some(Self::NoSort),
            "SORT_CTIME" => Some(Self::SortCtime),
            "SORT_VIEWCNT" => Some(Self::SortViewcnt),
            "SORT_FAVCNT" => Some(Self::SortFavcnt),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlaylistSource {
    ///
    Default = 0,
    ///
    MemSpace = 1,
    ///
    AudioCollection = 2,
    ///
    AudioCard = 3,
    ///
    UserFavourite = 4,
    ///
    UpArchive = 5,
    ///
    AudioCache = 6,
    ///
    PickCard = 7,
    ///
    MediaList = 8,
}
impl PlaylistSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "DEFAULT",
            Self::MemSpace => "MEM_SPACE",
            Self::AudioCollection => "AUDIO_COLLECTION",
            Self::AudioCard => "AUDIO_CARD",
            Self::UserFavourite => "USER_FAVOURITE",
            Self::UpArchive => "UP_ARCHIVE",
            Self::AudioCache => "AUDIO_CACHE",
            Self::PickCard => "PICK_CARD",
            Self::MediaList => "MEDIA_LIST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEFAULT" => Some(Self::Default),
            "MEM_SPACE" => Some(Self::MemSpace),
            "AUDIO_COLLECTION" => Some(Self::AudioCollection),
            "AUDIO_CARD" => Some(Self::AudioCard),
            "USER_FAVOURITE" => Some(Self::UserFavourite),
            "UP_ARCHIVE" => Some(Self::UpArchive),
            "AUDIO_CACHE" => Some(Self::AudioCache),
            "PICK_CARD" => Some(Self::PickCard),
            "MEDIA_LIST" => Some(Self::MediaList),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TopCardType {
    ///
    UnspecifiedTopCardType = 0,
    ///
    ListenHistory = 1,
    ///
    FavoriteFolder = 2,
    ///
    UpRecall = 3,
    ///
    PickToday = 4,
}
impl TopCardType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnspecifiedTopCardType => "UNSPECIFIED_TopCardType",
            Self::ListenHistory => "LISTEN_HISTORY",
            Self::FavoriteFolder => "FAVORITE_FOLDER",
            Self::UpRecall => "UP_RECALL",
            Self::PickToday => "PICK_TODAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED_TopCardType" => Some(Self::UnspecifiedTopCardType),
            "LISTEN_HISTORY" => Some(Self::ListenHistory),
            "FAVORITE_FOLDER" => Some(Self::FavoriteFolder),
            "UP_RECALL" => Some(Self::UpRecall),
            "PICK_TODAY" => Some(Self::PickToday),
            _ => None,
        }
    }
}
/// Generated client implementations.
#[cfg(feature = "feat-enable-generated-client")]
pub mod listener_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct ListenerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ListenerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ListenerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ListenerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn bk_arc_details(
            &mut self,
            request: impl tonic::IntoRequest<super::BkArcDetailsReq>,
        ) -> std::result::Result<
            tonic::Response<super::BkArcDetailsResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/BKArcDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.listener.v1.Listener", "BKArcDetails"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn coin_add(
            &mut self,
            request: impl tonic::IntoRequest<super::CoinAddReq>,
        ) -> std::result::Result<tonic::Response<super::CoinAddResp>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/CoinAdd",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.listener.v1.Listener", "CoinAdd"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn event(
            &mut self,
            request: impl tonic::IntoRequest<super::EventReq>,
        ) -> std::result::Result<tonic::Response<super::EventResp>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/Event",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.listener.v1.Listener", "Event"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn fav_folder_create(
            &mut self,
            request: impl tonic::IntoRequest<super::FavFolderCreateReq>,
        ) -> std::result::Result<
            tonic::Response<super::FavFolderCreateResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/FavFolderCreate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.listener.v1.Listener",
                        "FavFolderCreate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn fav_folder_delete(
            &mut self,
            request: impl tonic::IntoRequest<super::FavFolderDeleteReq>,
        ) -> std::result::Result<
            tonic::Response<super::FavFolderDeleteResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/FavFolderDelete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.listener.v1.Listener",
                        "FavFolderDelete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn fav_folder_detail(
            &mut self,
            request: impl tonic::IntoRequest<super::FavFolderDetailReq>,
        ) -> std::result::Result<
            tonic::Response<super::FavFolderDetailResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/FavFolderDetail",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.listener.v1.Listener",
                        "FavFolderDetail",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn fav_folder_list(
            &mut self,
            request: impl tonic::IntoRequest<super::FavFolderListReq>,
        ) -> std::result::Result<
            tonic::Response<super::FavFolderListResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/FavFolderList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.listener.v1.Listener", "FavFolderList"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn fav_item_add(
            &mut self,
            request: impl tonic::IntoRequest<super::FavItemAddReq>,
        ) -> std::result::Result<tonic::Response<super::FavItemAddResp>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/FavItemAdd",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.listener.v1.Listener", "FavItemAdd"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn fav_item_batch(
            &mut self,
            request: impl tonic::IntoRequest<super::FavItemBatchReq>,
        ) -> std::result::Result<
            tonic::Response<super::FavItemBatchResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/FavItemBatch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.listener.v1.Listener", "FavItemBatch"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn fav_item_del(
            &mut self,
            request: impl tonic::IntoRequest<super::FavItemDelReq>,
        ) -> std::result::Result<tonic::Response<super::FavItemDelResp>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/FavItemDel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.listener.v1.Listener", "FavItemDel"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn favored_in_any_folders(
            &mut self,
            request: impl tonic::IntoRequest<super::FavoredInAnyFoldersReq>,
        ) -> std::result::Result<
            tonic::Response<super::FavoredInAnyFoldersResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/FavoredInAnyFolders",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.listener.v1.Listener",
                        "FavoredInAnyFolders",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn medialist(
            &mut self,
            request: impl tonic::IntoRequest<super::MedialistReq>,
        ) -> std::result::Result<tonic::Response<super::MedialistResp>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/Medialist",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.listener.v1.Listener", "Medialist"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn pick_card_detail(
            &mut self,
            request: impl tonic::IntoRequest<super::PickCardDetailReq>,
        ) -> std::result::Result<
            tonic::Response<super::PickCardDetailResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/PickCardDetail",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.listener.v1.Listener",
                        "PickCardDetail",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn pick_feed(
            &mut self,
            request: impl tonic::IntoRequest<super::PickFeedReq>,
        ) -> std::result::Result<tonic::Response<super::PickFeedResp>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/PickFeed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.listener.v1.Listener", "PickFeed"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn ping(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/Ping",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.listener.v1.Listener", "Ping"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn play_action_report(
            &mut self,
            request: impl tonic::IntoRequest<super::PlayActionReportReq>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/PlayActionReport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.listener.v1.Listener",
                        "PlayActionReport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn play_history(
            &mut self,
            request: impl tonic::IntoRequest<super::PlayHistoryReq>,
        ) -> std::result::Result<
            tonic::Response<super::PlayHistoryResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/PlayHistory",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.listener.v1.Listener", "PlayHistory"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn play_history_add(
            &mut self,
            request: impl tonic::IntoRequest<super::PlayHistoryAddReq>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/PlayHistoryAdd",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.listener.v1.Listener",
                        "PlayHistoryAdd",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn play_history_del(
            &mut self,
            request: impl tonic::IntoRequest<super::PlayHistoryDelReq>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/PlayHistoryDel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.listener.v1.Listener",
                        "PlayHistoryDel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn play_url(
            &mut self,
            request: impl tonic::IntoRequest<super::PlayUrlReq>,
        ) -> std::result::Result<tonic::Response<super::PlayUrlResp>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/PlayURL",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.listener.v1.Listener", "PlayURL"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn playlist(
            &mut self,
            request: impl tonic::IntoRequest<super::PlaylistReq>,
        ) -> std::result::Result<tonic::Response<super::PlaylistResp>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/Playlist",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.listener.v1.Listener", "Playlist"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn playlist_add(
            &mut self,
            request: impl tonic::IntoRequest<super::PlaylistAddReq>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/PlaylistAdd",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.listener.v1.Listener", "PlaylistAdd"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn playlist_del(
            &mut self,
            request: impl tonic::IntoRequest<super::PlaylistDelReq>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/PlaylistDel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.listener.v1.Listener", "PlaylistDel"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn rcmd_playlist(
            &mut self,
            request: impl tonic::IntoRequest<super::RcmdPlaylistReq>,
        ) -> std::result::Result<
            tonic::Response<super::RcmdPlaylistResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/RcmdPlaylist",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.listener.v1.Listener", "RcmdPlaylist"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn thumb_up(
            &mut self,
            request: impl tonic::IntoRequest<super::ThumbUpReq>,
        ) -> std::result::Result<tonic::Response<super::ThumbUpResp>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/ThumbUp",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.listener.v1.Listener", "ThumbUp"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn triple_like(
            &mut self,
            request: impl tonic::IntoRequest<super::TripleLikeReq>,
        ) -> std::result::Result<tonic::Response<super::TripleLikeResp>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Listener/TripleLike",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.listener.v1.Listener", "TripleLike"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
#[cfg(feature = "feat-enable-generated-client")]
pub mod music_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct MusicClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> MusicClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MusicClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MusicClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn click(
            &mut self,
            request: impl tonic::IntoRequest<super::ClickReq>,
        ) -> std::result::Result<tonic::Response<super::ClickResp>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Music/Click",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.listener.v1.Music", "Click"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn fav_tab_show(
            &mut self,
            request: impl tonic::IntoRequest<super::FavTabShowReq>,
        ) -> std::result::Result<tonic::Response<super::FavTabShowResp>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Music/FavTabShow",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.listener.v1.Music", "FavTabShow"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn main_fav_music_menu_list(
            &mut self,
            request: impl tonic::IntoRequest<super::MainFavMusicMenuListReq>,
        ) -> std::result::Result<
            tonic::Response<super::MainFavMusicMenuListResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Music/MainFavMusicMenuList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.listener.v1.Music",
                        "MainFavMusicMenuList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn main_fav_music_sub_tab_list(
            &mut self,
            request: impl tonic::IntoRequest<super::MainFavMusicSubTabListReq>,
        ) -> std::result::Result<
            tonic::Response<super::MainFavMusicSubTabListResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Music/MainFavMusicSubTabList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.listener.v1.Music",
                        "MainFavMusicSubTabList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn menu_delete(
            &mut self,
            request: impl tonic::IntoRequest<super::MenuDeleteReq>,
        ) -> std::result::Result<tonic::Response<super::MenuDeleteResp>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Music/MenuDelete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.listener.v1.Music", "MenuDelete"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn menu_edit(
            &mut self,
            request: impl tonic::IntoRequest<super::MenuEditReq>,
        ) -> std::result::Result<tonic::Response<super::MenuEditResp>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Music/MenuEdit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.listener.v1.Music", "MenuEdit"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn menu_subscribe(
            &mut self,
            request: impl tonic::IntoRequest<super::MenuSubscribeReq>,
        ) -> std::result::Result<
            tonic::Response<super::MenuSubscribeResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.listener.v1.Music/MenuSubscribe",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.listener.v1.Music", "MenuSubscribe"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
#[cfg(feature = "feat-enable-generated-server")]
pub mod listener_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ListenerServer.
    #[async_trait]
    pub trait Listener: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn bk_arc_details(
            &self,
            request: tonic::Request<super::BkArcDetailsReq>,
        ) -> std::result::Result<
            tonic::Response<super::BkArcDetailsResp>,
            tonic::Status,
        >;
        ///
        async fn coin_add(
            &self,
            request: tonic::Request<super::CoinAddReq>,
        ) -> std::result::Result<tonic::Response<super::CoinAddResp>, tonic::Status>;
        ///
        async fn event(
            &self,
            request: tonic::Request<super::EventReq>,
        ) -> std::result::Result<tonic::Response<super::EventResp>, tonic::Status>;
        ///
        async fn fav_folder_create(
            &self,
            request: tonic::Request<super::FavFolderCreateReq>,
        ) -> std::result::Result<
            tonic::Response<super::FavFolderCreateResp>,
            tonic::Status,
        >;
        ///
        async fn fav_folder_delete(
            &self,
            request: tonic::Request<super::FavFolderDeleteReq>,
        ) -> std::result::Result<
            tonic::Response<super::FavFolderDeleteResp>,
            tonic::Status,
        >;
        ///
        async fn fav_folder_detail(
            &self,
            request: tonic::Request<super::FavFolderDetailReq>,
        ) -> std::result::Result<
            tonic::Response<super::FavFolderDetailResp>,
            tonic::Status,
        >;
        ///
        async fn fav_folder_list(
            &self,
            request: tonic::Request<super::FavFolderListReq>,
        ) -> std::result::Result<
            tonic::Response<super::FavFolderListResp>,
            tonic::Status,
        >;
        ///
        async fn fav_item_add(
            &self,
            request: tonic::Request<super::FavItemAddReq>,
        ) -> std::result::Result<tonic::Response<super::FavItemAddResp>, tonic::Status>;
        ///
        async fn fav_item_batch(
            &self,
            request: tonic::Request<super::FavItemBatchReq>,
        ) -> std::result::Result<
            tonic::Response<super::FavItemBatchResp>,
            tonic::Status,
        >;
        ///
        async fn fav_item_del(
            &self,
            request: tonic::Request<super::FavItemDelReq>,
        ) -> std::result::Result<tonic::Response<super::FavItemDelResp>, tonic::Status>;
        ///
        async fn favored_in_any_folders(
            &self,
            request: tonic::Request<super::FavoredInAnyFoldersReq>,
        ) -> std::result::Result<
            tonic::Response<super::FavoredInAnyFoldersResp>,
            tonic::Status,
        >;
        ///
        async fn medialist(
            &self,
            request: tonic::Request<super::MedialistReq>,
        ) -> std::result::Result<tonic::Response<super::MedialistResp>, tonic::Status>;
        ///
        async fn pick_card_detail(
            &self,
            request: tonic::Request<super::PickCardDetailReq>,
        ) -> std::result::Result<
            tonic::Response<super::PickCardDetailResp>,
            tonic::Status,
        >;
        ///
        async fn pick_feed(
            &self,
            request: tonic::Request<super::PickFeedReq>,
        ) -> std::result::Result<tonic::Response<super::PickFeedResp>, tonic::Status>;
        ///
        async fn ping(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        ///
        async fn play_action_report(
            &self,
            request: tonic::Request<super::PlayActionReportReq>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        ///
        async fn play_history(
            &self,
            request: tonic::Request<super::PlayHistoryReq>,
        ) -> std::result::Result<tonic::Response<super::PlayHistoryResp>, tonic::Status>;
        ///
        async fn play_history_add(
            &self,
            request: tonic::Request<super::PlayHistoryAddReq>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        ///
        async fn play_history_del(
            &self,
            request: tonic::Request<super::PlayHistoryDelReq>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        ///
        async fn play_url(
            &self,
            request: tonic::Request<super::PlayUrlReq>,
        ) -> std::result::Result<tonic::Response<super::PlayUrlResp>, tonic::Status>;
        ///
        async fn playlist(
            &self,
            request: tonic::Request<super::PlaylistReq>,
        ) -> std::result::Result<tonic::Response<super::PlaylistResp>, tonic::Status>;
        ///
        async fn playlist_add(
            &self,
            request: tonic::Request<super::PlaylistAddReq>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        ///
        async fn playlist_del(
            &self,
            request: tonic::Request<super::PlaylistDelReq>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        ///
        async fn rcmd_playlist(
            &self,
            request: tonic::Request<super::RcmdPlaylistReq>,
        ) -> std::result::Result<
            tonic::Response<super::RcmdPlaylistResp>,
            tonic::Status,
        >;
        ///
        async fn thumb_up(
            &self,
            request: tonic::Request<super::ThumbUpReq>,
        ) -> std::result::Result<tonic::Response<super::ThumbUpResp>, tonic::Status>;
        ///
        async fn triple_like(
            &self,
            request: tonic::Request<super::TripleLikeReq>,
        ) -> std::result::Result<tonic::Response<super::TripleLikeResp>, tonic::Status>;
    }
    ///
    #[derive(Debug)]
    pub struct ListenerServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ListenerServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ListenerServer<T>
    where
        T: Listener,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.app.listener.v1.Listener/BKArcDetails" => {
                    #[allow(non_camel_case_types)]
                    struct BKArcDetailsSvc<T: Listener>(pub Arc<T>);
                    impl<T: Listener> tonic::server::UnaryService<super::BkArcDetailsReq>
                    for BKArcDetailsSvc<T> {
                        type Response = super::BkArcDetailsResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BkArcDetailsReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::bk_arc_details(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BKArcDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/CoinAdd" => {
                    #[allow(non_camel_case_types)]
                    struct CoinAddSvc<T: Listener>(pub Arc<T>);
                    impl<T: Listener> tonic::server::UnaryService<super::CoinAddReq>
                    for CoinAddSvc<T> {
                        type Response = super::CoinAddResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CoinAddReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::coin_add(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CoinAddSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/Event" => {
                    #[allow(non_camel_case_types)]
                    struct EventSvc<T: Listener>(pub Arc<T>);
                    impl<T: Listener> tonic::server::UnaryService<super::EventReq>
                    for EventSvc<T> {
                        type Response = super::EventResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EventReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::event(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EventSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/FavFolderCreate" => {
                    #[allow(non_camel_case_types)]
                    struct FavFolderCreateSvc<T: Listener>(pub Arc<T>);
                    impl<
                        T: Listener,
                    > tonic::server::UnaryService<super::FavFolderCreateReq>
                    for FavFolderCreateSvc<T> {
                        type Response = super::FavFolderCreateResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FavFolderCreateReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::fav_folder_create(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FavFolderCreateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/FavFolderDelete" => {
                    #[allow(non_camel_case_types)]
                    struct FavFolderDeleteSvc<T: Listener>(pub Arc<T>);
                    impl<
                        T: Listener,
                    > tonic::server::UnaryService<super::FavFolderDeleteReq>
                    for FavFolderDeleteSvc<T> {
                        type Response = super::FavFolderDeleteResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FavFolderDeleteReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::fav_folder_delete(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FavFolderDeleteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/FavFolderDetail" => {
                    #[allow(non_camel_case_types)]
                    struct FavFolderDetailSvc<T: Listener>(pub Arc<T>);
                    impl<
                        T: Listener,
                    > tonic::server::UnaryService<super::FavFolderDetailReq>
                    for FavFolderDetailSvc<T> {
                        type Response = super::FavFolderDetailResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FavFolderDetailReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::fav_folder_detail(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FavFolderDetailSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/FavFolderList" => {
                    #[allow(non_camel_case_types)]
                    struct FavFolderListSvc<T: Listener>(pub Arc<T>);
                    impl<
                        T: Listener,
                    > tonic::server::UnaryService<super::FavFolderListReq>
                    for FavFolderListSvc<T> {
                        type Response = super::FavFolderListResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FavFolderListReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::fav_folder_list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FavFolderListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/FavItemAdd" => {
                    #[allow(non_camel_case_types)]
                    struct FavItemAddSvc<T: Listener>(pub Arc<T>);
                    impl<T: Listener> tonic::server::UnaryService<super::FavItemAddReq>
                    for FavItemAddSvc<T> {
                        type Response = super::FavItemAddResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FavItemAddReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::fav_item_add(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FavItemAddSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/FavItemBatch" => {
                    #[allow(non_camel_case_types)]
                    struct FavItemBatchSvc<T: Listener>(pub Arc<T>);
                    impl<T: Listener> tonic::server::UnaryService<super::FavItemBatchReq>
                    for FavItemBatchSvc<T> {
                        type Response = super::FavItemBatchResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FavItemBatchReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::fav_item_batch(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FavItemBatchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/FavItemDel" => {
                    #[allow(non_camel_case_types)]
                    struct FavItemDelSvc<T: Listener>(pub Arc<T>);
                    impl<T: Listener> tonic::server::UnaryService<super::FavItemDelReq>
                    for FavItemDelSvc<T> {
                        type Response = super::FavItemDelResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FavItemDelReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::fav_item_del(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FavItemDelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/FavoredInAnyFolders" => {
                    #[allow(non_camel_case_types)]
                    struct FavoredInAnyFoldersSvc<T: Listener>(pub Arc<T>);
                    impl<
                        T: Listener,
                    > tonic::server::UnaryService<super::FavoredInAnyFoldersReq>
                    for FavoredInAnyFoldersSvc<T> {
                        type Response = super::FavoredInAnyFoldersResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FavoredInAnyFoldersReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::favored_in_any_folders(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FavoredInAnyFoldersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/Medialist" => {
                    #[allow(non_camel_case_types)]
                    struct MedialistSvc<T: Listener>(pub Arc<T>);
                    impl<T: Listener> tonic::server::UnaryService<super::MedialistReq>
                    for MedialistSvc<T> {
                        type Response = super::MedialistResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MedialistReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::medialist(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MedialistSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/PickCardDetail" => {
                    #[allow(non_camel_case_types)]
                    struct PickCardDetailSvc<T: Listener>(pub Arc<T>);
                    impl<
                        T: Listener,
                    > tonic::server::UnaryService<super::PickCardDetailReq>
                    for PickCardDetailSvc<T> {
                        type Response = super::PickCardDetailResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PickCardDetailReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::pick_card_detail(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PickCardDetailSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/PickFeed" => {
                    #[allow(non_camel_case_types)]
                    struct PickFeedSvc<T: Listener>(pub Arc<T>);
                    impl<T: Listener> tonic::server::UnaryService<super::PickFeedReq>
                    for PickFeedSvc<T> {
                        type Response = super::PickFeedResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PickFeedReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::pick_feed(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PickFeedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/Ping" => {
                    #[allow(non_camel_case_types)]
                    struct PingSvc<T: Listener>(pub Arc<T>);
                    impl<T: Listener> tonic::server::UnaryService<()> for PingSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::ping(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/PlayActionReport" => {
                    #[allow(non_camel_case_types)]
                    struct PlayActionReportSvc<T: Listener>(pub Arc<T>);
                    impl<
                        T: Listener,
                    > tonic::server::UnaryService<super::PlayActionReportReq>
                    for PlayActionReportSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PlayActionReportReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::play_action_report(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PlayActionReportSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/PlayHistory" => {
                    #[allow(non_camel_case_types)]
                    struct PlayHistorySvc<T: Listener>(pub Arc<T>);
                    impl<T: Listener> tonic::server::UnaryService<super::PlayHistoryReq>
                    for PlayHistorySvc<T> {
                        type Response = super::PlayHistoryResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PlayHistoryReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::play_history(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PlayHistorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/PlayHistoryAdd" => {
                    #[allow(non_camel_case_types)]
                    struct PlayHistoryAddSvc<T: Listener>(pub Arc<T>);
                    impl<
                        T: Listener,
                    > tonic::server::UnaryService<super::PlayHistoryAddReq>
                    for PlayHistoryAddSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PlayHistoryAddReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::play_history_add(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PlayHistoryAddSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/PlayHistoryDel" => {
                    #[allow(non_camel_case_types)]
                    struct PlayHistoryDelSvc<T: Listener>(pub Arc<T>);
                    impl<
                        T: Listener,
                    > tonic::server::UnaryService<super::PlayHistoryDelReq>
                    for PlayHistoryDelSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PlayHistoryDelReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::play_history_del(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PlayHistoryDelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/PlayURL" => {
                    #[allow(non_camel_case_types)]
                    struct PlayURLSvc<T: Listener>(pub Arc<T>);
                    impl<T: Listener> tonic::server::UnaryService<super::PlayUrlReq>
                    for PlayURLSvc<T> {
                        type Response = super::PlayUrlResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PlayUrlReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::play_url(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PlayURLSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/Playlist" => {
                    #[allow(non_camel_case_types)]
                    struct PlaylistSvc<T: Listener>(pub Arc<T>);
                    impl<T: Listener> tonic::server::UnaryService<super::PlaylistReq>
                    for PlaylistSvc<T> {
                        type Response = super::PlaylistResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PlaylistReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::playlist(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PlaylistSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/PlaylistAdd" => {
                    #[allow(non_camel_case_types)]
                    struct PlaylistAddSvc<T: Listener>(pub Arc<T>);
                    impl<T: Listener> tonic::server::UnaryService<super::PlaylistAddReq>
                    for PlaylistAddSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PlaylistAddReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::playlist_add(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PlaylistAddSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/PlaylistDel" => {
                    #[allow(non_camel_case_types)]
                    struct PlaylistDelSvc<T: Listener>(pub Arc<T>);
                    impl<T: Listener> tonic::server::UnaryService<super::PlaylistDelReq>
                    for PlaylistDelSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PlaylistDelReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::playlist_del(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PlaylistDelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/RcmdPlaylist" => {
                    #[allow(non_camel_case_types)]
                    struct RcmdPlaylistSvc<T: Listener>(pub Arc<T>);
                    impl<T: Listener> tonic::server::UnaryService<super::RcmdPlaylistReq>
                    for RcmdPlaylistSvc<T> {
                        type Response = super::RcmdPlaylistResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RcmdPlaylistReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::rcmd_playlist(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RcmdPlaylistSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/ThumbUp" => {
                    #[allow(non_camel_case_types)]
                    struct ThumbUpSvc<T: Listener>(pub Arc<T>);
                    impl<T: Listener> tonic::server::UnaryService<super::ThumbUpReq>
                    for ThumbUpSvc<T> {
                        type Response = super::ThumbUpResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ThumbUpReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::thumb_up(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ThumbUpSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Listener/TripleLike" => {
                    #[allow(non_camel_case_types)]
                    struct TripleLikeSvc<T: Listener>(pub Arc<T>);
                    impl<T: Listener> tonic::server::UnaryService<super::TripleLikeReq>
                    for TripleLikeSvc<T> {
                        type Response = super::TripleLikeResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TripleLikeReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Listener>::triple_like(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TripleLikeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ListenerServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.app.listener.v1.Listener";
    impl<T> tonic::server::NamedService for ListenerServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
#[cfg(feature = "feat-enable-generated-server")]
pub mod music_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with MusicServer.
    #[async_trait]
    pub trait Music: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn click(
            &self,
            request: tonic::Request<super::ClickReq>,
        ) -> std::result::Result<tonic::Response<super::ClickResp>, tonic::Status>;
        ///
        async fn fav_tab_show(
            &self,
            request: tonic::Request<super::FavTabShowReq>,
        ) -> std::result::Result<tonic::Response<super::FavTabShowResp>, tonic::Status>;
        ///
        async fn main_fav_music_menu_list(
            &self,
            request: tonic::Request<super::MainFavMusicMenuListReq>,
        ) -> std::result::Result<
            tonic::Response<super::MainFavMusicMenuListResp>,
            tonic::Status,
        >;
        ///
        async fn main_fav_music_sub_tab_list(
            &self,
            request: tonic::Request<super::MainFavMusicSubTabListReq>,
        ) -> std::result::Result<
            tonic::Response<super::MainFavMusicSubTabListResp>,
            tonic::Status,
        >;
        ///
        async fn menu_delete(
            &self,
            request: tonic::Request<super::MenuDeleteReq>,
        ) -> std::result::Result<tonic::Response<super::MenuDeleteResp>, tonic::Status>;
        ///
        async fn menu_edit(
            &self,
            request: tonic::Request<super::MenuEditReq>,
        ) -> std::result::Result<tonic::Response<super::MenuEditResp>, tonic::Status>;
        ///
        async fn menu_subscribe(
            &self,
            request: tonic::Request<super::MenuSubscribeReq>,
        ) -> std::result::Result<
            tonic::Response<super::MenuSubscribeResp>,
            tonic::Status,
        >;
    }
    ///
    #[derive(Debug)]
    pub struct MusicServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> MusicServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for MusicServer<T>
    where
        T: Music,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.app.listener.v1.Music/Click" => {
                    #[allow(non_camel_case_types)]
                    struct ClickSvc<T: Music>(pub Arc<T>);
                    impl<T: Music> tonic::server::UnaryService<super::ClickReq>
                    for ClickSvc<T> {
                        type Response = super::ClickResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ClickReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Music>::click(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ClickSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Music/FavTabShow" => {
                    #[allow(non_camel_case_types)]
                    struct FavTabShowSvc<T: Music>(pub Arc<T>);
                    impl<T: Music> tonic::server::UnaryService<super::FavTabShowReq>
                    for FavTabShowSvc<T> {
                        type Response = super::FavTabShowResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FavTabShowReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Music>::fav_tab_show(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FavTabShowSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Music/MainFavMusicMenuList" => {
                    #[allow(non_camel_case_types)]
                    struct MainFavMusicMenuListSvc<T: Music>(pub Arc<T>);
                    impl<
                        T: Music,
                    > tonic::server::UnaryService<super::MainFavMusicMenuListReq>
                    for MainFavMusicMenuListSvc<T> {
                        type Response = super::MainFavMusicMenuListResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MainFavMusicMenuListReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Music>::main_fav_music_menu_list(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MainFavMusicMenuListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Music/MainFavMusicSubTabList" => {
                    #[allow(non_camel_case_types)]
                    struct MainFavMusicSubTabListSvc<T: Music>(pub Arc<T>);
                    impl<
                        T: Music,
                    > tonic::server::UnaryService<super::MainFavMusicSubTabListReq>
                    for MainFavMusicSubTabListSvc<T> {
                        type Response = super::MainFavMusicSubTabListResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MainFavMusicSubTabListReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Music>::main_fav_music_sub_tab_list(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MainFavMusicSubTabListSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Music/MenuDelete" => {
                    #[allow(non_camel_case_types)]
                    struct MenuDeleteSvc<T: Music>(pub Arc<T>);
                    impl<T: Music> tonic::server::UnaryService<super::MenuDeleteReq>
                    for MenuDeleteSvc<T> {
                        type Response = super::MenuDeleteResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MenuDeleteReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Music>::menu_delete(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MenuDeleteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Music/MenuEdit" => {
                    #[allow(non_camel_case_types)]
                    struct MenuEditSvc<T: Music>(pub Arc<T>);
                    impl<T: Music> tonic::server::UnaryService<super::MenuEditReq>
                    for MenuEditSvc<T> {
                        type Response = super::MenuEditResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MenuEditReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Music>::menu_edit(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MenuEditSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.listener.v1.Music/MenuSubscribe" => {
                    #[allow(non_camel_case_types)]
                    struct MenuSubscribeSvc<T: Music>(pub Arc<T>);
                    impl<T: Music> tonic::server::UnaryService<super::MenuSubscribeReq>
                    for MenuSubscribeSvc<T> {
                        type Response = super::MenuSubscribeResp;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MenuSubscribeReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Music>::menu_subscribe(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MenuSubscribeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for MusicServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.app.listener.v1.Music";
    impl<T> tonic::server::NamedService for MusicServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
