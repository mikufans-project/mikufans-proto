// This file is @generated by prost-build.
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Answer {
    ///
    #[prost(message, optional, tag = "1")]
    pub thinking: ::core::option::Option<Thinking>,
    ///
    #[prost(message, optional, tag = "2")]
    pub answer_text: ::core::option::Option<AnswerText>,
}
impl ::prost::Name for Answer {
    const NAME: &'static str = "Answer";
    const PACKAGE: &'static str = "bilibili.broadcast.message.deepsearch";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.message.deepsearch.Answer".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.message.deepsearch.Answer".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnswerParagraph {
    ///
    #[prost(bool, tag = "1")]
    pub embed: bool,
    ///
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<CardItem>,
}
impl ::prost::Name for AnswerParagraph {
    const NAME: &'static str = "AnswerParagraph";
    const PACKAGE: &'static str = "bilibili.broadcast.message.deepsearch";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.message.deepsearch.AnswerParagraph".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.message.deepsearch.AnswerParagraph".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnswerText {
    ///
    #[prost(message, repeated, tag = "1")]
    pub paragraphs: ::prost::alloc::vec::Vec<AnswerParagraph>,
}
impl ::prost::Name for AnswerText {
    const NAME: &'static str = "AnswerText";
    const PACKAGE: &'static str = "bilibili.broadcast.message.deepsearch";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.message.deepsearch.AnswerText".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.message.deepsearch.AnswerText".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthorCard {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub avatar: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub paragraph: ::core::option::Option<
        super::super::super::app::dynamic::v2::ModuleParagraph,
    >,
}
impl ::prost::Name for AuthorCard {
    const NAME: &'static str = "AuthorCard";
    const PACKAGE: &'static str = "bilibili.broadcast.message.deepsearch";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.message.deepsearch.AuthorCard".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.message.deepsearch.AuthorCard".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardItem {
    ///
    #[prost(enumeration = "card_item::CardType", tag = "1")]
    pub card_type: i32,
    ///
    #[prost(oneof = "card_item::CardItem", tags = "2, 3, 4, 5")]
    pub card_item: ::core::option::Option<card_item::CardItem>,
}
/// Nested message and enum types in `CardItem`.
pub mod card_item {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CardType {
        ///
        Invalid = 0,
        ///
        Author = 1,
        ///
        Video = 2,
        ///
        Text = 3,
        ///
        Picture = 4,
    }
    impl CardType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Invalid => "INVALID",
                Self::Author => "AUTHOR",
                Self::Video => "VIDEO",
                Self::Text => "TEXT",
                Self::Picture => "PICTURE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INVALID" => Some(Self::Invalid),
                "AUTHOR" => Some(Self::Author),
                "VIDEO" => Some(Self::Video),
                "TEXT" => Some(Self::Text),
                "PICTURE" => Some(Self::Picture),
                _ => None,
            }
        }
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CardItem {
        ///
        #[prost(message, tag = "2")]
        Author(super::AuthorCard),
        ///
        #[prost(message, tag = "3")]
        Video(super::VideoCard),
        ///
        #[prost(message, tag = "4")]
        Text(super::TextCard),
        ///
        #[prost(message, tag = "5")]
        Pictures(super::PictureCard),
    }
}
impl ::prost::Name for CardItem {
    const NAME: &'static str = "CardItem";
    const PACKAGE: &'static str = "bilibili.broadcast.message.deepsearch";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.message.deepsearch.CardItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.message.deepsearch.CardItem".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClipInfo {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
}
impl ::prost::Name for ClipInfo {
    const NAME: &'static str = "ClipInfo";
    const PACKAGE: &'static str = "bilibili.broadcast.message.deepsearch";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.message.deepsearch.ClipInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.message.deepsearch.ClipInfo".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeepSearchContent {
    ///
    #[prost(oneof = "deep_search_content::ContentItem", tags = "1, 2")]
    pub content_item: ::core::option::Option<deep_search_content::ContentItem>,
}
/// Nested message and enum types in `DeepSearchContent`.
pub mod deep_search_content {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ContentItem {
        ///
        #[prost(message, tag = "1")]
        Greetings(super::Greetings),
        ///
        #[prost(message, tag = "2")]
        Answer(super::Answer),
    }
}
impl ::prost::Name for DeepSearchContent {
    const NAME: &'static str = "DeepSearchContent";
    const PACKAGE: &'static str = "bilibili.broadcast.message.deepsearch";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.message.deepsearch.DeepSearchContent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.message.deepsearch.DeepSearchContent".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeepSearchResponse {
    ///
    #[prost(int32, tag = "1")]
    pub code: i32,
    ///
    #[prost(string, tag = "2")]
    pub session_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub query_id: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "ChatStatus", tag = "4")]
    pub status: i32,
    ///
    #[prost(message, optional, tag = "5")]
    pub deep_content: ::core::option::Option<DeepSearchContent>,
    ///
    #[prost(string, tag = "6")]
    pub chat_summary: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "7")]
    pub timestamp: i64,
}
impl ::prost::Name for DeepSearchResponse {
    const NAME: &'static str = "DeepSearchResponse";
    const PACKAGE: &'static str = "bilibili.broadcast.message.deepsearch";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.message.deepsearch.DeepSearchResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.message.deepsearch.DeepSearchResponse".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Greetings {
    ///
    #[prost(message, repeated, tag = "1")]
    pub paragraphs: ::prost::alloc::vec::Vec<
        super::super::super::app::dynamic::v2::ModuleParagraph,
    >,
}
impl ::prost::Name for Greetings {
    const NAME: &'static str = "Greetings";
    const PACKAGE: &'static str = "bilibili.broadcast.message.deepsearch";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.message.deepsearch.Greetings".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.message.deepsearch.Greetings".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PictureCard {
    ///
    #[prost(enumeration = "picture_card::Source", tag = "1")]
    pub source: i32,
    ///
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<PictureCardItem>,
    ///
    #[prost(string, tag = "3")]
    pub biz_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `PictureCard`.
pub mod picture_card {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        ///
        Default = 0,
        ///
        VideoSource = 1,
        ///
        Reply = 2,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Default => "DEFAULT",
                Self::VideoSource => "VIDEO_Source",
                Self::Reply => "REPLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEFAULT" => Some(Self::Default),
                "VIDEO_Source" => Some(Self::VideoSource),
                "REPLY" => Some(Self::Reply),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for PictureCard {
    const NAME: &'static str = "PictureCard";
    const PACKAGE: &'static str = "bilibili.broadcast.message.deepsearch";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.message.deepsearch.PictureCard".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.message.deepsearch.PictureCard".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PictureCardItem {
    ///
    #[prost(string, tag = "1")]
    pub src: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub width: i64,
    ///
    #[prost(int64, tag = "3")]
    pub height: i64,
    ///
    #[prost(message, optional, tag = "4")]
    pub preview: ::core::option::Option<PictureCardPreview>,
}
impl ::prost::Name for PictureCardItem {
    const NAME: &'static str = "PictureCardItem";
    const PACKAGE: &'static str = "bilibili.broadcast.message.deepsearch";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.message.deepsearch.PictureCardItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.message.deepsearch.PictureCardItem".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PictureCardPreview {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub start_time: i64,
    ///
    #[prost(string, tag = "3")]
    pub jump_url_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub jump_icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub card: ::core::option::Option<CardItem>,
}
impl ::prost::Name for PictureCardPreview {
    const NAME: &'static str = "PictureCardPreview";
    const PACKAGE: &'static str = "bilibili.broadcast.message.deepsearch";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.message.deepsearch.PictureCardPreview".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.message.deepsearch.PictureCardPreview".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextCard {
    ///
    #[prost(message, optional, tag = "1")]
    pub paragraph: ::core::option::Option<
        super::super::super::app::dynamic::v2::ModuleParagraph,
    >,
}
impl ::prost::Name for TextCard {
    const NAME: &'static str = "TextCard";
    const PACKAGE: &'static str = "bilibili.broadcast.message.deepsearch";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.message.deepsearch.TextCard".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.message.deepsearch.TextCard".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Thinking {
    ///
    #[prost(enumeration = "thinking::Status", tag = "1")]
    pub status: i32,
    ///
    #[prost(string, tag = "2")]
    pub thinking_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub window_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub thinking_content: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Thinking`.
pub mod thinking {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        ///
        InvalidStatus = 0,
        ///
        Thinking = 1,
        ///
        FinishStatus = 2,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::InvalidStatus => "INVALID_Status",
                Self::Thinking => "THINKING",
                Self::FinishStatus => "FINISH_Status",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INVALID_Status" => Some(Self::InvalidStatus),
                "THINKING" => Some(Self::Thinking),
                "FINISH_Status" => Some(Self::FinishStatus),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Thinking {
    const NAME: &'static str = "Thinking";
    const PACKAGE: &'static str = "bilibili.broadcast.message.deepsearch";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.message.deepsearch.Thinking".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.message.deepsearch.Thinking".into()
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoCard {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub card_desc: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "7")]
    pub clip_info: ::core::option::Option<ClipInfo>,
}
impl ::prost::Name for VideoCard {
    const NAME: &'static str = "VideoCard";
    const PACKAGE: &'static str = "bilibili.broadcast.message.deepsearch";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.broadcast.message.deepsearch.VideoCard".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.broadcast.message.deepsearch.VideoCard".into()
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChatStatus {
    ///
    InvalidChatStatus = 0,
    ///
    Start = 1,
    ///
    Common = 2,
    ///
    Finish = 3,
    ///
    Stop = 4,
    ///
    Placeholder = 5,
}
impl ChatStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::InvalidChatStatus => "INVALID_ChatStatus",
            Self::Start => "START",
            Self::Common => "COMMON",
            Self::Finish => "FINISH",
            Self::Stop => "STOP",
            Self::Placeholder => "PLACEHOLDER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INVALID_ChatStatus" => Some(Self::InvalidChatStatus),
            "START" => Some(Self::Start),
            "COMMON" => Some(Self::Common),
            "FINISH" => Some(Self::Finish),
            "STOP" => Some(Self::Stop),
            "PLACEHOLDER" => Some(Self::Placeholder),
            _ => None,
        }
    }
}
