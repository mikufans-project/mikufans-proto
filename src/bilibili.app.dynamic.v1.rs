// This file is @generated by prost-build.
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdInfo {
    ///
    #[prost(string, tag = "1")]
    pub nation_code: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub adcode: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub city_code: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub gps: ::core::option::Option<Gps>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddressComponent {
    ///
    #[prost(string, tag = "1")]
    pub nation: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub province: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub city: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub district: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub street: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub street_number: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BubbleInfo {
    ///
    #[prost(message, repeated, tag = "1")]
    pub modules: ::prost::alloc::vec::Vec<BubbleModule>,
    ///
    #[prost(string, tag = "2")]
    pub track_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub bubble_recall_extra_when_show: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BubbleModule {
    ///
    #[prost(enumeration = "BubbleModuleType", tag = "1")]
    pub module_type: i32,
    ///
    #[prost(oneof = "bubble_module::Module", tags = "2, 3, 4, 5")]
    pub module: ::core::option::Option<bubble_module::Module>,
}
/// Nested message and enum types in `BubbleModule`.
pub mod bubble_module {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Module {
        ///
        #[prost(message, tag = "2")]
        User(super::BubbleModuleUser),
        ///
        #[prost(message, tag = "3")]
        Text(super::BubbleModuleText),
        ///
        #[prost(message, tag = "4")]
        ColoredTip(super::BubbleModuleColoredTip),
        ///
        #[prost(message, tag = "5")]
        Pic(super::BubbleModulePic),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BubbleModuleColoredTip {
    ///
    #[prost(string, tag = "1")]
    pub prefix_icon: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "2")]
    pub is_svga_prefix_icon: bool,
    ///
    #[prost(string, tag = "3")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub text_color: ::core::option::Option<Color>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BubbleModulePic {
    ///
    #[prost(string, tag = "1")]
    pub pic_day: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub pic_night: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub pic_width: i64,
    ///
    #[prost(int64, tag = "4")]
    pub pic_height: i64,
    ///
    #[prost(bool, tag = "5")]
    pub rounded_corner: bool,
    ///
    #[prost(int64, tag = "6")]
    pub rounded_corner_radius: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BubbleModuleText {
    ///
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BubbleModuleUser {
    ///
    #[prost(message, repeated, tag = "1")]
    pub users: ::prost::alloc::vec::Vec<UserInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardCurrBatch {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub text1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub text2: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub badge: ::core::option::Option<VideoBadge>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardCurrSeason {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub text1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub badge: ::core::option::Option<VideoBadge>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardPgc {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub cover_left_text1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover_left_text2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub cover_left_text3: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "7")]
    pub cid: i64,
    ///
    #[prost(int64, tag = "8")]
    pub season_id: i64,
    ///
    #[prost(int64, tag = "9")]
    pub epid: i64,
    ///
    #[prost(int64, tag = "10")]
    pub aid: i64,
    ///
    #[prost(enumeration = "MediaType", tag = "11")]
    pub media_type: i32,
    ///
    #[prost(enumeration = "VideoSubType", tag = "12")]
    pub sub_type: i32,
    ///
    #[prost(int32, tag = "13")]
    pub is_preview: i32,
    ///
    #[prost(message, optional, tag = "14")]
    pub dimension: ::core::option::Option<Dimension>,
    ///
    #[prost(message, repeated, tag = "15")]
    pub badge: ::prost::alloc::vec::Vec<VideoBadge>,
    ///
    #[prost(int32, tag = "16")]
    pub can_play: i32,
    ///
    #[prost(message, optional, tag = "17")]
    pub season: ::core::option::Option<PgcSeason>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardUgc {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub cover_left_text1: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover_left_text2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub cover_left_text3: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "7")]
    pub avid: i64,
    ///
    #[prost(int64, tag = "8")]
    pub cid: i64,
    ///
    #[prost(enumeration = "MediaType", tag = "9")]
    pub media_type: i32,
    ///
    #[prost(message, optional, tag = "10")]
    pub dimension: ::core::option::Option<Dimension>,
    ///
    #[prost(message, repeated, tag = "11")]
    pub badge: ::prost::alloc::vec::Vec<VideoBadge>,
    ///
    #[prost(int32, tag = "12")]
    pub can_play: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Color {
    ///
    #[prost(string, tag = "1")]
    pub color_day: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub color_night: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CornerInfo {
    ///
    #[prost(enumeration = "CornerType", tag = "1")]
    pub corner_type: i32,
    ///
    #[prost(string, tag = "2")]
    pub corner_text: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub corner_text_color: ::core::option::Option<Color>,
    ///
    #[prost(message, optional, tag = "4")]
    pub corner_text_bg_color: ::core::option::Option<Color>,
    ///
    #[prost(string, tag = "5")]
    pub corner_icon: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "6")]
    pub corner_number: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecoCardFan {
    ///
    #[prost(int32, tag = "1")]
    pub is_fan: i32,
    ///
    #[prost(int32, tag = "2")]
    pub number: i32,
    ///
    #[prost(string, tag = "3")]
    pub color: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecorateCard {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub card_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub jump_url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub fan: ::core::option::Option<DecoCardFan>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Description {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub emoji_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub goods_type: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Dimension {
    ///
    #[prost(int64, tag = "1")]
    pub height: i64,
    ///
    #[prost(int64, tag = "2")]
    pub width: i64,
    ///
    #[prost(int64, tag = "3")]
    pub rotate: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynDetailsReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<DynamicItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynDetailsReq {
    ///
    #[prost(int32, tag = "1")]
    pub teenagers_mode: i32,
    ///
    #[prost(string, tag = "2")]
    pub dynamic_ids: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub qn: i32,
    ///
    #[prost(int32, tag = "4")]
    pub fnver: i32,
    ///
    #[prost(int32, tag = "5")]
    pub fnval: i32,
    ///
    #[prost(int32, tag = "6")]
    pub force_host: i32,
    ///
    #[prost(int32, tag = "7")]
    pub fourk: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynMixUpListSearchReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<MixUpListItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynMixUpListSearchReq {
    ///
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynMixUpListViewMoreReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<MixUpListItem>,
    ///
    #[prost(string, tag = "2")]
    pub search_default_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynOurCityItem {
    ///
    #[prost(string, tag = "1")]
    pub card_type: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub dyn_id: i64,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "4")]
    pub modules: ::prost::alloc::vec::Vec<DynOurCityModule>,
    ///
    #[prost(int64, tag = "5")]
    pub rid: i64,
    ///
    #[prost(string, tag = "6")]
    pub debug_info: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynOurCityModule {
    ///
    #[prost(string, tag = "1")]
    pub module_type: ::prost::alloc::string::String,
    ///
    #[prost(oneof = "dyn_our_city_module::ModuleItem", tags = "2, 3, 4, 5")]
    pub module_item: ::core::option::Option<dyn_our_city_module::ModuleItem>,
}
/// Nested message and enum types in `DynOurCityModule`.
pub mod dyn_our_city_module {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ModuleItem {
        ///
        #[prost(message, tag = "2")]
        ModuleCover(super::DynOurCityModuleCover),
        ///
        #[prost(message, tag = "3")]
        ModuleDesc(super::DynOurCityModuleDesc),
        ///
        #[prost(message, tag = "4")]
        ModuleAuthor(super::DynOurCityModuleAuthor),
        ///
        #[prost(message, tag = "5")]
        ModuleExtend(super::DynOurCityModuleExtend),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynOurCityModuleAuthor {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynOurCityModuleCover {
    ///
    #[prost(string, repeated, tag = "1")]
    pub covers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(int32, tag = "2")]
    pub style: i32,
    ///
    #[prost(int32, tag = "3")]
    pub cover_left_icon1: i32,
    ///
    #[prost(string, tag = "4")]
    pub cover_left_text1: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "5")]
    pub cover_left_icon2: i32,
    ///
    #[prost(string, tag = "6")]
    pub cover_left_text2: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub cover_left_text3: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "8")]
    pub badge: ::prost::alloc::vec::Vec<VideoBadge>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynOurCityModuleDesc {
    ///
    #[prost(string, tag = "1")]
    pub desc: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynOurCityModuleExtend {
    ///
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    ///
    #[prost(oneof = "dyn_our_city_module_extend::Extend", tags = "2")]
    pub extend: ::core::option::Option<dyn_our_city_module_extend::Extend>,
}
/// Nested message and enum types in `DynOurCityModuleExtend`.
pub mod dyn_our_city_module_extend {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Extend {
        ///
        #[prost(message, tag = "2")]
        ExtendLbs(super::DynOurCityModuleExtendLbs),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynOurCityModuleExtendLbs {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "4")]
    pub poi_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynOurCityReply {
    ///
    #[prost(string, tag = "1")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "2")]
    pub has_more: i32,
    ///
    #[prost(int32, tag = "3")]
    pub style: i32,
    ///
    #[prost(string, tag = "4")]
    pub top_label: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "5")]
    pub list: ::prost::alloc::vec::Vec<DynOurCityItem>,
    ///
    #[prost(string, tag = "6")]
    pub top_button_label: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "7")]
    pub city_id: i32,
    ///
    #[prost(string, tag = "8")]
    pub city_name: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynOurCityReq {
    ///
    #[prost(int64, tag = "1")]
    pub city_id: i64,
    ///
    #[prost(double, tag = "2")]
    pub lat: f64,
    ///
    #[prost(double, tag = "3")]
    pub lng: f64,
    ///
    #[prost(string, tag = "4")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "5")]
    pub page_size: i32,
    ///
    #[prost(int32, tag = "6")]
    pub teenagers_mode: i32,
    ///
    #[prost(int32, tag = "7")]
    pub qn: i32,
    ///
    #[prost(int32, tag = "8")]
    pub fnver: i32,
    ///
    #[prost(int32, tag = "9")]
    pub fnval: i32,
    ///
    #[prost(int32, tag = "10")]
    pub force_host: i32,
    ///
    #[prost(int32, tag = "11")]
    pub fourk: i32,
    ///
    #[prost(int32, tag = "12")]
    pub lbs_state: i32,
    ///
    #[prost(int32, tag = "13")]
    pub refresh_city: i32,
    ///
    #[prost(message, optional, tag = "14")]
    pub exp_conf: ::core::option::Option<ExpConf>,
    ///
    #[prost(message, optional, tag = "15")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(int64, tag = "16")]
    pub city_code: i64,
    ///
    #[prost(int64, tag = "17")]
    pub build_time: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DynOurCitySwitchReq {
    ///
    #[prost(int32, tag = "1")]
    pub switch: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DynRedItem {
    ///
    #[prost(int64, tag = "1")]
    pub count: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynRedReply {
    ///
    #[prost(string, tag = "1")]
    pub red_type: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub dyn_red_item: ::core::option::Option<DynRedItem>,
    ///
    #[prost(string, tag = "3")]
    pub default_tab: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub red_style: ::core::option::Option<DynRedStyle>,
    ///
    #[prost(string, tag = "5")]
    pub tab_recall_extra: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub bubble_info: ::core::option::Option<BubbleInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynRedReq {
    ///
    #[prost(message, repeated, tag = "1")]
    pub tab_offset: ::prost::alloc::vec::Vec<TabOffset>,
    ///
    #[prost(bool, tag = "2")]
    pub is_new_install: bool,
    ///
    #[prost(bool, tag = "3")]
    pub is_code_start: bool,
    ///
    #[prost(int64, repeated, tag = "4")]
    pub new_follow_up_mids: ::prost::alloc::vec::Vec<i64>,
    ///
    #[prost(enumeration = "dyn_red_req::DynRedReqScene", tag = "5")]
    pub req_scene: i32,
}
/// Nested message and enum types in `DynRedReq`.
pub mod dyn_red_req {
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DynRedReqScene {
        ///
        RedReqNone = 0,
        ///
        RedReqReturnToTab1 = 1,
        ///
        RedReqPeriodicallyAwake = 2,
        ///
        RedReqSwitchAccount = 3,
    }
    impl DynRedReqScene {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::RedReqNone => "RED_REQ_NONE",
                Self::RedReqReturnToTab1 => "RED_REQ_RETURN_TO_TAB_1",
                Self::RedReqPeriodicallyAwake => "RED_REQ_PERIODICALLY_AWAKE",
                Self::RedReqSwitchAccount => "RED_REQ_SWITCH_ACCOUNT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RED_REQ_NONE" => Some(Self::RedReqNone),
                "RED_REQ_RETURN_TO_TAB_1" => Some(Self::RedReqReturnToTab1),
                "RED_REQ_PERIODICALLY_AWAKE" => Some(Self::RedReqPeriodicallyAwake),
                "RED_REQ_SWITCH_ACCOUNT" => Some(Self::RedReqSwitchAccount),
                _ => None,
            }
        }
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynRedStyle {
    ///
    #[prost(enumeration = "BgType", tag = "1")]
    pub bg_type: i32,
    ///
    #[prost(enumeration = "CornerType", tag = "2")]
    pub corner_type: i32,
    ///
    #[prost(int32, tag = "3")]
    pub display_time: i32,
    ///
    #[prost(string, tag = "4")]
    pub corner_mark: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub up: ::core::option::Option<DynRedStyleUp>,
    ///
    #[prost(enumeration = "StyleType", tag = "6")]
    pub r#type: i32,
    ///
    #[prost(message, optional, tag = "7")]
    pub corner_info: ::core::option::Option<CornerInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynRedStyleUp {
    ///
    #[prost(int64, tag = "1")]
    pub uid: i64,
    ///
    #[prost(string, tag = "2")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "StyleType", tag = "3")]
    pub face_type: i32,
    ///
    #[prost(message, optional, tag = "4")]
    pub border_color: ::core::option::Option<Color>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynTab {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub bubble: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "4")]
    pub red_point: i32,
    ///
    #[prost(int64, tag = "5")]
    pub city_id: i64,
    ///
    #[prost(int32, tag = "6")]
    pub is_popup: i32,
    ///
    #[prost(message, optional, tag = "7")]
    pub popup: ::core::option::Option<Popup>,
    ///
    #[prost(bool, tag = "8")]
    pub default_tab: bool,
    ///
    #[prost(string, tag = "9")]
    pub sub_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub anchor: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "11")]
    pub internal_test: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynTabReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub dyn_tab: ::prost::alloc::vec::Vec<DynTab>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DynTabReq {
    ///
    #[prost(int32, tag = "1")]
    pub teenagers_mode: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynUpdOffsetReq {
    ///
    #[prost(int64, tag = "1")]
    pub host_uid: i64,
    ///
    #[prost(string, tag = "2")]
    pub read_offset: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynVideoPersonalReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<DynamicItem>,
    ///
    #[prost(string, tag = "2")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub has_more: i32,
    ///
    #[prost(string, tag = "4")]
    pub read_offset: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynVideoPersonalReq {
    ///
    #[prost(int32, tag = "1")]
    pub teenagers_mode: i32,
    ///
    #[prost(int64, tag = "2")]
    pub host_uid: i64,
    ///
    #[prost(string, tag = "3")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "4")]
    pub page: i32,
    ///
    #[prost(int32, tag = "5")]
    pub is_preload: i32,
    ///
    #[prost(int32, tag = "6")]
    pub qn: i32,
    ///
    #[prost(int32, tag = "7")]
    pub fnver: i32,
    ///
    #[prost(int32, tag = "8")]
    pub fnval: i32,
    ///
    #[prost(int32, tag = "9")]
    pub force_host: i32,
    ///
    #[prost(int32, tag = "10")]
    pub fourk: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynVideoReq {
    ///
    #[prost(int32, tag = "1")]
    pub teenagers_mode: i32,
    ///
    #[prost(string, tag = "2")]
    pub update_baseline: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "4")]
    pub page: i32,
    ///
    #[prost(int32, tag = "5")]
    pub refresh_type: i32,
    ///
    #[prost(int32, tag = "6")]
    pub qn: i32,
    ///
    #[prost(int32, tag = "7")]
    pub fnver: i32,
    ///
    #[prost(int32, tag = "8")]
    pub fnval: i32,
    ///
    #[prost(int32, tag = "9")]
    pub force_host: i32,
    ///
    #[prost(int32, tag = "10")]
    pub fourk: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynVideoReqReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<DynamicItem>,
    ///
    #[prost(int32, tag = "2")]
    pub update_num: i32,
    ///
    #[prost(string, tag = "3")]
    pub history_offset: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub update_baseline: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "5")]
    pub has_more: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynamicItem {
    ///
    #[prost(string, tag = "1")]
    pub card_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub item_type: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub modules: ::prost::alloc::vec::Vec<Module>,
    ///
    #[prost(string, tag = "4")]
    pub dyn_id_str: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub orig_dyn_id_str: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "6")]
    pub r_type: i32,
    ///
    #[prost(int32, tag = "7")]
    pub has_fold: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Exp {
    ///
    #[prost(string, tag = "1")]
    pub exp_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub exp_group: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpConf {
    ///
    #[prost(int32, tag = "1")]
    pub exp_enable: i32,
    ///
    #[prost(message, repeated, tag = "2")]
    pub exps: ::prost::alloc::vec::Vec<Exp>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtInfoGame {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtInfoHot {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtInfoLbs {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "4")]
    pub poi_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtInfoTopic {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub icon: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Extend {
    ///
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    ///
    #[prost(oneof = "extend::Extend", tags = "2, 3, 4, 5")]
    pub extend: ::core::option::Option<extend::Extend>,
}
/// Nested message and enum types in `Extend`.
pub mod extend {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Extend {
        ///
        #[prost(message, tag = "2")]
        ExtInfoTopic(super::ExtInfoTopic),
        ///
        #[prost(message, tag = "3")]
        ExtInfoLbs(super::ExtInfoLbs),
        ///
        #[prost(message, tag = "4")]
        ExtInfoHot(super::ExtInfoHot),
        ///
        #[prost(message, tag = "5")]
        ExtInfoGame(super::ExtInfoGame),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FollowListItem {
    ///
    #[prost(int32, tag = "1")]
    pub season_id: i32,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub new_ep: ::core::option::Option<NewEp>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoCoderReply {
    ///
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub address_component: ::core::option::Option<AddressComponent>,
    ///
    #[prost(message, optional, tag = "3")]
    pub ad_info: ::core::option::Option<AdInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeoCoderReq {
    ///
    #[prost(double, tag = "1")]
    pub lat: f64,
    ///
    #[prost(double, tag = "2")]
    pub lng: f64,
    ///
    #[prost(string, tag = "3")]
    pub from: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Gps {
    ///
    #[prost(double, tag = "1")]
    pub lat: f64,
    ///
    #[prost(double, tag = "2")]
    pub lng: f64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LikeAnimation {
    ///
    #[prost(string, tag = "1")]
    pub begin: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub proc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub end: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub like_icon_id: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LikeInfo {
    ///
    #[prost(message, optional, tag = "1")]
    pub animation: ::core::option::Option<LikeAnimation>,
    ///
    #[prost(int32, tag = "2")]
    pub is_like: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LikeUser {
    ///
    #[prost(int64, tag = "1")]
    pub uid: i64,
    ///
    #[prost(string, tag = "2")]
    pub uname: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiveInfo {
    ///
    #[prost(int32, tag = "1")]
    pub is_living: i32,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MixUpListItem {
    ///
    #[prost(int64, tag = "1")]
    pub uid: i64,
    ///
    #[prost(int32, tag = "2")]
    pub special_attention: i32,
    ///
    #[prost(int32, tag = "3")]
    pub reddot_state: i32,
    ///
    #[prost(message, optional, tag = "4")]
    pub live_info: ::core::option::Option<MixUpListLiveItem>,
    ///
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "7")]
    pub official: ::core::option::Option<OfficialVerify>,
    ///
    #[prost(message, optional, tag = "8")]
    pub vip: ::core::option::Option<VipInfo>,
    ///
    #[prost(message, optional, tag = "9")]
    pub relation: ::core::option::Option<Relation>,
    ///
    #[prost(int32, tag = "10")]
    pub premiere_state: i32,
    ///
    #[prost(string, tag = "11")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MixUpListLiveItem {
    ///
    #[prost(bool, tag = "1")]
    pub status: bool,
    ///
    #[prost(int64, tag = "2")]
    pub room_id: i64,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Module {
    ///
    #[prost(string, tag = "1")]
    pub module_type: ::prost::alloc::string::String,
    ///
    #[prost(oneof = "module::ModuleItem", tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12")]
    pub module_item: ::core::option::Option<module::ModuleItem>,
}
/// Nested message and enum types in `Module`.
pub mod module {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ModuleItem {
        ///
        #[prost(message, tag = "2")]
        ModuleFold(super::ModuleFold),
        ///
        #[prost(message, tag = "3")]
        ModuleAuthor(super::ModuleAuthor),
        ///
        #[prost(message, tag = "4")]
        ModuleDynamic(super::ModuleDynamic),
        ///
        #[prost(message, tag = "5")]
        ModuleState(super::ModuleState),
        ///
        #[prost(message, tag = "6")]
        ModuleForward(super::ModuleForward),
        ///
        #[prost(message, tag = "7")]
        ModuleExtend(super::ModuleExtend),
        ///
        #[prost(message, tag = "8")]
        ModuleDispute(super::ModuleDispute),
        ///
        #[prost(message, tag = "9")]
        ModuleDesc(super::ModuleDesc),
        ///
        #[prost(message, tag = "10")]
        ModuleLikeUser(super::ModuleLikeUser),
        ///
        #[prost(message, tag = "11")]
        ModuleUpList(super::ModuleDynUpList),
        ///
        #[prost(message, tag = "12")]
        ModuleFollowList(super::ModuleFollowList),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleAuthor {
    ///
    #[prost(int64, tag = "1")]
    pub id: i64,
    ///
    #[prost(string, tag = "2")]
    pub ptime_label_text: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub author: ::core::option::Option<UserInfo>,
    ///
    #[prost(message, optional, tag = "4")]
    pub decorate_card: ::core::option::Option<DecorateCard>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleDesc {
    ///
    #[prost(message, repeated, tag = "1")]
    pub desc: ::prost::alloc::vec::Vec<Description>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleDispute {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleDynUpList {
    ///
    #[prost(string, tag = "1")]
    pub module_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub show_all: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "3")]
    pub list: ::prost::alloc::vec::Vec<UpListItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleDynamic {
    ///
    #[prost(string, tag = "1")]
    pub card_type: ::prost::alloc::string::String,
    ///
    #[prost(oneof = "module_dynamic::Card", tags = "2, 3, 4, 5")]
    pub card: ::core::option::Option<module_dynamic::Card>,
}
/// Nested message and enum types in `ModuleDynamic`.
pub mod module_dynamic {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Card {
        ///
        #[prost(message, tag = "2")]
        CardUgc(super::CardUgc),
        ///
        #[prost(message, tag = "3")]
        CardPgc(super::CardPgc),
        ///
        #[prost(message, tag = "4")]
        CardCurrSeason(super::CardCurrSeason),
        ///
        #[prost(message, tag = "5")]
        CardCurrBatch(super::CardCurrBatch),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleExtend {
    ///
    #[prost(message, repeated, tag = "1")]
    pub extend: ::prost::alloc::vec::Vec<Extend>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleFold {
    ///
    #[prost(enumeration = "FoldType", tag = "1")]
    pub fold_type: i32,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub fold_ids: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "4")]
    pub fold_users: ::prost::alloc::vec::Vec<UserInfo>,
    ///
    #[prost(enumeration = "FoldType", tag = "5")]
    pub fold_type_v2: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleFollowList {
    ///
    #[prost(string, tag = "1")]
    pub view_all_link: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub list: ::prost::alloc::vec::Vec<FollowListItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleForward {
    ///
    #[prost(string, tag = "1")]
    pub card_type: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub modules: ::prost::alloc::vec::Vec<Module>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleLikeUser {
    ///
    #[prost(message, repeated, tag = "1")]
    pub like_users: ::prost::alloc::vec::Vec<LikeUser>,
    ///
    #[prost(string, tag = "2")]
    pub display_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleState {
    ///
    #[prost(int32, tag = "1")]
    pub repost: i32,
    ///
    #[prost(int32, tag = "2")]
    pub like: i32,
    ///
    #[prost(int32, tag = "3")]
    pub reply: i32,
    ///
    #[prost(message, optional, tag = "4")]
    pub like_info: ::core::option::Option<LikeInfo>,
    ///
    #[prost(bool, tag = "5")]
    pub no_comment: bool,
    ///
    #[prost(bool, tag = "6")]
    pub no_forward: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Nameplate {
    ///
    #[prost(int64, tag = "1")]
    pub nid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub image: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub image_small: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub level: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub condition: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewEp {
    ///
    #[prost(int32, tag = "1")]
    pub id: i32,
    ///
    #[prost(string, tag = "2")]
    pub index_show: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub cover: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NoReply {}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NoReq {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OfficialVerify {
    ///
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub is_atten: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OurCityClickReportReply {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OurCityClickReportReq {
    ///
    #[prost(string, tag = "1")]
    pub dynamic_id: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub city_id: i64,
    ///
    #[prost(double, tag = "3")]
    pub lat: f64,
    ///
    #[prost(double, tag = "4")]
    pub lng: f64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PgcSeason {
    ///
    #[prost(int32, tag = "1")]
    pub is_finish: i32,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub r#type: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerPreloadParams {
    ///
    #[prost(int32, tag = "1")]
    pub qn: i32,
    ///
    #[prost(int32, tag = "2")]
    pub fnver: i32,
    ///
    #[prost(int32, tag = "3")]
    pub fnval: i32,
    ///
    #[prost(int32, tag = "4")]
    pub force_host: i32,
    ///
    #[prost(int32, tag = "5")]
    pub fourk: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Popup {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Relation {
    ///
    #[prost(enumeration = "RelationStatus", tag = "1")]
    pub status: i32,
    ///
    #[prost(int32, tag = "2")]
    pub is_follow: i32,
    ///
    #[prost(int32, tag = "3")]
    pub is_followed: i32,
    ///
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SVideoItem {
    ///
    #[prost(string, tag = "1")]
    pub card_type: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub modules: ::prost::alloc::vec::Vec<SVideoModule>,
    ///
    #[prost(string, tag = "3")]
    pub dyn_id_str: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub index: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SVideoModule {
    ///
    #[prost(string, tag = "1")]
    pub module_type: ::prost::alloc::string::String,
    ///
    #[prost(oneof = "s_video_module::ModuleItem", tags = "2, 3, 4, 5")]
    pub module_item: ::core::option::Option<s_video_module::ModuleItem>,
}
/// Nested message and enum types in `SVideoModule`.
pub mod s_video_module {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ModuleItem {
        ///
        #[prost(message, tag = "2")]
        ModuleAuthor(super::SVideoModuleAuthor),
        ///
        #[prost(message, tag = "3")]
        ModulePlayer(super::SVideoModulePlayer),
        ///
        #[prost(message, tag = "4")]
        ModuleDesc(super::SVideoModuleDesc),
        ///
        #[prost(message, tag = "5")]
        ModuleStat(super::SVideoModuleStat),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SVideoModuleAuthor {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub pub_desc: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "5")]
    pub is_attention: i32,
    ///
    #[prost(string, tag = "6")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SVideoModuleDesc {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SVideoModulePlayer {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub aid: i64,
    ///
    #[prost(int64, tag = "5")]
    pub cid: i64,
    ///
    #[prost(int64, tag = "6")]
    pub duration: i64,
    ///
    #[prost(message, optional, tag = "7")]
    pub dimension: ::core::option::Option<Dimension>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SVideoModuleStat {
    ///
    #[prost(message, repeated, tag = "1")]
    pub stat_info: ::prost::alloc::vec::Vec<SVideoStatInfo>,
    ///
    #[prost(message, optional, tag = "2")]
    pub share_info: ::core::option::Option<ShareInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SVideoReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<SVideoItem>,
    ///
    #[prost(string, tag = "2")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub has_more: i32,
    ///
    #[prost(message, optional, tag = "4")]
    pub top: ::core::option::Option<SVideoTop>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SVideoReq {
    ///
    #[prost(int64, tag = "1")]
    pub oid: i64,
    ///
    #[prost(enumeration = "SVideoType", tag = "2")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "3")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "4")]
    pub qn: i32,
    ///
    #[prost(int32, tag = "5")]
    pub fnver: i32,
    ///
    #[prost(int32, tag = "6")]
    pub fnval: i32,
    ///
    #[prost(int32, tag = "7")]
    pub force_host: i32,
    ///
    #[prost(int32, tag = "8")]
    pub fourk: i32,
    ///
    #[prost(string, tag = "9")]
    pub spmid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub from_spmid: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "11")]
    pub player_preload: ::core::option::Option<PlayerPreloadParams>,
    ///
    #[prost(int64, tag = "12")]
    pub focus_aid: i64,
    ///
    #[prost(message, optional, tag = "13")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SVideoStatInfo {
    ///
    #[prost(int32, tag = "1")]
    pub icon: i32,
    ///
    #[prost(int64, tag = "2")]
    pub num: i64,
    ///
    #[prost(int32, tag = "3")]
    pub selected: i32,
    ///
    #[prost(string, tag = "4")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SVideoTop {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareInfo {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(string, tag = "2")]
    pub bvid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub subtitle: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "6")]
    pub mid: i64,
    ///
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TabOffset {
    ///
    #[prost(int32, tag = "1")]
    pub tab: i32,
    ///
    #[prost(string, tag = "2")]
    pub offset: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpListItem {
    ///
    #[prost(int32, tag = "1")]
    pub has_update: i32,
    ///
    #[prost(string, tag = "2")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub uid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserInfo {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub face: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "4")]
    pub official: ::core::option::Option<OfficialVerify>,
    ///
    #[prost(message, optional, tag = "5")]
    pub vip: ::core::option::Option<VipInfo>,
    ///
    #[prost(message, optional, tag = "6")]
    pub live: ::core::option::Option<LiveInfo>,
    ///
    #[prost(string, tag = "7")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "8")]
    pub pendant: ::core::option::Option<UserPendant>,
    ///
    #[prost(message, optional, tag = "9")]
    pub nameplate: ::core::option::Option<Nameplate>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserPendant {
    ///
    #[prost(int64, tag = "1")]
    pub pid: i64,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub image: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub expire: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoBadge {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub bg_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub bg_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub border_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub border_color_night: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "8")]
    pub bg_style: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VipInfo {
    ///
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    ///
    #[prost(int32, tag = "2")]
    pub status: i32,
    ///
    #[prost(int64, tag = "3")]
    pub due_date: i64,
    ///
    #[prost(message, optional, tag = "4")]
    pub label: ::core::option::Option<VipLabel>,
    ///
    #[prost(int32, tag = "5")]
    pub theme_type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VipLabel {
    ///
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BgType {
    ///
    Default = 0,
    ///
    Face = 1,
}
impl BgType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "bg_type_default",
            Self::Face => "bg_type_face",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "bg_type_default" => Some(Self::Default),
            "bg_type_face" => Some(Self::Face),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BubbleModuleType {
    ///
    BubbleModuleNone = 0,
    ///
    BubbleModuleUser = 1,
    ///
    BubbleModuleText = 2,
    ///
    BubbleModuleColoredTip = 3,
    ///
    BubbleModulePic = 4,
}
impl BubbleModuleType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BubbleModuleNone => "BUBBLE_MODULE_NONE",
            Self::BubbleModuleUser => "BUBBLE_MODULE_USER",
            Self::BubbleModuleText => "BUBBLE_MODULE_TEXT",
            Self::BubbleModuleColoredTip => "BUBBLE_MODULE_COLORED_TIP",
            Self::BubbleModulePic => "BUBBLE_MODULE_PIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BUBBLE_MODULE_NONE" => Some(Self::BubbleModuleNone),
            "BUBBLE_MODULE_USER" => Some(Self::BubbleModuleUser),
            "BUBBLE_MODULE_TEXT" => Some(Self::BubbleModuleText),
            "BUBBLE_MODULE_COLORED_TIP" => Some(Self::BubbleModuleColoredTip),
            "BUBBLE_MODULE_PIC" => Some(Self::BubbleModulePic),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CornerType {
    ///
    None = 0,
    ///
    Text = 1,
    ///
    Animation = 2,
    ///
    Static = 3,
    ///
    RedDot = 4,
    ///
    Number = 5,
}
impl CornerType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "corner_type_none",
            Self::Text => "corner_type_text",
            Self::Animation => "corner_type_animation",
            Self::Static => "corner_type_static",
            Self::RedDot => "corner_type_red_dot",
            Self::Number => "corner_type_number",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "corner_type_none" => Some(Self::None),
            "corner_type_text" => Some(Self::Text),
            "corner_type_animation" => Some(Self::Animation),
            "corner_type_static" => Some(Self::Static),
            "corner_type_red_dot" => Some(Self::RedDot),
            "corner_type_number" => Some(Self::Number),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FoldType {
    ///
    Zero = 0,
    ///
    Publish = 1,
    ///
    Frequent = 2,
    ///
    Unite = 3,
    ///
    Limit = 4,
}
impl FoldType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Zero => "FoldTypeZero",
            Self::Publish => "FoldTypePublish",
            Self::Frequent => "FoldTypeFrequent",
            Self::Unite => "FoldTypeUnite",
            Self::Limit => "FoldTypeLimit",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FoldTypeZero" => Some(Self::Zero),
            "FoldTypePublish" => Some(Self::Publish),
            "FoldTypeFrequent" => Some(Self::Frequent),
            "FoldTypeUnite" => Some(Self::Unite),
            "FoldTypeLimit" => Some(Self::Limit),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MediaType {
    ///
    None = 0,
    ///
    Ugc = 1,
    ///
    Pgc = 2,
    ///
    Live = 3,
    ///
    Vcs = 4,
}
impl MediaType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "MediaTypeNone",
            Self::Ugc => "MediaTypeUGC",
            Self::Pgc => "MediaTypePGC",
            Self::Live => "MediaTypeLive",
            Self::Vcs => "MediaTypeVCS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MediaTypeNone" => Some(Self::None),
            "MediaTypeUGC" => Some(Self::Ugc),
            "MediaTypePGC" => Some(Self::Pgc),
            "MediaTypeLive" => Some(Self::Live),
            "MediaTypeVCS" => Some(Self::Vcs),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RelationStatus {
    ///
    None = 0,
    ///
    Nofollow = 1,
    ///
    Follow = 2,
    ///
    Followed = 3,
    ///
    MutualConcern = 4,
    ///
    Special = 5,
}
impl RelationStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "relation_status_none",
            Self::Nofollow => "relation_status_nofollow",
            Self::Follow => "relation_status_follow",
            Self::Followed => "relation_status_followed",
            Self::MutualConcern => "relation_status_mutual_concern",
            Self::Special => "relation_status_special",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "relation_status_none" => Some(Self::None),
            "relation_status_nofollow" => Some(Self::Nofollow),
            "relation_status_follow" => Some(Self::Follow),
            "relation_status_followed" => Some(Self::Followed),
            "relation_status_mutual_concern" => Some(Self::MutualConcern),
            "relation_status_special" => Some(Self::Special),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SVideoType {
    ///
    TypeNone = 0,
    ///
    TypeDynamic = 1,
    ///
    TypePopularIndex = 2,
    ///
    TypePopularHotword = 3,
}
impl SVideoType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TypeNone => "TypeNone",
            Self::TypeDynamic => "TypeDynamic",
            Self::TypePopularIndex => "TypePopularIndex",
            Self::TypePopularHotword => "TypePopularHotword",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TypeNone" => Some(Self::TypeNone),
            "TypeDynamic" => Some(Self::TypeDynamic),
            "TypePopularIndex" => Some(Self::TypePopularIndex),
            "TypePopularHotword" => Some(Self::TypePopularHotword),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StyleType {
    ///
    None = 0,
    ///
    Live = 1,
    ///
    DynUp = 2,
    ///
    OgvUp = 3,
    ///
    CollectionUp = 4,
}
impl StyleType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "STYLE_TYPE_NONE",
            Self::Live => "STYLE_TYPE_LIVE",
            Self::DynUp => "STYLE_TYPE_DYN_UP",
            Self::OgvUp => "STYLE_TYPE_OGV_UP",
            Self::CollectionUp => "STYLE_TYPE_COLLECTION_UP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STYLE_TYPE_NONE" => Some(Self::None),
            "STYLE_TYPE_LIVE" => Some(Self::Live),
            "STYLE_TYPE_DYN_UP" => Some(Self::DynUp),
            "STYLE_TYPE_OGV_UP" => Some(Self::OgvUp),
            "STYLE_TYPE_COLLECTION_UP" => Some(Self::CollectionUp),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VideoSubType {
    ///
    None = 0,
    ///
    Bangumi = 1,
    ///
    Movie = 2,
    ///
    Documentary = 3,
    ///
    Domestic = 4,
    ///
    Teleplay = 5,
}
impl VideoSubType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "VideoSubTypeNone",
            Self::Bangumi => "VideoSubTypeBangumi",
            Self::Movie => "VideoSubTypeMovie",
            Self::Documentary => "VideoSubTypeDocumentary",
            Self::Domestic => "VideoSubTypeDomestic",
            Self::Teleplay => "VideoSubTypeTeleplay",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VideoSubTypeNone" => Some(Self::None),
            "VideoSubTypeBangumi" => Some(Self::Bangumi),
            "VideoSubTypeMovie" => Some(Self::Movie),
            "VideoSubTypeDocumentary" => Some(Self::Documentary),
            "VideoSubTypeDomestic" => Some(Self::Domestic),
            "VideoSubTypeTeleplay" => Some(Self::Teleplay),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod dynamic_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct DynamicClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DynamicClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DynamicClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DynamicClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn dyn_details(
            &mut self,
            request: impl tonic::IntoRequest<super::DynDetailsReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynDetailsReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v1.Dynamic/DynDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v1.Dynamic", "DynDetails"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_mix_up_list_search(
            &mut self,
            request: impl tonic::IntoRequest<super::DynMixUpListSearchReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynMixUpListSearchReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v1.Dynamic/DynMixUpListSearch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v1.Dynamic",
                        "DynMixUpListSearch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_mix_up_list_view_more(
            &mut self,
            request: impl tonic::IntoRequest<super::NoReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynMixUpListViewMoreReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v1.Dynamic/DynMixUpListViewMore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v1.Dynamic",
                        "DynMixUpListViewMore",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_our_city(
            &mut self,
            request: impl tonic::IntoRequest<super::DynOurCityReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynOurCityReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v1.Dynamic/DynOurCity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v1.Dynamic", "DynOurCity"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_our_city_switch(
            &mut self,
            request: impl tonic::IntoRequest<super::DynOurCitySwitchReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v1.Dynamic/DynOurCitySwitch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v1.Dynamic",
                        "DynOurCitySwitch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_red(
            &mut self,
            request: impl tonic::IntoRequest<super::DynRedReq>,
        ) -> std::result::Result<tonic::Response<super::DynRedReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v1.Dynamic/DynRed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v1.Dynamic", "DynRed"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_tab(
            &mut self,
            request: impl tonic::IntoRequest<super::DynTabReq>,
        ) -> std::result::Result<tonic::Response<super::DynTabReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v1.Dynamic/DynTab",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v1.Dynamic", "DynTab"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_upd_offset(
            &mut self,
            request: impl tonic::IntoRequest<super::DynUpdOffsetReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v1.Dynamic/DynUpdOffset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.dynamic.v1.Dynamic", "DynUpdOffset"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_video(
            &mut self,
            request: impl tonic::IntoRequest<super::DynVideoReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynVideoReqReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v1.Dynamic/DynVideo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v1.Dynamic", "DynVideo"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn dyn_video_personal(
            &mut self,
            request: impl tonic::IntoRequest<super::DynVideoPersonalReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynVideoPersonalReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v1.Dynamic/DynVideoPersonal",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v1.Dynamic",
                        "DynVideoPersonal",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn geo_coder(
            &mut self,
            request: impl tonic::IntoRequest<super::GeoCoderReq>,
        ) -> std::result::Result<tonic::Response<super::GeoCoderReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v1.Dynamic/GeoCoder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v1.Dynamic", "GeoCoder"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn our_city_click_report(
            &mut self,
            request: impl tonic::IntoRequest<super::OurCityClickReportReq>,
        ) -> std::result::Result<
            tonic::Response<super::OurCityClickReportReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v1.Dynamic/OurCityClickReport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.dynamic.v1.Dynamic",
                        "OurCityClickReport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn s_video(
            &mut self,
            request: impl tonic::IntoRequest<super::SVideoReq>,
        ) -> std::result::Result<tonic::Response<super::SVideoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.dynamic.v1.Dynamic/SVideo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.dynamic.v1.Dynamic", "SVideo"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod dynamic_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with DynamicServer.
    #[async_trait]
    pub trait Dynamic: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn dyn_details(
            &self,
            request: tonic::Request<super::DynDetailsReq>,
        ) -> std::result::Result<tonic::Response<super::DynDetailsReply>, tonic::Status>;
        ///
        async fn dyn_mix_up_list_search(
            &self,
            request: tonic::Request<super::DynMixUpListSearchReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynMixUpListSearchReply>,
            tonic::Status,
        >;
        ///
        async fn dyn_mix_up_list_view_more(
            &self,
            request: tonic::Request<super::NoReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynMixUpListViewMoreReply>,
            tonic::Status,
        >;
        ///
        async fn dyn_our_city(
            &self,
            request: tonic::Request<super::DynOurCityReq>,
        ) -> std::result::Result<tonic::Response<super::DynOurCityReply>, tonic::Status>;
        ///
        async fn dyn_our_city_switch(
            &self,
            request: tonic::Request<super::DynOurCitySwitchReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status>;
        ///
        async fn dyn_red(
            &self,
            request: tonic::Request<super::DynRedReq>,
        ) -> std::result::Result<tonic::Response<super::DynRedReply>, tonic::Status>;
        ///
        async fn dyn_tab(
            &self,
            request: tonic::Request<super::DynTabReq>,
        ) -> std::result::Result<tonic::Response<super::DynTabReply>, tonic::Status>;
        ///
        async fn dyn_upd_offset(
            &self,
            request: tonic::Request<super::DynUpdOffsetReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status>;
        ///
        async fn dyn_video(
            &self,
            request: tonic::Request<super::DynVideoReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynVideoReqReply>,
            tonic::Status,
        >;
        ///
        async fn dyn_video_personal(
            &self,
            request: tonic::Request<super::DynVideoPersonalReq>,
        ) -> std::result::Result<
            tonic::Response<super::DynVideoPersonalReply>,
            tonic::Status,
        >;
        ///
        async fn geo_coder(
            &self,
            request: tonic::Request<super::GeoCoderReq>,
        ) -> std::result::Result<tonic::Response<super::GeoCoderReply>, tonic::Status>;
        ///
        async fn our_city_click_report(
            &self,
            request: tonic::Request<super::OurCityClickReportReq>,
        ) -> std::result::Result<
            tonic::Response<super::OurCityClickReportReply>,
            tonic::Status,
        >;
        ///
        async fn s_video(
            &self,
            request: tonic::Request<super::SVideoReq>,
        ) -> std::result::Result<tonic::Response<super::SVideoReply>, tonic::Status>;
    }
    ///
    #[derive(Debug)]
    pub struct DynamicServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> DynamicServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for DynamicServer<T>
    where
        T: Dynamic,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.app.dynamic.v1.Dynamic/DynDetails" => {
                    #[allow(non_camel_case_types)]
                    struct DynDetailsSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::DynDetailsReq>
                    for DynDetailsSvc<T> {
                        type Response = super::DynDetailsReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynDetailsReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_details(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynDetailsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v1.Dynamic/DynMixUpListSearch" => {
                    #[allow(non_camel_case_types)]
                    struct DynMixUpListSearchSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::DynMixUpListSearchReq>
                    for DynMixUpListSearchSvc<T> {
                        type Response = super::DynMixUpListSearchReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynMixUpListSearchReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_mix_up_list_search(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynMixUpListSearchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v1.Dynamic/DynMixUpListViewMore" => {
                    #[allow(non_camel_case_types)]
                    struct DynMixUpListViewMoreSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::NoReq>
                    for DynMixUpListViewMoreSvc<T> {
                        type Response = super::DynMixUpListViewMoreReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::NoReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_mix_up_list_view_more(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynMixUpListViewMoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v1.Dynamic/DynOurCity" => {
                    #[allow(non_camel_case_types)]
                    struct DynOurCitySvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::DynOurCityReq>
                    for DynOurCitySvc<T> {
                        type Response = super::DynOurCityReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynOurCityReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_our_city(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynOurCitySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v1.Dynamic/DynOurCitySwitch" => {
                    #[allow(non_camel_case_types)]
                    struct DynOurCitySwitchSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::DynOurCitySwitchReq>
                    for DynOurCitySwitchSvc<T> {
                        type Response = super::NoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynOurCitySwitchReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_our_city_switch(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynOurCitySwitchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v1.Dynamic/DynRed" => {
                    #[allow(non_camel_case_types)]
                    struct DynRedSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::DynRedReq>
                    for DynRedSvc<T> {
                        type Response = super::DynRedReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynRedReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_red(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynRedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v1.Dynamic/DynTab" => {
                    #[allow(non_camel_case_types)]
                    struct DynTabSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::DynTabReq>
                    for DynTabSvc<T> {
                        type Response = super::DynTabReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynTabReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_tab(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynTabSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v1.Dynamic/DynUpdOffset" => {
                    #[allow(non_camel_case_types)]
                    struct DynUpdOffsetSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::DynUpdOffsetReq>
                    for DynUpdOffsetSvc<T> {
                        type Response = super::NoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynUpdOffsetReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_upd_offset(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynUpdOffsetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v1.Dynamic/DynVideo" => {
                    #[allow(non_camel_case_types)]
                    struct DynVideoSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::DynVideoReq>
                    for DynVideoSvc<T> {
                        type Response = super::DynVideoReqReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynVideoReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_video(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynVideoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v1.Dynamic/DynVideoPersonal" => {
                    #[allow(non_camel_case_types)]
                    struct DynVideoPersonalSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::DynVideoPersonalReq>
                    for DynVideoPersonalSvc<T> {
                        type Response = super::DynVideoPersonalReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DynVideoPersonalReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::dyn_video_personal(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DynVideoPersonalSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v1.Dynamic/GeoCoder" => {
                    #[allow(non_camel_case_types)]
                    struct GeoCoderSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::GeoCoderReq>
                    for GeoCoderSvc<T> {
                        type Response = super::GeoCoderReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GeoCoderReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::geo_coder(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GeoCoderSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v1.Dynamic/OurCityClickReport" => {
                    #[allow(non_camel_case_types)]
                    struct OurCityClickReportSvc<T: Dynamic>(pub Arc<T>);
                    impl<
                        T: Dynamic,
                    > tonic::server::UnaryService<super::OurCityClickReportReq>
                    for OurCityClickReportSvc<T> {
                        type Response = super::OurCityClickReportReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::OurCityClickReportReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::our_city_click_report(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = OurCityClickReportSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.dynamic.v1.Dynamic/SVideo" => {
                    #[allow(non_camel_case_types)]
                    struct SVideoSvc<T: Dynamic>(pub Arc<T>);
                    impl<T: Dynamic> tonic::server::UnaryService<super::SVideoReq>
                    for SVideoSvc<T> {
                        type Response = super::SVideoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SVideoReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dynamic>::s_video(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SVideoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for DynamicServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.app.dynamic.v1.Dynamic";
    impl<T> tonic::server::NamedService for DynamicServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
