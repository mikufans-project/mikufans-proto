// This file is @generated by prost-build.
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BapiLiveRtcHealthProto {}
/// Nested message and enum types in `BAPILiveRTCHealthProto`.
pub mod bapi_live_rtc_health_proto {
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Bandwidth {
        ///
        #[prost(int64, tag = "1")]
        pub tx_rate: i64,
        ///
        #[prost(int64, tag = "2")]
        pub rx_rate: i64,
    }
    impl ::prost::Name for Bandwidth {
        const NAME: &'static str = "Bandwidth";
        const PACKAGE: &'static str = "bilibili.live.rtc";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.live.rtc.BAPILiveRTCHealthProto.Bandwidth".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.live.rtc.BAPILiveRTCHealthProto.Bandwidth".into()
        }
    }
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Cpu {
        ///
        #[prost(float, tag = "1")]
        pub usage: f32,
    }
    impl ::prost::Name for Cpu {
        const NAME: &'static str = "Cpu";
        const PACKAGE: &'static str = "bilibili.live.rtc";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.live.rtc.BAPILiveRTCHealthProto.Cpu".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.live.rtc.BAPILiveRTCHealthProto.Cpu".into()
        }
    }
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Disk {
        ///
        #[prost(float, tag = "1")]
        pub usage: f32,
        ///
        #[prost(int64, tag = "2")]
        pub free: i64,
    }
    impl ::prost::Name for Disk {
        const NAME: &'static str = "Disk";
        const PACKAGE: &'static str = "bilibili.live.rtc";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.live.rtc.BAPILiveRTCHealthProto.Disk".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.live.rtc.BAPILiveRTCHealthProto.Disk".into()
        }
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HealthInfo {
        ///
        #[prost(string, tag = "1")]
        pub node_name: ::prost::alloc::string::String,
        ///
        #[prost(message, optional, tag = "2")]
        pub cpu: ::core::option::Option<Cpu>,
        ///
        #[prost(message, optional, tag = "3")]
        pub memory: ::core::option::Option<Memory>,
        ///
        #[prost(message, optional, tag = "4")]
        pub disk: ::core::option::Option<Disk>,
        ///
        #[prost(message, optional, tag = "5")]
        pub bandwidth: ::core::option::Option<Bandwidth>,
        ///
        #[prost(message, optional, tag = "6")]
        pub up_link: ::core::option::Option<ServiceQuality>,
        ///
        #[prost(message, optional, tag = "7")]
        pub dn_link: ::core::option::Option<ServiceQuality>,
        ///
        #[prost(bool, tag = "8")]
        pub offline: bool,
        ///
        #[prost(bool, tag = "9")]
        pub network_available: bool,
        ///
        #[prost(message, optional, tag = "10")]
        pub transbandwidth: ::core::option::Option<TransportBandwidth>,
    }
    impl ::prost::Name for HealthInfo {
        const NAME: &'static str = "HealthInfo";
        const PACKAGE: &'static str = "bilibili.live.rtc";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.live.rtc.BAPILiveRTCHealthProto.HealthInfo".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.live.rtc.BAPILiveRTCHealthProto.HealthInfo".into()
        }
    }
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Memory {
        ///
        #[prost(float, tag = "1")]
        pub usage: f32,
        ///
        #[prost(int64, tag = "2")]
        pub free: i64,
    }
    impl ::prost::Name for Memory {
        const NAME: &'static str = "Memory";
        const PACKAGE: &'static str = "bilibili.live.rtc";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.live.rtc.BAPILiveRTCHealthProto.Memory".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.live.rtc.BAPILiveRTCHealthProto.Memory".into()
        }
    }
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ServiceQuality {
        ///
        #[prost(int64, tag = "1")]
        pub stream_num: i64,
        ///
        #[prost(int32, tag = "2")]
        pub score_average: i32,
        ///
        #[prost(float, tag = "3")]
        pub zero_score_ratio: f32,
    }
    impl ::prost::Name for ServiceQuality {
        const NAME: &'static str = "ServiceQuality";
        const PACKAGE: &'static str = "bilibili.live.rtc";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.live.rtc.BAPILiveRTCHealthProto.ServiceQuality".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.live.rtc.BAPILiveRTCHealthProto.ServiceQuality".into()
        }
    }
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct TransportBandwidth {
        ///
        #[prost(float, tag = "1")]
        pub total_tx_byterate: f32,
        ///
        #[prost(float, tag = "2")]
        pub total_rx_byterate: f32,
        ///
        #[prost(float, tag = "3")]
        pub wan_tx_byterate: f32,
        ///
        #[prost(float, tag = "4")]
        pub wan_rx_byterate: f32,
        ///
        #[prost(float, tag = "5")]
        pub lan_tx_byterate: f32,
        ///
        #[prost(float, tag = "6")]
        pub lan_rx_byterate: f32,
    }
    impl ::prost::Name for TransportBandwidth {
        const NAME: &'static str = "TransportBandwidth";
        const PACKAGE: &'static str = "bilibili.live.rtc";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.live.rtc.BAPILiveRTCHealthProto.TransportBandwidth".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.live.rtc.BAPILiveRTCHealthProto.TransportBandwidth".into()
        }
    }
}
impl ::prost::Name for BapiLiveRtcHealthProto {
    const NAME: &'static str = "BAPILiveRTCHealthProto";
    const PACKAGE: &'static str = "bilibili.live.rtc";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.live.rtc.BAPILiveRTCHealthProto".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.live.rtc.BAPILiveRTCHealthProto".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BapiLiveRtcLegacyProto {}
/// Nested message and enum types in `BAPILiveRTCLegacyProto`.
pub mod bapi_live_rtc_legacy_proto {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MediaTypeField {
        ///
        #[prost(int32, repeated, tag = "1")]
        pub media_type: ::prost::alloc::vec::Vec<i32>,
    }
    impl ::prost::Name for MediaTypeField {
        const NAME: &'static str = "MediaTypeField";
        const PACKAGE: &'static str = "bilibili.live.rtc";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.live.rtc.BAPILiveRTCLegacyProto.MediaTypeField".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.live.rtc.BAPILiveRTCLegacyProto.MediaTypeField".into()
        }
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RtcSubscribe {
        ///
        #[prost(map = "int32, message", tag = "1")]
        pub subscribe: ::std::collections::HashMap<i32, MediaTypeField>,
    }
    impl ::prost::Name for RtcSubscribe {
        const NAME: &'static str = "RtcSubscribe";
        const PACKAGE: &'static str = "bilibili.live.rtc";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.live.rtc.BAPILiveRTCLegacyProto.RtcSubscribe".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.live.rtc.BAPILiveRTCLegacyProto.RtcSubscribe".into()
        }
    }
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MediaType {
        ///
        Audio = 0,
        ///
        Video = 1,
        ///
        Data = 2,
        ///
        SmallVideo = 3,
        ///
        Other = 15,
    }
    impl MediaType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Audio => "AUDIO",
                Self::Video => "VIDEO",
                Self::Data => "DATA",
                Self::SmallVideo => "SMALL_VIDEO",
                Self::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUDIO" => Some(Self::Audio),
                "VIDEO" => Some(Self::Video),
                "DATA" => Some(Self::Data),
                "SMALL_VIDEO" => Some(Self::SmallVideo),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for BapiLiveRtcLegacyProto {
    const NAME: &'static str = "BAPILiveRTCLegacyProto";
    const PACKAGE: &'static str = "bilibili.live.rtc";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.live.rtc.BAPILiveRTCLegacyProto".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.live.rtc.BAPILiveRTCLegacyProto".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BapiLiveRtcStreamProto {}
/// Nested message and enum types in `BAPILiveRTCStreamProto`.
pub mod bapi_live_rtc_stream_proto {
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AudioMetaData {
        ///
        #[prost(int64, tag = "1")]
        pub channels: i64,
        ///
        #[prost(int64, tag = "2")]
        pub sample_rate: i64,
        ///
        #[prost(int64, tag = "3")]
        pub payload: i64,
        ///
        #[prost(int32, tag = "4")]
        pub ssrc: i32,
    }
    impl ::prost::Name for AudioMetaData {
        const NAME: &'static str = "AudioMetaData";
        const PACKAGE: &'static str = "bilibili.live.rtc";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.live.rtc.BAPILiveRTCStreamProto.AudioMetaData".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.live.rtc.BAPILiveRTCStreamProto.AudioMetaData".into()
        }
    }
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct StreamMeta {
        ///
        #[prost(enumeration = "Codec", tag = "1")]
        pub codec: i32,
        ///
        #[prost(oneof = "stream_meta::Metadata", tags = "2, 3")]
        pub metadata: ::core::option::Option<stream_meta::Metadata>,
    }
    /// Nested message and enum types in `StreamMeta`.
    pub mod stream_meta {
        ///
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Metadata {
            ///
            #[prost(message, tag = "2")]
            Audio(super::AudioMetaData),
            ///
            #[prost(message, tag = "3")]
            Video(super::VideoMetaData),
        }
    }
    impl ::prost::Name for StreamMeta {
        const NAME: &'static str = "StreamMeta";
        const PACKAGE: &'static str = "bilibili.live.rtc";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.live.rtc.BAPILiveRTCStreamProto.StreamMeta".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.live.rtc.BAPILiveRTCStreamProto.StreamMeta".into()
        }
    }
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct VideoMetaData {
        ///
        #[prost(int64, tag = "1")]
        pub payload: i64,
        ///
        #[prost(int32, tag = "2")]
        pub ssrc: i32,
    }
    impl ::prost::Name for VideoMetaData {
        const NAME: &'static str = "VideoMetaData";
        const PACKAGE: &'static str = "bilibili.live.rtc";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.live.rtc.BAPILiveRTCStreamProto.VideoMetaData".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.live.rtc.BAPILiveRTCStreamProto.VideoMetaData".into()
        }
    }
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Codec {
        ///
        Opus = 0,
        ///
        H264 = 1,
        ///
        H265 = 2,
        ///
        Av1 = 3,
    }
    impl Codec {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Opus => "Opus",
                Self::H264 => "H264",
                Self::H265 => "H265",
                Self::Av1 => "AV1",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Opus" => Some(Self::Opus),
                "H264" => Some(Self::H264),
                "H265" => Some(Self::H265),
                "AV1" => Some(Self::Av1),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for BapiLiveRtcStreamProto {
    const NAME: &'static str = "BAPILiveRTCStreamProto";
    const PACKAGE: &'static str = "bilibili.live.rtc";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.live.rtc.BAPILiveRTCStreamProto".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.live.rtc.BAPILiveRTCStreamProto".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BapiLiveRtcTokenProto {}
/// Nested message and enum types in `BAPILiveRTCTokenProto`.
pub mod bapi_live_rtc_token_proto {
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AccessToken {
        ///
        #[prost(int64, tag = "1")]
        pub channel_id: i64,
        ///
        #[prost(int64, tag = "2")]
        pub uid: i64,
        ///
        #[prost(string, tag = "3")]
        pub token: ::prost::alloc::string::String,
        ///
        #[prost(string, repeated, tag = "4")]
        pub addr: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        ///
        #[prost(string, tag = "5")]
        pub fingerprint: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "6")]
        pub password: ::prost::alloc::string::String,
        ///
        #[prost(string, repeated, tag = "7")]
        pub http_dns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        ///
        #[prost(int32, tag = "8")]
        pub version: i32,
        ///
        #[prost(string, tag = "9")]
        pub business_name: ::prost::alloc::string::String,
        ///
        #[prost(message, optional, tag = "10")]
        pub turn_addr: ::core::option::Option<TurnAddr>,
        ///
        #[prost(string, tag = "11")]
        pub media_server_name: ::prost::alloc::string::String,
    }
    impl ::prost::Name for AccessToken {
        const NAME: &'static str = "AccessToken";
        const PACKAGE: &'static str = "bilibili.live.rtc";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.live.rtc.BAPILiveRTCTokenProto.AccessToken".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.live.rtc.BAPILiveRTCTokenProto.AccessToken".into()
        }
    }
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Token {
        ///
        #[prost(int64, tag = "1")]
        pub channel_id: i64,
        ///
        #[prost(int64, tag = "2")]
        pub uid: i64,
        ///
        #[prost(int64, tag = "3")]
        pub timestamp: i64,
        ///
        #[prost(enumeration = "super::bapi_live_rtc_user_proto::UserRole", tag = "4")]
        pub role: i32,
    }
    impl ::prost::Name for Token {
        const NAME: &'static str = "Token";
        const PACKAGE: &'static str = "bilibili.live.rtc";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.live.rtc.BAPILiveRTCTokenProto.Token".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.live.rtc.BAPILiveRTCTokenProto.Token".into()
        }
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TurnAddr {
        ///
        #[prost(string, tag = "1")]
        pub username: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "2")]
        pub password: ::prost::alloc::string::String,
        ///
        #[prost(string, repeated, tag = "3")]
        pub addr: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        ///
        #[prost(int32, repeated, tag = "4")]
        pub protocol: ::prost::alloc::vec::Vec<i32>,
        ///
        #[prost(bool, tag = "5")]
        pub turn_only: bool,
    }
    impl ::prost::Name for TurnAddr {
        const NAME: &'static str = "TurnAddr";
        const PACKAGE: &'static str = "bilibili.live.rtc";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.live.rtc.BAPILiveRTCTokenProto.TurnAddr".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.live.rtc.BAPILiveRTCTokenProto.TurnAddr".into()
        }
    }
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TurnProtocol {
        ///
        Udp = 0,
        ///
        Tcp = 1,
        ///
        Tls = 2,
    }
    impl TurnProtocol {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Udp => "UDP",
                Self::Tcp => "TCP",
                Self::Tls => "TLS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UDP" => Some(Self::Udp),
                "TCP" => Some(Self::Tcp),
                "TLS" => Some(Self::Tls),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for BapiLiveRtcTokenProto {
    const NAME: &'static str = "BAPILiveRTCTokenProto";
    const PACKAGE: &'static str = "bilibili.live.rtc";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.live.rtc.BAPILiveRTCTokenProto".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.live.rtc.BAPILiveRTCTokenProto".into()
    }
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BapiLiveRtcUserProto {}
/// Nested message and enum types in `BAPILiveRTCUserProto`.
pub mod bapi_live_rtc_user_proto {
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CodecCapability {
        ///
        #[prost(bool, tag = "1")]
        pub av1: bool,
        ///
        #[prost(bool, tag = "2")]
        pub h265: bool,
    }
    impl ::prost::Name for CodecCapability {
        const NAME: &'static str = "CodecCapability";
        const PACKAGE: &'static str = "bilibili.live.rtc";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.live.rtc.BAPILiveRTCUserProto.CodecCapability".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.live.rtc.BAPILiveRTCUserProto.CodecCapability".into()
        }
    }
    ///
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Stream {
        ///
        #[prost(bool, tag = "1")]
        pub has_video: bool,
        ///
        #[prost(bool, tag = "2")]
        pub has_audio: bool,
        ///
        #[prost(bool, tag = "3")]
        pub audio_muted: bool,
        ///
        #[prost(bool, tag = "4")]
        pub video_muted: bool,
        ///
        #[prost(int32, tag = "5")]
        pub video_count: i32,
        ///
        #[prost(int32, tag = "6")]
        pub temporal_count: i32,
    }
    impl ::prost::Name for Stream {
        const NAME: &'static str = "Stream";
        const PACKAGE: &'static str = "bilibili.live.rtc";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.live.rtc.BAPILiveRTCUserProto.Stream".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.live.rtc.BAPILiveRTCUserProto.Stream".into()
        }
    }
    ///
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct User {
        ///
        #[prost(int64, tag = "1")]
        pub uid: i64,
        ///
        #[prost(enumeration = "UserRole", tag = "2")]
        pub role: i32,
        ///
        #[prost(message, optional, tag = "3")]
        pub pub_stream: ::core::option::Option<Stream>,
        ///
        #[prost(string, tag = "4")]
        pub platform: ::prost::alloc::string::String,
        ///
        #[prost(string, tag = "5")]
        pub sdk_version: ::prost::alloc::string::String,
        ///
        #[prost(message, optional, tag = "6")]
        pub decode_capability: ::core::option::Option<CodecCapability>,
    }
    impl ::prost::Name for User {
        const NAME: &'static str = "User";
        const PACKAGE: &'static str = "bilibili.live.rtc";
        fn full_name() -> ::prost::alloc::string::String {
            "bilibili.live.rtc.BAPILiveRTCUserProto.User".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/bilibili.live.rtc.BAPILiveRTCUserProto.User".into()
        }
    }
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserLeaveReason {
        ///
        Normal = 0,
        ///
        Kicked = 1,
        ///
        Timeout = 2,
        ///
        Killed = 3,
        ///
        Reconnect = 4,
    }
    impl UserLeaveReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Normal => "NORMAL",
                Self::Kicked => "KICKED",
                Self::Timeout => "TIMEOUT",
                Self::Killed => "KILLED",
                Self::Reconnect => "RECONNECT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NORMAL" => Some(Self::Normal),
                "KICKED" => Some(Self::Kicked),
                "TIMEOUT" => Some(Self::Timeout),
                "KILLED" => Some(Self::Killed),
                "RECONNECT" => Some(Self::Reconnect),
                _ => None,
            }
        }
    }
    ///
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserRole {
        ///
        Normal = 0,
        ///
        Audience = 1,
        ///
        Monitor = 2,
        ///
        Relay = 3,
        ///
        App = 4,
        ///
        Mix = 5,
        ///
        Unknown = 99,
    }
    impl UserRole {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Normal => "Normal",
                Self::Audience => "Audience",
                Self::Monitor => "Monitor",
                Self::Relay => "Relay",
                Self::App => "App",
                Self::Mix => "Mix",
                Self::Unknown => "Unknown",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Normal" => Some(Self::Normal),
                "Audience" => Some(Self::Audience),
                "Monitor" => Some(Self::Monitor),
                "Relay" => Some(Self::Relay),
                "App" => Some(Self::App),
                "Mix" => Some(Self::Mix),
                "Unknown" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for BapiLiveRtcUserProto {
    const NAME: &'static str = "BAPILiveRTCUserProto";
    const PACKAGE: &'static str = "bilibili.live.rtc";
    fn full_name() -> ::prost::alloc::string::String {
        "bilibili.live.rtc.BAPILiveRTCUserProto".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/bilibili.live.rtc.BAPILiveRTCUserProto".into()
    }
}
