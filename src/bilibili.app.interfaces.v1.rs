// This file is @generated by prost-build.
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Arc {
    ///
    #[prost(message, optional, tag = "1")]
    pub archive: ::core::option::Option<super::super::archive::v1::Arc>,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub view_content: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub icon_type: i64,
    ///
    #[prost(string, tag = "5")]
    pub cover_icon: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "6")]
    pub is_fold: bool,
    ///
    #[prost(bool, tag = "7")]
    pub is_pugv: bool,
    ///
    #[prost(string, tag = "8")]
    pub publish_time_text: ::prost::alloc::string::String,
    ///
    #[prost(string, repeated, tag = "9")]
    pub badges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(bool, tag = "10")]
    pub is_oneself: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Badge {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub icon: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigItem {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover_image_uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub cover_right_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover_left_text1: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "6")]
    pub cover_left_icon1: i64,
    ///
    #[prost(string, tag = "7")]
    pub cover_left_text2: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "8")]
    pub cover_left_icon2: i64,
    ///
    #[prost(message, optional, tag = "9")]
    pub user_card: ::core::option::Option<UserCard>,
    ///
    #[prost(message, optional, tag = "10")]
    pub like_button: ::core::option::Option<LikeButton>,
    ///
    #[prost(int64, tag = "11")]
    pub param: i64,
    ///
    #[prost(message, optional, tag = "12")]
    pub share_plane: ::core::option::Option<super::super::card::v1::SharePlane>,
    ///
    #[prost(message, optional, tag = "13")]
    pub three_point_meta: ::core::option::Option<super::super::card::v1::PanelMeta>,
    ///
    #[prost(message, optional, tag = "14")]
    pub inline_progress_bar: ::core::option::Option<
        super::super::card::v1::InlineProgressBar,
    >,
    ///
    #[prost(int32, tag = "15")]
    pub can_play: i32,
    ///
    #[prost(message, optional, tag = "16")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(bool, tag = "17")]
    pub is_fav: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Button {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub link: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub id: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub icon: i64,
    ///
    #[prost(enumeration = "ButType", tag = "5")]
    pub but_type: i32,
    ///
    #[prost(int32, tag = "6")]
    pub follow_state: i32,
    ///
    #[prost(string, tag = "7")]
    pub has_title: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardArticle {
    ///
    #[prost(string, repeated, tag = "1")]
    pub covers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub mid: i64,
    ///
    #[prost(bool, tag = "4")]
    pub display_attention: bool,
    ///
    #[prost(string, tag = "5")]
    pub badge: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "6")]
    pub relation: ::core::option::Option<Relation>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardCheese {
    ///
    #[prost(string, tag = "1")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub progress: i64,
    ///
    #[prost(int64, tag = "3")]
    pub duration: i64,
    ///
    #[prost(string, tag = "4")]
    pub subtitle: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "5")]
    pub state: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardLive {
    ///
    #[prost(string, tag = "1")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub mid: i64,
    ///
    #[prost(string, tag = "4")]
    pub tag: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "5")]
    pub status: i32,
    ///
    #[prost(bool, tag = "6")]
    pub display_attention: bool,
    ///
    #[prost(message, optional, tag = "7")]
    pub relation: ::core::option::Option<Relation>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardOgv {
    ///
    #[prost(string, tag = "1")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub progress: i64,
    ///
    #[prost(int64, tag = "3")]
    pub duration: i64,
    ///
    #[prost(string, tag = "4")]
    pub subtitle: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub badge: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "6")]
    pub state: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardUgc {
    ///
    #[prost(string, tag = "1")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub progress: i64,
    ///
    #[prost(int64, tag = "3")]
    pub duration: i64,
    ///
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "5")]
    pub mid: i64,
    ///
    #[prost(bool, tag = "6")]
    pub display_attention: bool,
    ///
    #[prost(int64, tag = "7")]
    pub cid: i64,
    ///
    #[prost(int32, tag = "8")]
    pub page: i32,
    ///
    #[prost(string, tag = "9")]
    pub subtitle: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "10")]
    pub relation: ::core::option::Option<Relation>,
    ///
    #[prost(string, tag = "11")]
    pub bvid: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "12")]
    pub videos: i64,
    ///
    #[prost(string, tag = "13")]
    pub short_link: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "14")]
    pub share_subtitle: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "15")]
    pub view: i64,
    ///
    #[prost(int64, tag = "16")]
    pub state: i64,
    ///
    #[prost(string, tag = "17")]
    pub badge: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "18")]
    pub badge_v2: ::core::option::Option<Badge>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cast {
    ///
    #[prost(message, repeated, tag = "1")]
    pub person: ::prost::alloc::vec::Vec<MediaPerson>,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChannelInfo {
    ///
    #[prost(int64, tag = "1")]
    pub channel_id: i64,
    ///
    #[prost(bool, tag = "2")]
    pub subscribed: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearReq {
    ///
    #[prost(string, tag = "1")]
    pub business: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommentItem {
    ///
    #[prost(string, tag = "1")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "CommentType", tag = "4")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "5")]
    pub action_type: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub id: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Cursor {
    ///
    #[prost(int64, tag = "1")]
    pub max: i64,
    ///
    #[prost(int32, tag = "2")]
    pub max_tp: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CursorItem {
    ///
    #[prost(string, tag = "6")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "8")]
    pub view_at: i64,
    ///
    #[prost(int64, tag = "9")]
    pub kid: i64,
    ///
    #[prost(int64, tag = "10")]
    pub oid: i64,
    ///
    #[prost(string, tag = "11")]
    pub business: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "12")]
    pub tp: i32,
    ///
    #[prost(message, optional, tag = "13")]
    pub dt: ::core::option::Option<DeviceType>,
    ///
    #[prost(bool, tag = "14")]
    pub has_share: bool,
    ///
    #[prost(oneof = "cursor_item::CardItem", tags = "1, 2, 3, 4, 5")]
    pub card_item: ::core::option::Option<cursor_item::CardItem>,
}
/// Nested message and enum types in `CursorItem`.
pub mod cursor_item {
    ///
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CardItem {
        ///
        #[prost(message, tag = "1")]
        CardUgc(super::CardUgc),
        ///
        #[prost(message, tag = "2")]
        CardOgv(super::CardOgv),
        ///
        #[prost(message, tag = "3")]
        CardArticle(super::CardArticle),
        ///
        #[prost(message, tag = "4")]
        CardLive(super::CardLive),
        ///
        #[prost(message, tag = "5")]
        CardCheese(super::CardCheese),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CursorReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<CursorItem>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub tab: ::prost::alloc::vec::Vec<CursorTab>,
    ///
    #[prost(message, optional, tag = "3")]
    pub cursor: ::core::option::Option<Cursor>,
    ///
    #[prost(bool, tag = "4")]
    pub has_more: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CursorReq {
    ///
    #[prost(message, optional, tag = "1")]
    pub cursor: ::core::option::Option<Cursor>,
    ///
    #[prost(string, tag = "2")]
    pub business: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub player_preload: ::core::option::Option<PlayerPreloadParams>,
    ///
    #[prost(message, optional, tag = "4")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CursorTab {
    ///
    #[prost(string, tag = "1")]
    pub business: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub router: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "4")]
    pub focus: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CursorV2Reply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<CursorItem>,
    ///
    #[prost(message, optional, tag = "2")]
    pub cursor: ::core::option::Option<Cursor>,
    ///
    #[prost(bool, tag = "3")]
    pub has_more: bool,
    ///
    #[prost(string, tag = "4")]
    pub empty_link: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CursorV2Req {
    ///
    #[prost(message, optional, tag = "1")]
    pub cursor: ::core::option::Option<Cursor>,
    ///
    #[prost(string, tag = "2")]
    pub business: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "3")]
    pub player_preload: ::core::option::Option<PlayerPreloadParams>,
    ///
    #[prost(message, optional, tag = "4")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
    ///
    #[prost(bool, tag = "5")]
    pub is_local: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DefaultWordsReply {
    ///
    #[prost(string, tag = "1")]
    pub trackid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub param: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub show: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub word: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "5")]
    pub show_front: i64,
    ///
    #[prost(string, tag = "6")]
    pub exp_str: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub goto: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub value: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "9")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "10")]
    pub enable_refresh: i64,
    ///
    #[prost(int64, tag = "11")]
    pub refresh_interval_milli: i64,
    ///
    #[prost(int64, tag = "12")]
    pub enable_animation: i64,
    ///
    #[prost(int64, tag = "13")]
    pub animation_time_milli: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DefaultWordsReq {
    ///
    #[prost(int64, tag = "1")]
    pub from: i64,
    ///
    #[prost(int64, tag = "2")]
    pub login_event: i64,
    ///
    #[prost(int32, tag = "3")]
    pub teenagers_mode: i32,
    ///
    #[prost(int32, tag = "4")]
    pub lessons_mode: i32,
    ///
    #[prost(string, tag = "5")]
    pub tab: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub event_id: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub avid: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "8")]
    pub query: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "9")]
    pub an: i64,
    ///
    #[prost(int64, tag = "10")]
    pub is_fresh: i64,
    ///
    #[prost(string, tag = "11")]
    pub splash_guide: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "12")]
    pub splash_id: i64,
    ///
    #[prost(int64, tag = "13")]
    pub refresh_type: i64,
    ///
    #[prost(string, tag = "14")]
    pub user_act: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "15")]
    pub search_page_return: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteReq {
    ///
    #[prost(message, repeated, tag = "1")]
    pub his_info: ::prost::alloc::vec::Vec<HisInfo>,
    ///
    #[prost(string, tag = "2")]
    pub tab: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceType {
    ///
    #[prost(enumeration = "Dt", tag = "1")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "2")]
    pub icon: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dynamic {
    ///
    #[prost(message, optional, tag = "1")]
    pub dynamic: ::core::option::Option<super::super::dynamic::v2::DynamicItem>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FacialRecognitionVerifyReply {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FacialRecognitionVerifyReq {
    ///
    #[prost(enumeration = "FacialRecognitionVerifyFrom", tag = "1")]
    pub from: i32,
    ///
    #[prost(string, tag = "2")]
    pub device_token: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HisInfo {
    ///
    #[prost(string, tag = "1")]
    pub business: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub kid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistoryTabReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub tab: ::prost::alloc::vec::Vec<CursorTab>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistoryTabReq {
    ///
    #[prost(string, tag = "1")]
    pub business: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "HistorySource", tag = "2")]
    pub source: i32,
    ///
    #[prost(string, tag = "3")]
    pub keyword: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LatestHistoryReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub items: ::core::option::Option<CursorItem>,
    ///
    #[prost(string, tag = "2")]
    pub scene: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "3")]
    pub rtime: i64,
    ///
    #[prost(string, tag = "4")]
    pub flag: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LatestHistoryReq {
    ///
    #[prost(string, tag = "1")]
    pub business: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "2")]
    pub player_preload: ::core::option::Option<PlayerPreloadParams>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LikeButton {
    ///
    #[prost(int64, tag = "1")]
    pub aid: i64,
    ///
    #[prost(int32, tag = "2")]
    pub count: i32,
    ///
    #[prost(bool, tag = "3")]
    pub show_count: bool,
    ///
    #[prost(string, tag = "4")]
    pub event: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "5")]
    pub selected: i32,
    ///
    #[prost(string, tag = "6")]
    pub event_v2: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "7")]
    pub like_resource: ::core::option::Option<LikeButtonResource>,
    ///
    #[prost(message, optional, tag = "8")]
    pub dis_like_resource: ::core::option::Option<LikeButtonResource>,
    ///
    #[prost(message, optional, tag = "9")]
    pub like_night_resource: ::core::option::Option<LikeButtonResource>,
    ///
    #[prost(message, optional, tag = "10")]
    pub dis_like_night_resource: ::core::option::Option<LikeButtonResource>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LikeButtonResource {
    ///
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub hash: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LikeCard {
    ///
    #[prost(int64, tag = "1")]
    pub like: i64,
    ///
    #[prost(bool, tag = "2")]
    pub is_follow: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaCard {
    ///
    #[prost(string, tag = "1")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cur_title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub style: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub label: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "5")]
    pub but_first: ::core::option::Option<Button>,
    ///
    #[prost(message, optional, tag = "6")]
    pub but_second: ::core::option::Option<Supernatant>,
    ///
    #[prost(message, optional, tag = "7")]
    pub scores: ::core::option::Option<Scores>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaCommentReply {
    ///
    #[prost(string, tag = "1")]
    pub err_msg: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaCommentReq {
    ///
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaDetailReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub cast: ::core::option::Option<Cast>,
    ///
    #[prost(message, optional, tag = "2")]
    pub staff: ::core::option::Option<Staff>,
    ///
    #[prost(message, optional, tag = "3")]
    pub overview: ::core::option::Option<Overview>,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MediaDetailReq {
    ///
    #[prost(int64, tag = "1")]
    pub biz_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub biz_type: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MediaFollowReply {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaFollowReq {
    ///
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "ButType", tag = "2")]
    pub r#type: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaPerson {
    ///
    #[prost(string, tag = "1")]
    pub real_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub square_url: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub character: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub person_id: i64,
    ///
    #[prost(string, tag = "5")]
    pub r#type: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaRelationReply {
    ///
    #[prost(string, tag = "1")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "2")]
    pub has_more: bool,
    ///
    #[prost(message, repeated, tag = "3")]
    pub list: ::prost::alloc::vec::Vec<SmallItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaRelationReq {
    ///
    #[prost(int64, tag = "1")]
    pub biz_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub biz_type: i64,
    ///
    #[prost(int64, tag = "3")]
    pub feed_id: i64,
    ///
    #[prost(string, tag = "5")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "6")]
    pub ps: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaTabReply {
    ///
    #[prost(message, optional, tag = "1")]
    pub media_card: ::core::option::Option<MediaCard>,
    ///
    #[prost(message, repeated, tag = "2")]
    pub tab: ::prost::alloc::vec::Vec<ShowTab>,
    ///
    #[prost(int64, tag = "3")]
    pub default_tab_index: i64,
    ///
    #[prost(message, optional, tag = "4")]
    pub channel_info: ::core::option::Option<ChannelInfo>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaTabReq {
    ///
    #[prost(int64, tag = "1")]
    pub biz_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub biz_type: i64,
    ///
    #[prost(string, tag = "3")]
    pub source: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub spmid: ::prost::alloc::string::String,
    ///
    #[prost(map = "string, string", tag = "5")]
    pub args: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaVideoReply {
    ///
    #[prost(string, tag = "1")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "2")]
    pub has_more: bool,
    ///
    #[prost(message, repeated, tag = "3")]
    pub list: ::prost::alloc::vec::Vec<BigItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaVideoReq {
    ///
    #[prost(int64, tag = "1")]
    pub biz_id: i64,
    ///
    #[prost(int64, tag = "2")]
    pub biz_type: i64,
    ///
    #[prost(int64, tag = "3")]
    pub feed_id: i64,
    ///
    #[prost(string, tag = "5")]
    pub offset: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "6")]
    pub ps: i32,
    ///
    #[prost(message, optional, tag = "7")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModeStatusReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub user_models: ::prost::alloc::vec::Vec<UserModel>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModeStatusReq {
    ///
    #[prost(string, tag = "1")]
    pub device_token: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ModifyPwdReply {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModifyPwdReq {
    ///
    #[prost(string, tag = "1")]
    pub old_pwd: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub new_pwd: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub device_token: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NftFaceIcon {
    ///
    #[prost(int32, tag = "1")]
    pub region_type: i32,
    ///
    #[prost(string, tag = "2")]
    pub icon: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "3")]
    pub show_status: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NoReply {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OfficialVerify {
    ///
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    ///
    #[prost(string, tag = "2")]
    pub desc: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Overview {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Page {
    ///
    #[prost(int64, tag = "1")]
    pub pn: i64,
    ///
    #[prost(int64, tag = "2")]
    pub total: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerPreloadParams {
    ///
    #[prost(int64, tag = "1")]
    pub qn: i64,
    ///
    #[prost(int64, tag = "2")]
    pub fnver: i64,
    ///
    #[prost(int64, tag = "3")]
    pub fnval: i64,
    ///
    #[prost(int64, tag = "4")]
    pub force_host: i64,
    ///
    #[prost(int64, tag = "5")]
    pub fourk: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Policy {
    ///
    #[prost(int64, tag = "1")]
    pub interval: i64,
    ///
    #[prost(bool, tag = "2")]
    pub use_local_time: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReasonStyle {
    ///
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub text_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub bg_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub bg_color_night: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "6")]
    pub border_color: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "7")]
    pub border_color_night: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "8")]
    pub bg_style: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Relation {
    ///
    #[prost(int32, tag = "1")]
    pub status: i32,
    ///
    #[prost(int32, tag = "2")]
    pub is_follow: i32,
    ///
    #[prost(int32, tag = "3")]
    pub is_followed: i32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResultItem {
    ///
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub keyword: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "4")]
    pub position: i32,
    ///
    #[prost(string, tag = "5")]
    pub cover: ::prost::alloc::string::String,
    ///
    #[prost(double, tag = "6")]
    pub cover_size: f64,
    ///
    #[prost(string, tag = "7")]
    pub sug_type: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "8")]
    pub term_type: i32,
    ///
    #[prost(string, tag = "9")]
    pub goto: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "10")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(message, optional, tag = "11")]
    pub official_verify: ::core::option::Option<OfficialVerify>,
    ///
    #[prost(string, tag = "12")]
    pub param: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "13")]
    pub mid: i64,
    ///
    #[prost(int32, tag = "14")]
    pub fans: i32,
    ///
    #[prost(int32, tag = "15")]
    pub level: i32,
    ///
    #[prost(int32, tag = "16")]
    pub archives: i32,
    ///
    #[prost(int64, tag = "17")]
    pub ptime: i64,
    ///
    #[prost(string, tag = "18")]
    pub season_type_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "19")]
    pub area: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "20")]
    pub style: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "21")]
    pub label: ::prost::alloc::string::String,
    ///
    #[prost(double, tag = "22")]
    pub rating: f64,
    ///
    #[prost(int32, tag = "23")]
    pub vote: i32,
    ///
    #[prost(message, repeated, tag = "24")]
    pub badges: ::prost::alloc::vec::Vec<ReasonStyle>,
    ///
    #[prost(string, tag = "25")]
    pub styles: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "26")]
    pub module_id: i64,
    ///
    #[prost(string, tag = "27")]
    pub live_link: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "28")]
    pub face_nft_new: i32,
    ///
    #[prost(message, optional, tag = "29")]
    pub nft_face_icon: ::core::option::Option<NftFaceIcon>,
    ///
    #[prost(int32, tag = "30")]
    pub is_senior_member: i32,
    ///
    #[prost(int32, tag = "31")]
    pub is_sug_style_exp: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Scores {
    ///
    #[prost(float, tag = "1")]
    pub score: f32,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchArchiveReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub archives: ::prost::alloc::vec::Vec<Arc>,
    ///
    #[prost(int64, tag = "2")]
    pub total: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchArchiveReq {
    ///
    #[prost(string, tag = "1")]
    pub keyword: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub mid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub pn: i64,
    ///
    #[prost(int64, tag = "4")]
    pub ps: i64,
    ///
    #[prost(message, optional, tag = "5")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchDynamicReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub dynamics: ::prost::alloc::vec::Vec<Dynamic>,
    ///
    #[prost(int64, tag = "2")]
    pub total: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchDynamicReq {
    ///
    #[prost(string, tag = "1")]
    pub keyword: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub mid: i64,
    ///
    #[prost(int64, tag = "3")]
    pub pn: i64,
    ///
    #[prost(int64, tag = "4")]
    pub ps: i64,
    ///
    #[prost(message, optional, tag = "5")]
    pub player_args: ::core::option::Option<
        super::super::archive::middleware::v1::PlayerArgs,
    >,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchReply {
    ///
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<CursorItem>,
    ///
    #[prost(bool, tag = "2")]
    pub has_more: bool,
    ///
    #[prost(message, optional, tag = "3")]
    pub page: ::core::option::Option<Page>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchReq {
    ///
    #[prost(string, tag = "1")]
    pub keyword: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub pn: i64,
    ///
    #[prost(string, tag = "3")]
    pub business: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchTabReply {
    ///
    #[prost(int64, tag = "1")]
    pub focus: i64,
    ///
    #[prost(message, repeated, tag = "2")]
    pub tabs: ::prost::alloc::vec::Vec<Tab>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchTabReq {
    ///
    #[prost(string, tag = "1")]
    pub keyword: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "2")]
    pub mid: i64,
    ///
    #[prost(enumeration = "From", tag = "3")]
    pub from: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetTeenagersModelAgeReply {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTeenagersModelAgeReq {
    ///
    #[prost(string, tag = "1")]
    pub pwd: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "PwdFrom", tag = "2")]
    pub pwd_from: i32,
    ///
    #[prost(string, tag = "3")]
    pub device_token: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "4")]
    pub age: i32,
    ///
    #[prost(bool, tag = "5")]
    pub is_dynamic: bool,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowTab {
    ///
    #[prost(enumeration = "TabType", tag = "1")]
    pub tab_type: i32,
    ///
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmallItem {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub cover_image_uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "4")]
    pub cover_right_text: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "5")]
    pub cover_left_text1: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "6")]
    pub cover_left_icon1: i64,
    ///
    #[prost(string, tag = "7")]
    pub cover_left_text2: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "8")]
    pub cover_left_icon2: i64,
    ///
    #[prost(int64, tag = "9")]
    pub param: i64,
    ///
    #[prost(int64, tag = "10")]
    pub mid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Staff {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestionResult3Reply {
    ///
    #[prost(string, tag = "1")]
    pub trackid: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub list: ::prost::alloc::vec::Vec<ResultItem>,
    ///
    #[prost(string, tag = "3")]
    pub exp_str: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestionResult3Req {
    ///
    #[prost(string, tag = "1")]
    pub keyword: ::prost::alloc::string::String,
    ///
    #[prost(int32, tag = "2")]
    pub highlight: i32,
    ///
    #[prost(int32, tag = "3")]
    pub teenagers_mode: i32,
    ///
    #[prost(string, tag = "4")]
    pub user_act: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Supernatant {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(message, repeated, tag = "2")]
    pub item: ::prost::alloc::vec::Vec<CommentItem>,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tab {
    ///
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateReserveStartTimeReply {
    ///
    #[prost(string, tag = "1")]
    pub desc_text: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateReserveStartTimeReq {
    ///
    #[prost(int64, tag = "1")]
    pub sid: i64,
    ///
    #[prost(int64, tag = "2")]
    pub new_live_plan_start_time: i64,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateStatusReply {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateStatusReq {
    ///
    #[prost(string, tag = "1")]
    pub pwd: ::prost::alloc::string::String,
    ///
    #[prost(bool, tag = "2")]
    pub switch: bool,
    ///
    #[prost(enumeration = "PwdFrom", tag = "3")]
    pub pwd_from: i32,
    ///
    #[prost(string, tag = "4")]
    pub device_token: ::prost::alloc::string::String,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserCard {
    ///
    #[prost(string, tag = "1")]
    pub user_name: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "2")]
    pub user_face: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub user_url: ::prost::alloc::string::String,
    ///
    #[prost(int64, tag = "4")]
    pub mid: i64,
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserModel {
    ///
    #[prost(int64, tag = "1")]
    pub mid: i64,
    ///
    #[prost(string, tag = "2")]
    pub mode: ::prost::alloc::string::String,
    ///
    #[prost(string, tag = "3")]
    pub wsxcde: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "ModelStatus", tag = "4")]
    pub status: i32,
    ///
    #[prost(message, optional, tag = "5")]
    pub policy: ::core::option::Option<Policy>,
    ///
    #[prost(bool, tag = "6")]
    pub is_forced: bool,
    ///
    #[prost(bool, tag = "7")]
    pub must_teen: bool,
    ///
    #[prost(bool, tag = "8")]
    pub must_real_name: bool,
    ///
    #[prost(bool, tag = "9")]
    pub is_parent_control: bool,
    ///
    #[prost(int32, tag = "10")]
    pub age: i32,
}
///
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VerifyPwdReply {}
///
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifyPwdReq {
    ///
    #[prost(string, tag = "1")]
    pub pwd: ::prost::alloc::string::String,
    ///
    #[prost(enumeration = "PwdFrom", tag = "2")]
    pub pwd_from: i32,
    ///
    #[prost(bool, tag = "3")]
    pub is_dynamic: bool,
    ///
    #[prost(bool, tag = "4")]
    pub close_device: bool,
    ///
    #[prost(string, tag = "5")]
    pub device_token: ::prost::alloc::string::String,
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ButType {
    ///
    ButInvalid = 0,
    ///
    ButRedirect = 1,
    ///
    ButLike = 2,
}
impl ButType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ButInvalid => "BUT_INVALID",
            Self::ButRedirect => "BUT_REDIRECT",
            Self::ButLike => "BUT_LIKE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BUT_INVALID" => Some(Self::ButInvalid),
            "BUT_REDIRECT" => Some(Self::ButRedirect),
            "BUT_LIKE" => Some(Self::ButLike),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CommentType {
    ///
    None = 0,
    ///
    Redirect = 1,
    ///
    Judge = 2,
}
impl CommentType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "comment_type_none",
            Self::Redirect => "comment_type_redirect",
            Self::Judge => "comment_type_judge",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "comment_type_none" => Some(Self::None),
            "comment_type_redirect" => Some(Self::Redirect),
            "comment_type_judge" => Some(Self::Judge),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Dt {
    ///
    Unknown = 0,
    ///
    Phone = 1,
    ///
    Pad = 2,
    ///
    Pc = 3,
    ///
    Tv = 4,
    ///
    Car = 5,
    ///
    Iot = 6,
    ///
    AndPad = 7,
}
impl Dt {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "Unknown",
            Self::Phone => "Phone",
            Self::Pad => "Pad",
            Self::Pc => "PC",
            Self::Tv => "TV",
            Self::Car => "Car",
            Self::Iot => "Iot",
            Self::AndPad => "AndPad",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Unknown" => Some(Self::Unknown),
            "Phone" => Some(Self::Phone),
            "Pad" => Some(Self::Pad),
            "PC" => Some(Self::Pc),
            "TV" => Some(Self::Tv),
            "Car" => Some(Self::Car),
            "Iot" => Some(Self::Iot),
            "AndPad" => Some(Self::AndPad),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FacialRecognitionVerifyFrom {
    ///
    VerifyUnknownFrom = 0,
    ///
    VerifyFromGuardian = 1,
    ///
    VerifyFromAppeal = 2,
}
impl FacialRecognitionVerifyFrom {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::VerifyUnknownFrom => "VerifyUnknownFrom",
            Self::VerifyFromGuardian => "VerifyFromGuardian",
            Self::VerifyFromAppeal => "VerifyFromAppeal",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VerifyUnknownFrom" => Some(Self::VerifyUnknownFrom),
            "VerifyFromGuardian" => Some(Self::VerifyFromGuardian),
            "VerifyFromAppeal" => Some(Self::VerifyFromAppeal),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum From {
    ///
    ArchiveTab = 0,
    ///
    DynamicTab = 1,
}
impl From {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ArchiveTab => "ArchiveTab",
            Self::DynamicTab => "DynamicTab",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ArchiveTab" => Some(Self::ArchiveTab),
            "DynamicTab" => Some(Self::DynamicTab),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HistorySource {
    ///
    History = 0,
    ///
    Shopping = 1,
}
impl HistorySource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::History => "history",
            Self::Shopping => "shopping",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "history" => Some(Self::History),
            "shopping" => Some(Self::Shopping),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ModelStatus {
    ///
    CloseStatus = 0,
    ///
    OpenStatus = 1,
    ///
    NotSetStatus = 2,
}
impl ModelStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CloseStatus => "CloseStatus",
            Self::OpenStatus => "OpenStatus",
            Self::NotSetStatus => "NotSetStatus",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CloseStatus" => Some(Self::CloseStatus),
            "OpenStatus" => Some(Self::OpenStatus),
            "NotSetStatus" => Some(Self::NotSetStatus),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PwdFrom {
    ///
    UnknownFrom = 0,
    ///
    TeenagersAntiAddictionFrom = 1,
    ///
    TeenagersCurfewFrom = 2,
    ///
    TeenagersLoginFrom = 3,
    ///
    TeenagersLogOutFrom = 4,
    ///
    FamilyAntiAddictionFrom = 5,
    ///
    FamilyCurfewFrom = 6,
    ///
    FamilyLogOutFrom = 7,
    ///
    FamilyTimeLockFrom = 8,
    ///
    TeenagersQuitPwdFrom = 9,
    ///
    TeenagersModifyPwdFrom = 10,
    ///
    FamilyQuitFrom = 11,
    ///
    OsTeenagersLogin = 12,
    ///
    OsTeenagersLogout = 13,
    ///
    TeenagersSetAge = 14,
    ///
    OsTeenagersSetAge = 15,
}
impl PwdFrom {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownFrom => "UnknownFrom",
            Self::TeenagersAntiAddictionFrom => "TeenagersAntiAddictionFrom",
            Self::TeenagersCurfewFrom => "TeenagersCurfewFrom",
            Self::TeenagersLoginFrom => "TeenagersLoginFrom",
            Self::TeenagersLogOutFrom => "TeenagersLogOutFrom",
            Self::FamilyAntiAddictionFrom => "FamilyAntiAddictionFrom",
            Self::FamilyCurfewFrom => "FamilyCurfewFrom",
            Self::FamilyLogOutFrom => "FamilyLogOutFrom",
            Self::FamilyTimeLockFrom => "FamilyTimeLockFrom",
            Self::TeenagersQuitPwdFrom => "TeenagersQuitPwdFrom",
            Self::TeenagersModifyPwdFrom => "TeenagersModifyPwdFrom",
            Self::FamilyQuitFrom => "FamilyQuitFrom",
            Self::OsTeenagersLogin => "OSTeenagersLogin",
            Self::OsTeenagersLogout => "OSTeenagersLogout",
            Self::TeenagersSetAge => "TeenagersSetAge",
            Self::OsTeenagersSetAge => "OSTeenagersSetAge",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UnknownFrom" => Some(Self::UnknownFrom),
            "TeenagersAntiAddictionFrom" => Some(Self::TeenagersAntiAddictionFrom),
            "TeenagersCurfewFrom" => Some(Self::TeenagersCurfewFrom),
            "TeenagersLoginFrom" => Some(Self::TeenagersLoginFrom),
            "TeenagersLogOutFrom" => Some(Self::TeenagersLogOutFrom),
            "FamilyAntiAddictionFrom" => Some(Self::FamilyAntiAddictionFrom),
            "FamilyCurfewFrom" => Some(Self::FamilyCurfewFrom),
            "FamilyLogOutFrom" => Some(Self::FamilyLogOutFrom),
            "FamilyTimeLockFrom" => Some(Self::FamilyTimeLockFrom),
            "TeenagersQuitPwdFrom" => Some(Self::TeenagersQuitPwdFrom),
            "TeenagersModifyPwdFrom" => Some(Self::TeenagersModifyPwdFrom),
            "FamilyQuitFrom" => Some(Self::FamilyQuitFrom),
            "OSTeenagersLogin" => Some(Self::OsTeenagersLogin),
            "OSTeenagersLogout" => Some(Self::OsTeenagersLogout),
            "TeenagersSetAge" => Some(Self::TeenagersSetAge),
            "OSTeenagersSetAge" => Some(Self::OsTeenagersSetAge),
            _ => None,
        }
    }
}
///
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TabType {
    ///
    TabInvalid = 0,
    ///
    TabOgvDetail = 6,
    ///
    TabOgvReply = 7,
    ///
    TabFeedBid = 8,
    ///
    TabFeedSmall = 9,
}
impl TabType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TabInvalid => "TAB_INVALID",
            Self::TabOgvDetail => "TAB_OGV_DETAIL",
            Self::TabOgvReply => "TAB_OGV_REPLY",
            Self::TabFeedBid => "TAB_FEED_BID",
            Self::TabFeedSmall => "TAB_FEED_SMALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TAB_INVALID" => Some(Self::TabInvalid),
            "TAB_OGV_DETAIL" => Some(Self::TabOgvDetail),
            "TAB_OGV_REPLY" => Some(Self::TabOgvReply),
            "TAB_FEED_BID" => Some(Self::TabFeedBid),
            "TAB_FEED_SMALL" => Some(Self::TabFeedSmall),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod history_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct HistoryClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> HistoryClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> HistoryClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            HistoryClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn clear(
            &mut self,
            request: impl tonic::IntoRequest<super::ClearReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.History/Clear",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.interfaces.v1.History", "Clear"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn cursor(
            &mut self,
            request: impl tonic::IntoRequest<super::CursorReq>,
        ) -> std::result::Result<tonic::Response<super::CursorReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.History/Cursor",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.interfaces.v1.History", "Cursor"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn cursor_v2(
            &mut self,
            request: impl tonic::IntoRequest<super::CursorV2Req>,
        ) -> std::result::Result<tonic::Response<super::CursorV2Reply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.History/CursorV2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.interfaces.v1.History", "CursorV2"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.History/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.interfaces.v1.History", "Delete"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn history_tab(
            &mut self,
            request: impl tonic::IntoRequest<super::HistoryTabReq>,
        ) -> std::result::Result<
            tonic::Response<super::HistoryTabReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.History/HistoryTab",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.interfaces.v1.History", "HistoryTab"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn history_tab_v2(
            &mut self,
            request: impl tonic::IntoRequest<super::HistoryTabReq>,
        ) -> std::result::Result<
            tonic::Response<super::HistoryTabReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.History/HistoryTabV2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.interfaces.v1.History", "HistoryTabV2"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn latest_history(
            &mut self,
            request: impl tonic::IntoRequest<super::LatestHistoryReq>,
        ) -> std::result::Result<
            tonic::Response<super::LatestHistoryReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.History/LatestHistory",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.interfaces.v1.History",
                        "LatestHistory",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn search(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchReq>,
        ) -> std::result::Result<tonic::Response<super::SearchReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.History/Search",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.interfaces.v1.History", "Search"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod media_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct MediaClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> MediaClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MediaClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MediaClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn media_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::MediaCommentReq>,
        ) -> std::result::Result<
            tonic::Response<super::MediaCommentReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.Media/MediaComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.interfaces.v1.Media", "MediaComment"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn media_detail(
            &mut self,
            request: impl tonic::IntoRequest<super::MediaDetailReq>,
        ) -> std::result::Result<
            tonic::Response<super::MediaDetailReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.Media/MediaDetail",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.interfaces.v1.Media", "MediaDetail"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn media_follow(
            &mut self,
            request: impl tonic::IntoRequest<super::MediaFollowReq>,
        ) -> std::result::Result<
            tonic::Response<super::MediaFollowReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.Media/MediaFollow",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.interfaces.v1.Media", "MediaFollow"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn media_relation(
            &mut self,
            request: impl tonic::IntoRequest<super::MediaRelationReq>,
        ) -> std::result::Result<
            tonic::Response<super::MediaRelationReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.Media/MediaRelation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.interfaces.v1.Media", "MediaRelation"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn media_tab(
            &mut self,
            request: impl tonic::IntoRequest<super::MediaTabReq>,
        ) -> std::result::Result<tonic::Response<super::MediaTabReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.Media/MediaTab",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("bilibili.app.interfaces.v1.Media", "MediaTab"));
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn media_video(
            &mut self,
            request: impl tonic::IntoRequest<super::MediaVideoReq>,
        ) -> std::result::Result<
            tonic::Response<super::MediaVideoReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.Media/MediaVideo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.interfaces.v1.Media", "MediaVideo"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod search_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct SearchClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SearchClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SearchClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SearchClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn default_words(
            &mut self,
            request: impl tonic::IntoRequest<super::DefaultWordsReq>,
        ) -> std::result::Result<
            tonic::Response<super::DefaultWordsReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.Search/DefaultWords",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.interfaces.v1.Search", "DefaultWords"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn suggest3(
            &mut self,
            request: impl tonic::IntoRequest<super::SuggestionResult3Req>,
        ) -> std::result::Result<
            tonic::Response<super::SuggestionResult3Reply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.Search/Suggest3",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.interfaces.v1.Search", "Suggest3"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod search_test_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct SearchTestClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SearchTestClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SearchTestClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SearchTestClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn not_exist(
            &mut self,
            request: impl tonic::IntoRequest<super::SuggestionResult3Req>,
        ) -> std::result::Result<
            tonic::Response<super::SuggestionResult3Reply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.SearchTest/NotExist",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.interfaces.v1.SearchTest", "NotExist"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod space_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct SpaceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SpaceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SpaceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SpaceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn search_archive(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchArchiveReq>,
        ) -> std::result::Result<
            tonic::Response<super::SearchArchiveReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.Space/SearchArchive",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.interfaces.v1.Space", "SearchArchive"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn search_dynamic(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchDynamicReq>,
        ) -> std::result::Result<
            tonic::Response<super::SearchDynamicReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.Space/SearchDynamic",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.interfaces.v1.Space", "SearchDynamic"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn search_tab(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchTabReq>,
        ) -> std::result::Result<tonic::Response<super::SearchTabReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.Space/SearchTab",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.interfaces.v1.Space", "SearchTab"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn update_reserve_start_time(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateReserveStartTimeReq>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateReserveStartTimeReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.Space/UpdateReserveStartTime",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.interfaces.v1.Space",
                        "UpdateReserveStartTime",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod teenagers_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    #[derive(Debug, Clone)]
    pub struct TeenagersClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TeenagersClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TeenagersClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TeenagersClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        ///
        pub async fn facial_recognition_verify(
            &mut self,
            request: impl tonic::IntoRequest<super::FacialRecognitionVerifyReq>,
        ) -> std::result::Result<
            tonic::Response<super::FacialRecognitionVerifyReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.Teenagers/FacialRecognitionVerify",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.interfaces.v1.Teenagers",
                        "FacialRecognitionVerify",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn mode_status(
            &mut self,
            request: impl tonic::IntoRequest<super::ModeStatusReq>,
        ) -> std::result::Result<
            tonic::Response<super::ModeStatusReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.Teenagers/ModeStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.interfaces.v1.Teenagers", "ModeStatus"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn modify_pwd(
            &mut self,
            request: impl tonic::IntoRequest<super::ModifyPwdReq>,
        ) -> std::result::Result<tonic::Response<super::ModifyPwdReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.Teenagers/ModifyPwd",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.interfaces.v1.Teenagers", "ModifyPwd"),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn set_teenagers_model_age(
            &mut self,
            request: impl tonic::IntoRequest<super::SetTeenagersModelAgeReq>,
        ) -> std::result::Result<
            tonic::Response<super::SetTeenagersModelAgeReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.Teenagers/SetTeenagersModelAge",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.interfaces.v1.Teenagers",
                        "SetTeenagersModelAge",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn update_status(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateStatusReq>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateStatusReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.Teenagers/UpdateStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "bilibili.app.interfaces.v1.Teenagers",
                        "UpdateStatus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        pub async fn verify_pwd(
            &mut self,
            request: impl tonic::IntoRequest<super::VerifyPwdReq>,
        ) -> std::result::Result<tonic::Response<super::VerifyPwdReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/bilibili.app.interfaces.v1.Teenagers/VerifyPwd",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("bilibili.app.interfaces.v1.Teenagers", "VerifyPwd"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod history_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with HistoryServer.
    #[async_trait]
    pub trait History: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn clear(
            &self,
            request: tonic::Request<super::ClearReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status>;
        ///
        async fn cursor(
            &self,
            request: tonic::Request<super::CursorReq>,
        ) -> std::result::Result<tonic::Response<super::CursorReply>, tonic::Status>;
        ///
        async fn cursor_v2(
            &self,
            request: tonic::Request<super::CursorV2Req>,
        ) -> std::result::Result<tonic::Response<super::CursorV2Reply>, tonic::Status>;
        ///
        async fn delete(
            &self,
            request: tonic::Request<super::DeleteReq>,
        ) -> std::result::Result<tonic::Response<super::NoReply>, tonic::Status>;
        ///
        async fn history_tab(
            &self,
            request: tonic::Request<super::HistoryTabReq>,
        ) -> std::result::Result<tonic::Response<super::HistoryTabReply>, tonic::Status>;
        ///
        async fn history_tab_v2(
            &self,
            request: tonic::Request<super::HistoryTabReq>,
        ) -> std::result::Result<tonic::Response<super::HistoryTabReply>, tonic::Status>;
        ///
        async fn latest_history(
            &self,
            request: tonic::Request<super::LatestHistoryReq>,
        ) -> std::result::Result<
            tonic::Response<super::LatestHistoryReply>,
            tonic::Status,
        >;
        ///
        async fn search(
            &self,
            request: tonic::Request<super::SearchReq>,
        ) -> std::result::Result<tonic::Response<super::SearchReply>, tonic::Status>;
    }
    ///
    #[derive(Debug)]
    pub struct HistoryServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> HistoryServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for HistoryServer<T>
    where
        T: History,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.app.interfaces.v1.History/Clear" => {
                    #[allow(non_camel_case_types)]
                    struct ClearSvc<T: History>(pub Arc<T>);
                    impl<T: History> tonic::server::UnaryService<super::ClearReq>
                    for ClearSvc<T> {
                        type Response = super::NoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ClearReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as History>::clear(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ClearSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.History/Cursor" => {
                    #[allow(non_camel_case_types)]
                    struct CursorSvc<T: History>(pub Arc<T>);
                    impl<T: History> tonic::server::UnaryService<super::CursorReq>
                    for CursorSvc<T> {
                        type Response = super::CursorReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CursorReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as History>::cursor(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CursorSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.History/CursorV2" => {
                    #[allow(non_camel_case_types)]
                    struct CursorV2Svc<T: History>(pub Arc<T>);
                    impl<T: History> tonic::server::UnaryService<super::CursorV2Req>
                    for CursorV2Svc<T> {
                        type Response = super::CursorV2Reply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CursorV2Req>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as History>::cursor_v2(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CursorV2Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.History/Delete" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteSvc<T: History>(pub Arc<T>);
                    impl<T: History> tonic::server::UnaryService<super::DeleteReq>
                    for DeleteSvc<T> {
                        type Response = super::NoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as History>::delete(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.History/HistoryTab" => {
                    #[allow(non_camel_case_types)]
                    struct HistoryTabSvc<T: History>(pub Arc<T>);
                    impl<T: History> tonic::server::UnaryService<super::HistoryTabReq>
                    for HistoryTabSvc<T> {
                        type Response = super::HistoryTabReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HistoryTabReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as History>::history_tab(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = HistoryTabSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.History/HistoryTabV2" => {
                    #[allow(non_camel_case_types)]
                    struct HistoryTabV2Svc<T: History>(pub Arc<T>);
                    impl<T: History> tonic::server::UnaryService<super::HistoryTabReq>
                    for HistoryTabV2Svc<T> {
                        type Response = super::HistoryTabReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HistoryTabReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as History>::history_tab_v2(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = HistoryTabV2Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.History/LatestHistory" => {
                    #[allow(non_camel_case_types)]
                    struct LatestHistorySvc<T: History>(pub Arc<T>);
                    impl<T: History> tonic::server::UnaryService<super::LatestHistoryReq>
                    for LatestHistorySvc<T> {
                        type Response = super::LatestHistoryReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LatestHistoryReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as History>::latest_history(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LatestHistorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.History/Search" => {
                    #[allow(non_camel_case_types)]
                    struct SearchSvc<T: History>(pub Arc<T>);
                    impl<T: History> tonic::server::UnaryService<super::SearchReq>
                    for SearchSvc<T> {
                        type Response = super::SearchReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SearchReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as History>::search(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SearchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for HistoryServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.app.interfaces.v1.History";
    impl<T> tonic::server::NamedService for HistoryServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod media_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with MediaServer.
    #[async_trait]
    pub trait Media: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn media_comment(
            &self,
            request: tonic::Request<super::MediaCommentReq>,
        ) -> std::result::Result<
            tonic::Response<super::MediaCommentReply>,
            tonic::Status,
        >;
        ///
        async fn media_detail(
            &self,
            request: tonic::Request<super::MediaDetailReq>,
        ) -> std::result::Result<
            tonic::Response<super::MediaDetailReply>,
            tonic::Status,
        >;
        ///
        async fn media_follow(
            &self,
            request: tonic::Request<super::MediaFollowReq>,
        ) -> std::result::Result<
            tonic::Response<super::MediaFollowReply>,
            tonic::Status,
        >;
        ///
        async fn media_relation(
            &self,
            request: tonic::Request<super::MediaRelationReq>,
        ) -> std::result::Result<
            tonic::Response<super::MediaRelationReply>,
            tonic::Status,
        >;
        ///
        async fn media_tab(
            &self,
            request: tonic::Request<super::MediaTabReq>,
        ) -> std::result::Result<tonic::Response<super::MediaTabReply>, tonic::Status>;
        ///
        async fn media_video(
            &self,
            request: tonic::Request<super::MediaVideoReq>,
        ) -> std::result::Result<tonic::Response<super::MediaVideoReply>, tonic::Status>;
    }
    ///
    #[derive(Debug)]
    pub struct MediaServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> MediaServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for MediaServer<T>
    where
        T: Media,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.app.interfaces.v1.Media/MediaComment" => {
                    #[allow(non_camel_case_types)]
                    struct MediaCommentSvc<T: Media>(pub Arc<T>);
                    impl<T: Media> tonic::server::UnaryService<super::MediaCommentReq>
                    for MediaCommentSvc<T> {
                        type Response = super::MediaCommentReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MediaCommentReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Media>::media_comment(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MediaCommentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.Media/MediaDetail" => {
                    #[allow(non_camel_case_types)]
                    struct MediaDetailSvc<T: Media>(pub Arc<T>);
                    impl<T: Media> tonic::server::UnaryService<super::MediaDetailReq>
                    for MediaDetailSvc<T> {
                        type Response = super::MediaDetailReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MediaDetailReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Media>::media_detail(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MediaDetailSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.Media/MediaFollow" => {
                    #[allow(non_camel_case_types)]
                    struct MediaFollowSvc<T: Media>(pub Arc<T>);
                    impl<T: Media> tonic::server::UnaryService<super::MediaFollowReq>
                    for MediaFollowSvc<T> {
                        type Response = super::MediaFollowReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MediaFollowReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Media>::media_follow(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MediaFollowSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.Media/MediaRelation" => {
                    #[allow(non_camel_case_types)]
                    struct MediaRelationSvc<T: Media>(pub Arc<T>);
                    impl<T: Media> tonic::server::UnaryService<super::MediaRelationReq>
                    for MediaRelationSvc<T> {
                        type Response = super::MediaRelationReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MediaRelationReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Media>::media_relation(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MediaRelationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.Media/MediaTab" => {
                    #[allow(non_camel_case_types)]
                    struct MediaTabSvc<T: Media>(pub Arc<T>);
                    impl<T: Media> tonic::server::UnaryService<super::MediaTabReq>
                    for MediaTabSvc<T> {
                        type Response = super::MediaTabReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MediaTabReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Media>::media_tab(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MediaTabSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.Media/MediaVideo" => {
                    #[allow(non_camel_case_types)]
                    struct MediaVideoSvc<T: Media>(pub Arc<T>);
                    impl<T: Media> tonic::server::UnaryService<super::MediaVideoReq>
                    for MediaVideoSvc<T> {
                        type Response = super::MediaVideoReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MediaVideoReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Media>::media_video(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MediaVideoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for MediaServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.app.interfaces.v1.Media";
    impl<T> tonic::server::NamedService for MediaServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod search_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SearchServer.
    #[async_trait]
    pub trait Search: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn default_words(
            &self,
            request: tonic::Request<super::DefaultWordsReq>,
        ) -> std::result::Result<
            tonic::Response<super::DefaultWordsReply>,
            tonic::Status,
        >;
        ///
        async fn suggest3(
            &self,
            request: tonic::Request<super::SuggestionResult3Req>,
        ) -> std::result::Result<
            tonic::Response<super::SuggestionResult3Reply>,
            tonic::Status,
        >;
    }
    ///
    #[derive(Debug)]
    pub struct SearchServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SearchServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for SearchServer<T>
    where
        T: Search,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.app.interfaces.v1.Search/DefaultWords" => {
                    #[allow(non_camel_case_types)]
                    struct DefaultWordsSvc<T: Search>(pub Arc<T>);
                    impl<T: Search> tonic::server::UnaryService<super::DefaultWordsReq>
                    for DefaultWordsSvc<T> {
                        type Response = super::DefaultWordsReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DefaultWordsReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Search>::default_words(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DefaultWordsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.Search/Suggest3" => {
                    #[allow(non_camel_case_types)]
                    struct Suggest3Svc<T: Search>(pub Arc<T>);
                    impl<
                        T: Search,
                    > tonic::server::UnaryService<super::SuggestionResult3Req>
                    for Suggest3Svc<T> {
                        type Response = super::SuggestionResult3Reply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SuggestionResult3Req>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Search>::suggest3(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = Suggest3Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SearchServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.app.interfaces.v1.Search";
    impl<T> tonic::server::NamedService for SearchServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod search_test_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SearchTestServer.
    #[async_trait]
    pub trait SearchTest: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn not_exist(
            &self,
            request: tonic::Request<super::SuggestionResult3Req>,
        ) -> std::result::Result<
            tonic::Response<super::SuggestionResult3Reply>,
            tonic::Status,
        >;
    }
    ///
    #[derive(Debug)]
    pub struct SearchTestServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SearchTestServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for SearchTestServer<T>
    where
        T: SearchTest,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.app.interfaces.v1.SearchTest/NotExist" => {
                    #[allow(non_camel_case_types)]
                    struct NotExistSvc<T: SearchTest>(pub Arc<T>);
                    impl<
                        T: SearchTest,
                    > tonic::server::UnaryService<super::SuggestionResult3Req>
                    for NotExistSvc<T> {
                        type Response = super::SuggestionResult3Reply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SuggestionResult3Req>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SearchTest>::not_exist(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = NotExistSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SearchTestServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.app.interfaces.v1.SearchTest";
    impl<T> tonic::server::NamedService for SearchTestServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod space_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SpaceServer.
    #[async_trait]
    pub trait Space: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn search_archive(
            &self,
            request: tonic::Request<super::SearchArchiveReq>,
        ) -> std::result::Result<
            tonic::Response<super::SearchArchiveReply>,
            tonic::Status,
        >;
        ///
        async fn search_dynamic(
            &self,
            request: tonic::Request<super::SearchDynamicReq>,
        ) -> std::result::Result<
            tonic::Response<super::SearchDynamicReply>,
            tonic::Status,
        >;
        ///
        async fn search_tab(
            &self,
            request: tonic::Request<super::SearchTabReq>,
        ) -> std::result::Result<tonic::Response<super::SearchTabReply>, tonic::Status>;
        ///
        async fn update_reserve_start_time(
            &self,
            request: tonic::Request<super::UpdateReserveStartTimeReq>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateReserveStartTimeReply>,
            tonic::Status,
        >;
    }
    ///
    #[derive(Debug)]
    pub struct SpaceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SpaceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for SpaceServer<T>
    where
        T: Space,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.app.interfaces.v1.Space/SearchArchive" => {
                    #[allow(non_camel_case_types)]
                    struct SearchArchiveSvc<T: Space>(pub Arc<T>);
                    impl<T: Space> tonic::server::UnaryService<super::SearchArchiveReq>
                    for SearchArchiveSvc<T> {
                        type Response = super::SearchArchiveReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SearchArchiveReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Space>::search_archive(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SearchArchiveSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.Space/SearchDynamic" => {
                    #[allow(non_camel_case_types)]
                    struct SearchDynamicSvc<T: Space>(pub Arc<T>);
                    impl<T: Space> tonic::server::UnaryService<super::SearchDynamicReq>
                    for SearchDynamicSvc<T> {
                        type Response = super::SearchDynamicReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SearchDynamicReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Space>::search_dynamic(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SearchDynamicSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.Space/SearchTab" => {
                    #[allow(non_camel_case_types)]
                    struct SearchTabSvc<T: Space>(pub Arc<T>);
                    impl<T: Space> tonic::server::UnaryService<super::SearchTabReq>
                    for SearchTabSvc<T> {
                        type Response = super::SearchTabReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SearchTabReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Space>::search_tab(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SearchTabSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.Space/UpdateReserveStartTime" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateReserveStartTimeSvc<T: Space>(pub Arc<T>);
                    impl<
                        T: Space,
                    > tonic::server::UnaryService<super::UpdateReserveStartTimeReq>
                    for UpdateReserveStartTimeSvc<T> {
                        type Response = super::UpdateReserveStartTimeReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateReserveStartTimeReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Space>::update_reserve_start_time(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateReserveStartTimeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SpaceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.app.interfaces.v1.Space";
    impl<T> tonic::server::NamedService for SpaceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod teenagers_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with TeenagersServer.
    #[async_trait]
    pub trait Teenagers: std::marker::Send + std::marker::Sync + 'static {
        ///
        async fn facial_recognition_verify(
            &self,
            request: tonic::Request<super::FacialRecognitionVerifyReq>,
        ) -> std::result::Result<
            tonic::Response<super::FacialRecognitionVerifyReply>,
            tonic::Status,
        >;
        ///
        async fn mode_status(
            &self,
            request: tonic::Request<super::ModeStatusReq>,
        ) -> std::result::Result<tonic::Response<super::ModeStatusReply>, tonic::Status>;
        ///
        async fn modify_pwd(
            &self,
            request: tonic::Request<super::ModifyPwdReq>,
        ) -> std::result::Result<tonic::Response<super::ModifyPwdReply>, tonic::Status>;
        ///
        async fn set_teenagers_model_age(
            &self,
            request: tonic::Request<super::SetTeenagersModelAgeReq>,
        ) -> std::result::Result<
            tonic::Response<super::SetTeenagersModelAgeReply>,
            tonic::Status,
        >;
        ///
        async fn update_status(
            &self,
            request: tonic::Request<super::UpdateStatusReq>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateStatusReply>,
            tonic::Status,
        >;
        ///
        async fn verify_pwd(
            &self,
            request: tonic::Request<super::VerifyPwdReq>,
        ) -> std::result::Result<tonic::Response<super::VerifyPwdReply>, tonic::Status>;
    }
    ///
    #[derive(Debug)]
    pub struct TeenagersServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> TeenagersServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for TeenagersServer<T>
    where
        T: Teenagers,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/bilibili.app.interfaces.v1.Teenagers/FacialRecognitionVerify" => {
                    #[allow(non_camel_case_types)]
                    struct FacialRecognitionVerifySvc<T: Teenagers>(pub Arc<T>);
                    impl<
                        T: Teenagers,
                    > tonic::server::UnaryService<super::FacialRecognitionVerifyReq>
                    for FacialRecognitionVerifySvc<T> {
                        type Response = super::FacialRecognitionVerifyReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FacialRecognitionVerifyReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Teenagers>::facial_recognition_verify(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FacialRecognitionVerifySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.Teenagers/ModeStatus" => {
                    #[allow(non_camel_case_types)]
                    struct ModeStatusSvc<T: Teenagers>(pub Arc<T>);
                    impl<T: Teenagers> tonic::server::UnaryService<super::ModeStatusReq>
                    for ModeStatusSvc<T> {
                        type Response = super::ModeStatusReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ModeStatusReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Teenagers>::mode_status(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ModeStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.Teenagers/ModifyPwd" => {
                    #[allow(non_camel_case_types)]
                    struct ModifyPwdSvc<T: Teenagers>(pub Arc<T>);
                    impl<T: Teenagers> tonic::server::UnaryService<super::ModifyPwdReq>
                    for ModifyPwdSvc<T> {
                        type Response = super::ModifyPwdReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ModifyPwdReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Teenagers>::modify_pwd(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ModifyPwdSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.Teenagers/SetTeenagersModelAge" => {
                    #[allow(non_camel_case_types)]
                    struct SetTeenagersModelAgeSvc<T: Teenagers>(pub Arc<T>);
                    impl<
                        T: Teenagers,
                    > tonic::server::UnaryService<super::SetTeenagersModelAgeReq>
                    for SetTeenagersModelAgeSvc<T> {
                        type Response = super::SetTeenagersModelAgeReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetTeenagersModelAgeReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Teenagers>::set_teenagers_model_age(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetTeenagersModelAgeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.Teenagers/UpdateStatus" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateStatusSvc<T: Teenagers>(pub Arc<T>);
                    impl<
                        T: Teenagers,
                    > tonic::server::UnaryService<super::UpdateStatusReq>
                    for UpdateStatusSvc<T> {
                        type Response = super::UpdateStatusReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateStatusReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Teenagers>::update_status(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/bilibili.app.interfaces.v1.Teenagers/VerifyPwd" => {
                    #[allow(non_camel_case_types)]
                    struct VerifyPwdSvc<T: Teenagers>(pub Arc<T>);
                    impl<T: Teenagers> tonic::server::UnaryService<super::VerifyPwdReq>
                    for VerifyPwdSvc<T> {
                        type Response = super::VerifyPwdReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VerifyPwdReq>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Teenagers>::verify_pwd(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = VerifyPwdSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for TeenagersServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "bilibili.app.interfaces.v1.Teenagers";
    impl<T> tonic::server::NamedService for TeenagersServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
